#!/bin/bash
# shellcheck disable=SC2317,SC1090,SC1091,SC2086,SC2154

#rootdir="/scratch/ywang/MPAS/mpas_runscripts"
scpdir="$( cd "$( dirname "$0" )" && pwd )"              # dir of script
rootdir=$(realpath "$(dirname "${scpdir}")")
mpasdir=$(dirname "${rootdir}")

eventdateDF=$(date -u +%Y%m%d)

#-----------------------------------------------------------------------
#
# This is the 5th step of th WOFS-MPAS workflow. It run program atmosphere_model
# and its associated post-processing programs.
#
# Required files from ROOTDIR
#
# 0. module files in modules
#     build_jet_Rocky8_intel_smiol
#     env.mpas_smiol
#
# 1. exec                                   # The executables
#     atmosphere_model
#     mpassit
#     unipost.exe
#
# 2. templates                              # templates used in this scripts
#    README
#
#    2.1 SLURM scripts on Jet
#        run_mpas_array.slurm                or run_mpas_array.pbs
#        run_mpassit_array.slurm             or run_mpassit_array.pbs
#        run_upp_array.slurm
#
# 3. fix_files                              # runtime fix files for MPAS model and accompany programs
#
#    3.1 tables for Thompson cloud microphysics scheme
#        *MP_THOMPSON_QIautQS_DATA.DBL
#        *MP_THOMPSON_QRacrQG_DATA.DBL
#        *MP_THOMPSON_QRacrQS_DATA.DBL
#        *MP_THOMPSON_freezeH2O_DATA.DBL
#        CCN_ACTIVATE.BIN                   src/core_atmosphere/physics/TEMPO/tables
#
#        Can be generated by submitting job script "templates/build_tables.slurm"
#
#    3.2 MPASS run-time static files
#        stream_list.atmosphere.diagnostics_fcst
#        stream_list.atmosphere.output
#        stream_list.atmosphere.surface
#
#        *CAM_ABS_DATA.DBL
#        *CAM_AEROPT_DATA.DBL
#        *GENPARM.TBL
#        *LANDUSE.TBL
#        *OZONE_DAT.TBL
#        *OZONE_LAT.TBL
#        *OZONE_PLEV.TBL
#        *RRTMG_LW_DATA
#        *RRTMG_LW_DATA.DBL
#        *RRTMG_SW_DATA
#        *RRTMG_SW_DATA.DBL SOILPARM.TBL
#        *VEGPARM.TBL
#
#    3.3 Parameters for program MPASSIT
#        MPASSIT/diaglist
#        MPASSIT/histlist_2d
#        MPASSIT/histlist_3d.NSSL and MPASSIT/histlist_3d.THOM
#        MPASSIT/histlist_soil
#
#    3.4 UPP parameters (copied from "/lfs4/NAGAPE/hpc-wof1/ywang/MPAS/UPP_KATE_kjet")
#                    originally from "/lfs4/NAGAPE/wof/wrfout_3km-1km/UPP_KATE_kjet"
#
#        hrrr_params_grib2_tbl_new
#        hrrr_post_avblflds.xml
#        hrrr_postcntrl.xml
#        hrrr_postxconfig-NT.txt
#        crtm2_fix
#
#
#    NOTE:
#         * not in the git repository
#
# INSTRUCTIONS:
#
#  Use existing domain (wofs_mpas)
#
#     0. It should be run after "run_dacycles.sh".
#
#     1. Copy these directories to rootdir (or clone using git)
#        modules
#        exec
#        scripts
#        templates
#        fix_files (link needed files use script lnwrkfiles.sh, see README in that directory)
#
#     2. run_fcst.sh [YYYYmmddHH] [run_dirs] [jobnames]
#        Option "-h" gives a brief instruction about all the available options
#
# HOW THE CLEAN COMMAND WORKS:
#
#     1. By default "clean" will only delete working files, log files and
#        intermediated files for each task (both mpas and mpassit), but leave
#        the output file from these tasks as is.
#     2. "-c" option will delete the output files from the task, but
#        leave the runtime file and job script. So that user can run this
#        task again manually. By default it works for both tasks (mpas and mpassit),
#        if a task name is given, it will clean that task only.
#     3. "-a" option will clean the whole work directory for the corresponding task.
#
#-----------------------------------------------------------------------

function usage {
    echo " "
    echo "    USAGE: $0 [options] DATETIME [WORKDIR] [JOBS]"
    echo " "
    echo "    PURPOSE: Run MPAS free forecast based on analysis from the WoFS workflow."
    echo " "
    echo "    DATETIME - Case date and time in YYYYmmddHHMM/YYYYmmdd, Default eventdate is ${eventdateDF}"
    echo "               YYYYmmdd:     run all cycles from $eventtime to 0300. Or use options \"-s\" & \"-e\" to specify cycles."
    echo "               YYYYmmddHHMM: run this forecast cycle only."
    echo "    WORKDIR  - Run Directory"
    echo "    JOBS     - One or more jobs from [mpas,mpassit,upp,clean]"
    echo "               Default all jobs in sequence."
    echo " "
    echo "    OPTIONS:"
    echo "              -h                  Display this message"
    echo "              -n                  Show command to be run and generate job scripts only"
    echo "              -v                  Verbose mode"
    echo "              -k  [0,1,2]         Keep working directory if exist, 0- keep as is; 1- overwrite; 2- make a backup as xxxx.bak?"
    echo "                                  Default is 0 for ungrib, mpassit, upp and 1 for others"
    echo "              -t  DIR             Template directory for runtime files"
    echo "              -w                  Hold script to wait for all job conditions are satified and submitted (for mpassit & upp)."
    echo "                                  By default, the script will exit after submitting all possible jobs."
    echo "              -a/-c/-d            Works with the Clean command only, accept one argument {mpas,mpassit} or nothing."
    echo "                                  Default (Nothing): Deletes output files (log/standard output, etc.) only."
    echo "                                  -a: Deep clean of the whole working directory"
    echo "                                  -c: Delete output (netCDF) files from the specific task but keep done files."
    echo "                                  -d: Delete all done files"
    echo "              -m  Machine         Machine name to run on, [Jet, Cheyenne, Vecna]."
    echo "              -i  YYYYmmddHHMM    Initial time, default: same as start time from the command line argument"
    echo "              -s  YYYYmmddHHMM    Start date & time of the forecast cycles"
    echo "                  HHMM            Start time of the forecast cycles"
    echo "              -e  YYYYmmddHHMM    End date & time of the forecast cycles"
    echo "                  HHMM            End time of the forecast cycles"
    echo "              -r                  Realtime run, default: a retrospective run"
    echo "              -f conf_file        Configuration file for this case. Default: \${WORKDIR}/config.\${eventdate}"
    echo " "
    echo "   DEFAULTS:"
    echo "              eventdt = $eventdateDF"
    echo "              rootdir = $rootdir"
    echo "              WORKDIR = $mpasdir/run_dirs"
    echo "              TEMPDIR = $rootdir/templates"
    echo "              FIXDIR  = $rootdir/fix_files"
    echo " "
    echo "                                     -- By Y. Wang (2023.06.01)"
    echo " "
    exit "$1"
}

########################################################################
#
# Handle command line arguments
#
########################################################################

function parse_args {

    declare -Ag args

    #-------------------------------------------------------------------
    # Parse command line arguments
    #-------------------------------------------------------------------

    while [[ $# -gt 0 ]]; do
        key="$1"

        case $key in
            -h)
                usage 0
                ;;
            -n)
                args["dorun"]=false
                ;;
            -v)
                args["verb"]=1
                ;;
            -r)
                args["rt_run"]=true
                ;;
            -k)
                if [[ $2 =~ [012] ]]; then
                    args["overwrite"]=$2
                    shift
                else
                    echo -e "${RED}ERROR${NC}: option for ${BLUE}-k${NC} can only be [${YELLOW}0-2${NC}], but got ${PURPLE}$2${NC}."
                    usage 1
                fi
                ;;
            -w)
                args["jobwait"]=1
                ;;
            -c | -a | -d )
                args["cleanoption"]="$key"
                if [[ "$2" == "mpassit" || "$2" == "mpas" ]]; then
                    args["cleanjobs"]+=" $2"
                    shift
                fi
                ;;
            -t)
                if [[ -d $2 ]]; then
                    args["TEMPDIR"]=$2
                else
                    echo -e "${RED}ERROR${NC}: Template directory ${BLUE}$2${NC} does not exist."
                    usage 1
                fi
                shift
                ;;
            -m)
                if [[ ${2^^} == "JET" ]]; then
                    args["machine"]=Jet
                elif [[ ${2^^} == "VECNA" ]]; then
                    args["machine"]=Vecna
                elif [[ ${2^^} == "HERCULES" ]]; then
                    args["machine"]=Hercules
                elif [[ ${2^^} == "CHEYENNE" || ${2^^} == "DERECHO" ]]; then
                    args["machine"]=Cheyenne
                else
                    echo -e "${RED}ERROR${NC}: Unsupported machine name, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -f)
                args["config_file"]="$2"
                shift
                ;;
            #-i)
            #    if [[ $2 =~ ^[0-9]{12}$ ]]; then
            #        args["initdatetime"]=$2
            #    else
            #        echo -e "${RED}ERROR${NC}: Initial time should be ${GREEN}YYYYmmddHHMM${NC}, got ${PURPLE}$2${NC}."
            #        usage 1
            #    fi
            #    shift
            #    ;;
            -s )
                if [[ $2 =~ ^[0-9]{12}$ ]]; then
                    args["eventtime"]=${2:8:4}
                    eventhour=${2:8:2}
                    if ((10#$eventhour < 12)); then
                        args["eventdate"]=$(date -u -d "${2:0:8} 1 day ago" +%Y%m%d)
                    else
                        args["eventdate"]=${2:0:8}
                    fi
                elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                    args["eventtime"]="${2}"
                else
                    echo -e "${RED}ERROR${NC}: Start time should be in ${GREEN}YYYYmmddHHMM${NC} or ${GREEN}HHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -e )
                if [[ $2 =~ ^[0-9]{12}$ ]]; then
                    args["enddatetime"]=$2
                elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                    args["endhrmin"]=$2
                else
                    echo -e "${RED}ERROR${NC}: End time should be in ${GREEN}YYYYmmddHHMM${NC} or ${GREEN}HHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -*)
                echo -e "${RED}ERROR${NC}: Unknown option: ${PURPLE}$key${NC}"
                usage 2
                ;;
            mpassit* | mpas* | upp* | clean* )
                args["jobs"]="${key//,/ }"
                ;;
            *)
                if [[ $key =~ ^[0-9]{12}$ ]]; then
                    args["enddatetime"]=${key}
                    args["eventtime"]=${key:8:4}
                    eventhour=${key:8:2}
                    if ((10#$eventhour < 12)); then
                        args["eventdate"]=$(date -u -d "${key:0:8} 1 day ago" +%Y%m%d)
                    else
                        args["eventdate"]=${key:0:8}
                    fi
                    args["endhrmin"]=${key:8:4}
                elif [[ $key =~ ^[0-9]{8}$ ]]; then
                    args["eventdate"]=${key}
                elif [[ $key =~ ^[0-9]{4}$ ]]; then
                    args["eventtime"]=${key}
                elif [[ -d $key ]]; then
                    WORKDIR=$key
                    lastdir=$(basename $WORKDIR)
                    if [[ $lastdir =~ ^[0-9]{8}$ ]]; then
                        args["WORKDIR"]=$(dirname ${WORKDIR})
                        args["eventdate"]=${lastdir}
                    elif [[ $lastdir =~ ^[0-9]{12}$ ]]; then
                        args["WORKDIR"]=$(upnlevels ${WORKDIR} 3)
                        args["eventdate"]=${lastdir:0:8}
                        args["eventtime"]=${lastdir:8:4}
                        eventhour=${lastdir:8:2}
                        if ((10#$eventhour < 12)); then
                            args["eventdate"]=$(date -u -d "${args["eventdate"]} 1 day ago" +%Y%m%d)
                        fi
                    else
                        args["WORKDIR"]=$WORKDIR
                    fi
                    #echo $WORKDIR,$eventdate,$eventtime
                else
                    echo  -e "${RED}ERROR${NC}: unknown argument, get ${PURPLE}$key${NC}."
                    usage 3
                fi
                ;;
        esac
        shift # past argument or value
    done
}

########################################################################

function run_mpas {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, npefcst
    # RETURN: mpas_jobscript

    local isec jsec dawrkdir

    #
    # Build working directory
    #
    mkwrkdir ${wrkdir} 0
    cd ${wrkdir} || return

    timestr=$(date -u -d @${iseconds} +%H%M)
    dawrkdir=${rundir}/dacycles${daffix}/${timestr}
    #
    # Waiting for job conditions
    #
    conditions=("${rundir}/lbc/done.${domname}" "${dawrkdir}/done.update_states" "${dawrkdir}/done.update_bc")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                #if [[ $verb -eq 1 ]]; then
                #    echo "Waiting for file: $cond"
                #fi
                sleep 10
            done
        done
    fi

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.fcst || -f $wrkdir/done.fcst || -f $wrkdir/queue.fcst ]]; then
        return
    fi

    #
    # Preparation for all members
    #
    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefcst} ]]; then
        split_graph "${gpmetis}" "${domname}.graph.info" "${npefcst}" "$rundir/$domname" "$dorun" "$verb"
    fi

    currtime_str=$(date -u -d @$iseconds +%Y-%m-%d_%H:%M:%S)
    currtime_fil=${currtime_str//:/.}

    #
    # Preparation for each member
    # nenslbc/pbl_schemes/sfclayer_schemes are from the config file
    #
    if [[ -z ${coef_3rd_order} ]];      then coef_3rd_order=1.0;       fi
    if [[ -z ${smagorinsky_coef} ]];    then smagorinsky_coef=0.25;    fi
    if [[ -z ${visc4_2dsmag} ]];        then visc4_2dsmag=0.125;       fi
    if [[ -z ${h_mom_eddy_visc4} ]];    then h_mom_eddy_visc4=0.0;     fi
    if [[ -z ${h_theta_eddy_visc4} ]];  then h_theta_eddy_visc4=0.25;  fi
    if [[ -z ${h_scalar_eddy_visc4} ]]; then h_scalar_eddy_visc4=0.25; fi
    if [[ -z ${smdiv} ]];               then smdiv=0.1;                fi

    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        basen=$(( (iens-1)%6 ))
        if [[ $basen -lt 2 ]]; then     # map to 0,1,2
            idx=0
        elif [[ $basen -lt 4 ]]; then
            idx=1
        else
            idx=2
        fi
        pblscheme=${pbl_schemes[$idx]}
        sfcscheme=${sfclayer_schemes[$idx]}

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 1
        cd $memwrkdir || return

        if ${relative_path}; then
            casedir=$(realpath -m --relative-to=. ${rundir})
            dadir=$(realpath -m --relative-to=. $dawrkdir)
        else
            casedir=${rundir}
            dadir=${dawrkdir}
        fi
        #
        # init files
        #
        do_restart="false"
        do_dacyle="false"
        if [[ ${damode} == "restart" ]]; then
            do_restart="true"
            do_dacyle="true"
        fi

        initfile="${dadir}/fcst_${memstr}/${domname}_${memstr}.${damode}.${currtime_fil}.nc"
        ln -sf ${initfile} .
        ln -sf ${casedir}/init/${domname}.invariant.nc .

        if [[ $verb -eq 1 ]]; then
            mecho0 "Member: $iens init file: ${initfile}";
        fi

        #
        # lbc files
        #
        jens=$(( (iens-1)%nenslbc+1 ))
        mlbcstr=$(printf "%02d" $jens)

        mpastime_str=$(date -u -d @$iseconds +%Y-%m-%d_%H.%M.%S)
        lbc_dafile=${dadir}/fcst_${memstr}/${domname}_${memstr}.lbc.${mpastime_str}.nc
        lbc_myfile=${domname}_${memstr}.lbc.${mpastime_str}.nc
        if [[ $dorun == true ]]; then
            if [[ ! -e ${lbc_dafile} ]]; then     # impossible condition unless not actual run
                mecho0 "File: ${lbc_dafile} not exist."
                exit 1
            fi
        fi
        ln -sf ${lbc_dafile} ${lbc_myfile}
        if [[ $verb -eq 1 ]]; then
            mecho0 "Member: $iens lbc file ${mpastime_str}: ${lbc_dafile}";
        fi

        for ((i=EXTINVL;i<=fcst_seconds;i+=EXTINVL)); do
            isec=$(( iseconds+i ))           # MPAS expects time string
            jsec=$(( iseconds/3600*3600+i )) # External GRIB file provided around to whole hour
            lbctime_str=$(date -u -d @$jsec +%Y-%m-%d_%H.%M.%S)
            mpastime_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)
            lbc_file="${casedir}/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str}.nc"
            ln -sf $lbc_file ${domname}_${memstr}.lbc.${mpastime_str}.nc
            if [[ $verb -eq 1 ]]; then
                mecho0 "Member: $iens lbc file ${mpastime_str}: ${lbc_file}";
            fi
        done

        ln -sf ${casedir}/${domname}/$domname.graph.info.part.${npefcst} .

        streamlists=(stream_list.atmosphere.diagnostics_fcst stream_list.atmosphere.output stream_list.atmosphere.surface)
        for fn in "${streamlists[@]}"; do
            cp -f ${FIXDIR}/$fn .
        done

        datafiles=(  CAM_ABS_DATA.DBL  CAM_AEROPT_DATA.DBL GENPARM.TBL       LANDUSE.TBL    \
                     OZONE_DAT.TBL     OZONE_LAT.TBL       OZONE_PLEV.TBL    RRTMG_LW_DATA  \
                     RRTMG_LW_DATA.DBL RRTMG_SW_DATA       RRTMG_SW_DATA.DBL SOILPARM.TBL   \
                     VEGPARM.TBL )

        for fn in "${datafiles[@]}"; do
            ln -sf ${FIXDIR}/$fn .
        done

        if [[ "${mpscheme}" == "Thompson" ]]; then
            thompson_tables=( MP_THOMPSON_QRacrQG_DATA.DBL   MP_THOMPSON_QRacrQS_DATA.DBL   \
                              MP_THOMPSON_freezeH2O_DATA.DBL MP_THOMPSON_QIautQS_DATA.DBL CCN_ACTIVATE.BIN)

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        fi

        fcsthr_str=$(printf "%02d:00:00" $((fcst_seconds/3600)))

        cat << EOF > namelist.atmosphere
&nhyd_model
    config_time_integration_order   = 2
    config_dt                       = ${time_step}
    config_start_time               = '${currtime_str}'
    config_run_duration             = '${fcsthr_str}'
    config_split_dynamics_transport = true
    config_number_of_sub_steps      = 4
    config_dynamics_split_steps     = 3
    config_h_mom_eddy_visc2         = 0.0
    config_h_mom_eddy_visc4         = ${h_mom_eddy_visc4}
    config_v_mom_eddy_visc2         = 0.0
    config_h_theta_eddy_visc2       = 0.0
    config_h_theta_eddy_visc4       = ${h_theta_eddy_visc4}
    config_v_theta_eddy_visc2       = 0.0
    config_h_scalar_eddy_visc4      = ${h_scalar_eddy_visc4}
    config_horiz_mixing             = '2d_smagorinsky'
    config_len_disp                 = 3000.0
    config_visc4_2dsmag             = ${visc4_2dsmag}
    config_w_adv_order              = 3
    config_theta_adv_order          = 3
    config_scalar_adv_order         = 3
    config_u_vadv_order             = 3
    config_w_vadv_order             = 3
    config_theta_vadv_order         = 3
    config_scalar_vadv_order        = 3
    config_scalar_advection         = true
    config_monotonic                = true
    config_coef_3rd_order           = ${coef_3rd_order}
    config_epssm                    = 0.1
    config_smdiv                    = ${smdiv}
    config_smagorinsky_coef         = ${smagorinsky_coef}
/
&damping
    config_mpas_cam_coef             = 2.0
    config_rayleigh_damp_u           = true
    config_zd                        = 16000.0
    config_xnutr                     = 0.2
    config_number_cam_damping_levels = 8
/
&limited_area
    config_apply_lbcs                = true
/
&io
    config_pio_num_iotasks           = NNNODE
    config_pio_stride                = NNCORE
/
&decomposition
    config_block_decomp_file_prefix  = '${domname}.graph.info.part.'
/
&restart
    config_do_restart                = ${do_restart}
    config_do_DAcycling              = ${do_dacyle}
/
&printout
    config_print_global_minmax_sca   = true
    config_print_global_minmax_vel   = true
    config_print_detailed_minmax_vel = false
/
&IAU
    config_IAU_option                = 'off'
    config_IAU_window_length_s       = 21600.
/
&physics
    config_sst_update                = false
    config_sstdiurn_update           = false
    config_deepsoiltemp_update       = false
    config_radtlw_interval           = '00:05:00'
    config_radtsw_interval           = '00:05:00'
    config_bucket_update             = 'none'
    config_lsm_scheme                = '${MPASLSM}'
    num_soil_layers                  = ${MPASNFLS}
    config_microp_re                 = true
    config_physics_suite             = 'convection_permitting'
    config_convection_scheme         = 'off'
    config_frac_seaice               = false
    config_pbl_scheme                = '${pblscheme}'
    config_sfclayer_scheme           = '${sfcscheme}'
EOF

        if [[ ${mpscheme} == "mp_nssl2m" ]]; then

            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
/
&nssl_mp_params
    ehw0                             = 0.9
    ehlw0                            = 0.9
    icefallfac                       = 1.5
    snowfallfac                      = 1.25
    iusewetsnow                      = 0
EOF

        fi

        cat << EOF >> namelist.atmosphere
/
&soundings
    config_sounding_interval         = 'none'
/
&assimilation
    config_jedi_da                   = false
/
&development
    config_halo_exch_method          = 'mpas_halo'
/
EOF

        cat << EOF > streams.atmosphere
<streams>
<immutable_stream name="input"
                  type="input"
                  filename_template="${domname}_${memstr}.init.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  input_interval="initial_only" />

<immutable_stream name="invariant"
                  type="input"
                  filename_template="${domname}.invariant.nc"
                  input_interval="initial_only" />

<immutable_stream name="restart"
                  type="input;output"
                  filename_template="${domname}_${memstr}.restart.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  input_interval="initial_only"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" />

<stream name="output"
                  type="output"
                  filename_template="${domname}_${memstr}.history.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.output"/>
</stream>

<stream name="diagnostics"
                  type="output"
                  filename_template="${domname}_${memstr}.diag.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.diagnostics_fcst"/>
</stream>

<stream name="surface"
                  type="input"
                  filename_template="${domname}_${memstr}.sfc_update.nc"
                  filename_interval="none"
                  input_interval="none" >

    <file name="stream_list.atmosphere.surface"/>
</stream>

<immutable_stream name="iau"
                  type="input"
                  filename_template="${domname}_${memstr}.AmB.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="none"
                  packages="iau"
                  input_interval="initial_only" />

<immutable_stream name="lbc_in"
                  type="input"
                  filename_template="${domname}_${memstr}.lbc.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="input_interval"
                  packages="limited_area"
                  input_interval="${EXTINVL_STR}" />

EOF
        if [[ ${outpsfc} == true ]]; then
            cat << EOF >> streams.atmosphere
<stream name="psfc"
        type="output"
        filename_template="psfc_${memstr}.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
        clobber_mode="replace_files"
        precision="single"
        io_type="pnetcdf,cdf5"
        output_interval="${OUTINVL_STR}">

        <var name="surface_pressure"/>
        <var name="tend_sfc_pressure"/>
        <var name="latCell"/>
        <var name="lonCell"/>
        <var name="xtime"/>
</stream>

EOF
        fi

        echo "</streams>" >> streams.atmosphere

        jobarrays+=("$iens")
    done

    #
    # Create job script and submit it
    #
    cd $wrkdir || return

    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    # undefined variables are from the config file
    declare -A jobParms=(
        [PARTION]="${partition_fcst}"
        [NOPART]="$npefcst"
        [NNODES]="${nnodes_fcst}"
        [JOBNAME]="mpas-${eventdate:4:4}_${eventtime}"
        [CPUSPEC]="${claim_cpu_fcst}"
        [CLAIMTIME]="${claim_time_fcst}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_fcst}"
        jobParms[NCORES]="${ncores_fcst}"
    fi

    submit_a_job "${wrkdir}" "fcst" "jobParms" "${TEMPDIR}/run_mpas_array.${mach}" "${mpas_jobscript}" "${jobarraystr}"
}

########################################################################

function run_mpassit {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # Build working directory
    #
    wrkdir=$wrkdir/mpassit
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    #
    # Check MPASSIT status
    #
    if [[ -f done.mpassit ]]; then
        mecho0 "MPASSIT done for all forecast minutes"
        return
    fi

    if [[ -f running.mpassit || -f queue.mpassit ]]; then
        mecho0 "MPASSIT is running/queued for all forecast minutes"
        #check_job_status "mpassit mem" $wrkdir $ENS_SIZE run_mpassit.${mach} ${num_resubmit}
        #if [[ -f done.mpassit ]]; then
        #    mecho0 "MPASSIT done for all forecast minutes"
        #fi
        return
    fi

    if [[ -f error.mpassit ]]; then
        mecho0 "MPASSIT failed for all forecast minutes "
        return
    fi

    n=0; fcst_minutes=()
    for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
        minstr=$(printf "%03d" $((i/60)))

        if [[ -f running.mpassit$minstr || -f queue.mpassit$minstr ]]; then
            check_job_status "mpassit$minstr mem" $wrkdir $ENS_SIZE run_mpassit_$minstr.${mach} ${num_resubmit}
            if [[ -f done.mpassit$minstr ]]; then
                mecho0 "MPASSIT done for ensemble forecasts at ${minstr}"
                (( n+=1 ))
            else
                mecho0 "MPASSIT is running/queued for ensemble forecasts at ${minstr}"
            fi
            continue
        fi

        if [[ -f done.mpassit$minstr ]]; then
            mecho0 "MPASSIT done for ensemble forecasts at ${minstr}"
            #done_mins+=("${minstr}")
            (( n+=1 ))
            continue
        fi

        if [[ -f error.mpassit$minstr ]]; then
            mecho0 "MPASSIT failed for forecast at ${minstr}"
            continue
        fi

        fcst_minutes+=("${minstr}")
    done

    #if [[ ${#done_mins[@]} -gt 0 ]]; then
    #    mecho0 "MPASSIT done: [${done_mins[*]}]"
    #fi

    n_fcst=$(( (fcst_seconds-diag_start)/OUTINVL+1 ))
    if [[ $n -eq $n_fcst ]]; then
        touch done.mpassit
        rm -rf done.mpassit???
        mecho0 "MPASSIT done for all forecast minutes"
    fi

    #
    # Prepare MPASSIT working files
    #
    if [[ ${#fcst_minutes[@]} -gt 0 ]]; then
        if [[ "${mpscheme}" == "Thompson" ]]; then
            fileappend="THOM"
        else
            fileappend="NSSL"
        fi

        jobarrays=()
        for mem in $(seq 1 $ENS_SIZE); do
            memstr=$(printf "%02d" $mem)
            memdir=$wrkdir/mem$memstr
            mkwrkdir $memdir 0
            cd $memdir || return

            rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

            # Linking working file for this member
            parmfiles=(diaglist histlist_2d histlist_3d histlist_soil)
            for fn in "${parmfiles[@]}"; do
                if [[ ! -e $fn ]]; then
                    #if [[ $verb -eq 1 ]]; then echo "Linking $fn ..."; fi
                    if [[ -e $FIXDIR/MPASSIT/${fn}.${fileappend} ]]; then
                        ln -sf $FIXDIR/MPASSIT/${fn}.${fileappend} $fn
                    elif [[ -e $FIXDIR/MPASSIT/${fn} ]]; then
                        ln -sf $FIXDIR/MPASSIT/$fn .
                    else
                        mecho0 "${RED}ERROR${NC}: file ${BLUE}$FIXDIR/MPASSIT/${fn}${NC} not exist."
                        return
                    fi
                fi
            done
            jobarrays+=("$mem")
        done

        jobarrays_str=$(get_jobarray_str "${mach}" "${jobarrays[@]}")

        cd $wrkdir || return

        if [[ $rt_run == true ]]; then
            run_mpassit_onetime "${wrkdir}" "${iseconds}" "${fcst_minutes[*]}" "${jobarrays_str}"
        else
            run_mpassit_alltimes "${wrkdir}" "${iseconds}" "${fcst_minutes[*]}" "${jobarrays_str}"
        fi
    fi
}

########################################################################

function run_mpassit_onetime {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local fcsttimes
    local -r jobarraystr=$4

    IFS=" " read -r -a fcsttimes <<< "$3"

    cd $wrkdir || return

    # Loop over forecast minutes
    for minstr in "${fcsttimes[@]}"; do

        (( i=10#${minstr}*60 ))
        prepare_mpassit_onetime $wrkdir ${iseconds} $i 30
        local estatus=$?               # number of missing members
        if [[ ${estatus} -gt 0 ]]; then
        #    echo -e " ${PURPLE}${estatus}${NC} files missing"
            continue
        #else
        #    echo -e " ${GREEN}Ready${NC}"
        fi

        #
        # Create job script and submit it
        #
        jobscript="run_mpassit_$minstr.${mach}"

        declare -A jobParms=(
            [PARTION]="${partition_post}"
            [NOPART]="${npepost}"
            [JOBNAME]="mpassit${minstr}_${eventtime}"
            [CPUSPEC]="${claim_cpu_post}"
            [CLAIMTIME]="${claim_time_mpassit_onetime}"
            [HHMINSTR]="$minstr"
            [FCST_START]="${i}"
            [FCST_END]="${i}"
            [FCST_INTVL]="${OUTINVL}"
        )
        if [[ "${mach}" == "pbs" ]]; then
            jobParms[NNODES]="${nnodes_post}"
            jobParms[NCORES]="${ncores_post}"
        fi

        submit_a_job "${wrkdir}" "mpassit$minstr" "jobParms" "${TEMPDIR}/run_mpassit_array.${mach}" "${jobscript}" "${jobarraystr}"
    done
}

########################################################################

function run_mpassit_alltimes {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local fcsttimes
    local -r jobarraystr=$4

    IFS=" " read -r -a fcsttimes <<< "$3"

    cd $wrkdir || return

    # Loop over forecast minutes
    local missed=false
    local minsec=${fcst_seconds}
    local maxsec=0

    for minstr in "${fcsttimes[@]}"; do
        (( i=10#${minstr}*60 ))
        (( i > maxsec )) && maxsec=$i
        (( i < minsec )) && minsec=$i

        prepare_mpassit_onetime $wrkdir ${iseconds} $i 2
        local estatus=$?               # number of missing members
        if [[ ${estatus} -gt 0 ]]; then
            #echo -e " ${PURPLE}${estatus}${NC} files missing"
            missed=true
            continue
        #else
        #    echo -e " ${GREEN}done${NC}"
        fi
    done

    if [[ ${#fcsttimes[@]} -gt 0 && ${missed} == false ]]; then
        #
        # Create job script and submit it
        #
        cd $wrkdir || return

        jobscript="run_mpassit.${mach}"

        declare -A jobParms=(
            [PARTION]="${partition_post}"
            [NOPART]="$npepost"
            [JOBNAME]="mpassit_${eventtime}"
            [CPUSPEC]="${claim_cpu_post}"
            [CLAIMTIME]="${claim_time_mpassit_alltimes}"
            [HHMINSTR]=""
            [FCST_START]="${minsec}"
            [FCST_END]="${maxsec}"
            [FCST_INTVL]="${OUTINVL}"
        )
        if [[ "${mach}" == "pbs" ]]; then
            jobParms[NNODES]="${nnodes_post}"
            jobParms[NCORES]="${ncores_post}"
        fi

        submit_a_job "$wrkdir" "mpassit" "jobParms" "$TEMPDIR/run_mpassit_array.${mach}" "$jobscript" "$jobarraystr"
    fi
}

########################################################################

function prepare_mpassit_onetime {
    # Work for one forecast time and all ensemble members
    # 1. Wait for the history/diag files
    # 2. Create namelist files

    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local -r fctseconds=$3
    local -r waitseconds=$4   # run all time together, it does not have to wait

    cd $wrkdir || return

    minstr=$(printf "%03d" $((fctseconds/60)))
    fcst_lauch_time=$(date -u -d @${iseconds} +%H%M)

    isec=$(( iseconds+fctseconds ))
    fcst_time_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

    if [[ $dorun == true ]]; then
        mecho0n "Checking forecast files at ${WHITE}$minstr${NC} for all $ENS_SIZE memebers from fcst${daffix}/${fcst_lauch_time} ..."
    fi

    jobarrays=()
    missing=0
    for mem in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $mem)
        memdir=$wrkdir/mem$memstr
        mkwrkdir $memdir 0
        cd $memdir || return

        if ${relative_path}; then
            casedir=$(realpath -m --relative-to=. ${rundir})
            fcstmemdir="../.."
        else
            casedir=${rundir}
            fcstmemdir=$(upnlevels $memdir 2)
        fi

        rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

        histfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.history.${fcst_time_str}.nc"
        diagfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.diag.${fcst_time_str}.nc"

        if [[ $dorun == true ]]; then
            for fn in $histfile $diagfile; do
                #mecho0 "Checking ${fn} ..."
                while [[ ! -f $fn ]]; do
                    if [[ $jobwait -eq 0 ]]; then    # do not wait for it
                        (( missing+=1 ))
                        continue 3                   # go ahead to process next hour
                    fi

                    if [[ $verb -eq 1 ]]; then
                        mecho0 "Waiting for $fn ..."
                    fi
                    sleep 10
                done
                fileage=$(( $(date +%s) - $(stat -c %Y -- "$fn") ))
                if [[ $fileage -lt $waitseconds ]]; then
                    if [[ $verb -eq 1 ]]; then mecho0 "Waiting for $fn ..."; fi
                    sleep "$waitseconds"
                fi
            done
        fi

        nmlfile="namelist.fcst_$minstr"
        cat << EOF > $nmlfile
&config
    grid_file_input_grid = "${casedir}/init/${domname}_${memstr}.init.nc"
    hist_file_input_grid = "$histfile"
    diag_file_input_grid = "$diagfile"
    file_target_grid     = "${casedir}/${domname/*_/geo_}/geo_em.d01.nc"
    target_grid_type     = "file"
    output_file          = "./MPASSIT_${memstr}.${fcst_time_str}.nc"
    interp_diag          = .true.
    interp_hist          = .true.
    wrf_mod_vars         = .true.
    esmf_log             = .false.
/
EOF
    done

    if [[ $dorun == true ]]; then
        if [[ $missing -gt 0 ]]; then
            echo -e " ${PURPLE}${missing}${NC} files missing"
        else
            echo -e " ${GREEN}Ready${NC}"
        fi
    fi

    cd $wrkdir || return

    return ${missing}
}

########################################################################

function run_upp {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # Build working directory
    #
    wrkdir=$wrkdir/upp
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    # these arrays are referred indirectly later
    # shellcheck disable=SC2034
    fixfiles_AerosolCoeff=( AerosolCoeff.bin )
    # shellcheck disable=SC2034
    fixfiles_CloudCoeff=( CloudCoeff.bin )
    # shellcheck disable=SC2034
    fixfiles_EmisCoeff=( EmisCoeff.bin )

    # shellcheck disable=SC2034
    fixfiles_SpcCoeff=( amsre_aqua.SpcCoeff.bin       imgr_g11.SpcCoeff.bin    \
        imgr_g12.SpcCoeff.bin     imgr_g13.SpcCoeff.bin  imgr_g15.SpcCoeff.bin  \
        imgr_insat3d.SpcCoeff.bin imgr_mt1r.SpcCoeff.bin imgr_mt2.SpcCoeff.bin  \
        seviri_m10.SpcCoeff.bin   ssmi_f13.SpcCoeff.bin  ssmi_f14.SpcCoeff.bin  \
        ssmi_f15.SpcCoeff.bin     ssmis_f16.SpcCoeff.bin ssmis_f17.SpcCoeff.bin \
        ssmis_f18.SpcCoeff.bin    ssmis_f19.SpcCoeff.bin ssmis_f20.SpcCoeff.bin \
        tmi_trmm.SpcCoeff.bin     v.seviri_m10.SpcCoeff.bin)

    # shellcheck disable=SC2034
    fixfiles_TauCoeff=( amsre_aqua.TauCoeff.bin       imgr_g11.TauCoeff.bin    \
        imgr_g12.TauCoeff.bin     imgr_g13.TauCoeff.bin  imgr_g15.TauCoeff.bin  \
        imgr_insat3d.TauCoeff.bin imgr_mt1r.TauCoeff.bin imgr_mt2.TauCoeff.bin  \
        seviri_m10.TauCoeff.bin   ssmi_f13.TauCoeff.bin  ssmi_f14.TauCoeff.bin  \
        ssmi_f15.TauCoeff.bin     ssmis_f16.TauCoeff.bin ssmis_f17.TauCoeff.bin \
        ssmis_f18.TauCoeff.bin    ssmis_f19.TauCoeff.bin ssmis_f20.TauCoeff.bin \
        tmi_trmm.TauCoeff.bin )

    declare -A fixdirs
    #declare -A fixfiles fixdirs
    #fixfiles[AerosolCoeff]=fixfiles_AerosolCoeff[@]
    #fixfiles[CloudCoeff]=fixfiles_CloudCoeff[@]
    #fixfiles[EmisCoeff]=fixfiles_EmisCoeff[@]
    #fixfiles[SpcCoeff]=fixfiles_SpcCoeff[@]
    #fixfiles[TauCoeff]=fixfiles_TauCoeff[@]
    fixfiles=( AerosolCoeff CloudCoeff EmisCoeff SpcCoeff TauCoeff )

    fixdirs[AerosolCoeff]="$FIXDIR/UPP/crtm2_fix/AerosolCoeff/Big_Endian"
    fixdirs[CloudCoeff]="$FIXDIR/UPP/crtm2_fix/CloudCoeff/Big_Endian"
    fixdirs[EmisCoeff]="$FIXDIR/UPP/crtm2_fix/EmisCoeff/Big_Endian"
    fixdirs[SpcCoeff]="$FIXDIR/UPP/crtm2_fix/SpcCoeff/Big_Endian"
    fixdirs[TauCoeff]="$FIXDIR/UPP/crtm2_fix/TauCoeff/ODPS/Big_Endian"

    eventtimestr=$(date -u -d @$iseconds +%Y%m%d%H%M)

    for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
        imin=$((i/60))
        minstr=$(printf "%03d" $imin)
        ihour=$((imin/60))
        iminute=$((imin%60))
        if [[ $iminute -eq 0 ]]; then
            upptimestr=$(printf "%02d" $ihour)
        else
            upptimestr=$(printf "%02d.%02d" $ihour $iminute)
        fi

        if [[  -f $wrkdir/done.upp$minstr || -f $wrkdir/queue.upp$minstr ]]; then
            continue      # already done, or is in queue, skip this hour
        fi

        if [[  -f $wrkdir/running.upp$minstr ]]; then
            fileage=$(( $(date +%s) - $(stat -c %Y -- "$wrkdir/running.upp$minstr") ))
            if [[ $fileage -lt 300 ]]; then
                continue                        # Job is running, skip
            else                                # > 5 minutes, May be a time out issue
                rm $wrkdir/running.upp$minstr
            fi
        fi

        #if [[  -f $wrkdir/error.upp_$minstr ]]; then
            # resubmission may solve the problem
        #fi

        mpassitdir=$(upnlevels $wrkdir 1)

        donefile="$mpassitdir/mpassit/done.mpassit$minstr"

        if [[ $dorun == true ]]; then
            mecho0 "Checking $donefile ...."
            while [[ ! -f $donefile && ! -f "$mpassitdir/mpassit/done.mpassit" ]]; do
                if [[ $jobwait -eq 0 ]]; then     # do not wait
                    continue 2                    # go ahread to process next forecast hour
                fi

                #if [[ $verb -eq 1 ]]; then
                #    echo "Waiting for $donefile ..."
                #fi
                sleep 10
            done
        fi

        isec=$(( iseconds+i ))
        fcst_time_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

        jobarrays=()
        for mem in $(seq 1 $ENS_SIZE); do
            memstr=$(printf "%02d" $mem)
            memdir=$wrkdir/mem$memstr
            mkwrkdir $memdir 0
            cd $memdir || return

            mpassitmemdir=${memdir/upp/mpassit}

            mpasfile="$mpassitmemdir/MPASSIT_${memstr}.${fcst_time_str}.nc"

            mkwrkdir $memdir/post_$minstr 1
            cd $memdir/post_$minstr || return

            #for coeff in ${!fixfiles[@]}; do
            #    echo "$coeff"
            #    for fn in ${!fixfiles[$coeff][@]}; do
            for coeff in "${fixfiles[@]}"; do
                #eval filearray=\( \${fixfiles_${coeff}[@]} \)
                fixfilename="fixfiles_${coeff}[@]"
                for fn in "${!fixfilename}"; do
                    #echo "$coeff -> ${fixdirs[$coeff]}/$fn"
                    ln -sf ${fixdirs[$coeff]}/$fn .
                done
            done

            #
            #...Link microphysic's tables - code will use based on mp_physics option
            #   found in data
            #
            ln -sf $FIXDIR/WRFV4.0/ETAMPNEW_DATA               nam_micro_lookup.dat
            ln -sf $FIXDIR/WRFV4.0/ETAMPNEW_DATA.expanded_rain hires_micro_lookup.dat

            #
            #...For GRIB2 the code uses postcntrl.xml to select variables for output
            #   the available fields are defined in post_avlbflds.xml -- while we
            #   set a link to this file for reading during runtime it is not typical
            #   for one to update this file, therefore the link goes back to the
            #   program directory - this is true for params_grib2_tbl_new also - a
            #   file which defines the GRIB2 table values
            #
            parmfiles=(params_grib2_tbl_new post_avblflds.xml postcntrl.xml postxconfig-NT.txt )
            for fn in "${parmfiles[@]}"; do
                ln -sf $FIXDIR/UPP/hrrr_$fn $fn
            done

            nmlfile="itag"
            cat << EOF > $nmlfile
$mpasfile
netcdf
grib2
${fcst_time_str//./:}
RAPR
EOF
            jobarrays+=("$mem")
        done

        #
        # Create job script and submit it
        #
        cd $wrkdir || return
        if [[ ${#jobarrays} -gt 0 ]]; then
            jobscript="run_upp$minstr.slurm"
            jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

            # shellcheck disable=SC2034
            declare -A jobParms=(
                [PARTION]="${partition_post}"
                [NOPART]="$npepost"
                [CPUSPEC]="${claim_cpu_post}"
                [JOBNAME]="upp${minstr}_${eventtime}"
                [HHMINSTR]="$minstr"
                [UPPDATE]="$upptimestr"
                [EVENTDATE]="$eventtimestr"
            )
            submit_a_job "$wrkdir" "upp$minstr" "jobParms" "$TEMPDIR/run_upp_array.slurm" "$jobscript" "$jobarraystr"
        fi
    done
}

########################################################################

function fcst_driver() {
    #
    #  Free forecast driver from an analysis cycle
    #

    # $1     $2
    # start  end       in seconds
    local start_sec=$1
    local end_sec=$2

    #
    # Build working directory
    #
    wrkdir=$rundir/fcst${daffix}
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg date_end
    date_beg=$(date -u -d @$start_sec +%Y%m%d%H%M)
    date_end=$(date -u -d @$end_sec +%Y%m%d%H%M)

    echo -e "Forecasting cycles from ${GREEN}$date_beg${NC} to ${LIGHT_BLUE}$date_end${NC} ...."

    # fcst_length_seconds/fcst_launch_intvl from the config file
    for ilaunch in $(seq $start_sec ${fcst_launch_intvl} $end_sec ); do
        #timestr_curr=$(date -u -d @$ilaunch +%Y%m%d%H%M)
        eventtime=$(date -u -d @$ilaunch +%H%M)

        eventMM=$(date -u -d @$ilaunch +%M)
        fcstindex=1
        if [[ "${eventMM}" == "00" ]]; then fcstindex=0; fi
        fcst_seconds=${fcst_length_seconds[$fcstindex]}

        fcstwrkdir=$wrkdir/${eventtime}
        mkwrkdir $fcstwrkdir 0        # keep original directory
        cd $fcstwrkdir || return

        if [[ $dorun == true && $jobwait -eq 1 ]]; then
            num_resubmit=2               # resubmit failed jobs one more times (give it a 2nd chance)
        else
            num_resubmit=0               # Just check job status
        fi

        echo ""
        echo -e "- FCST Cycle at ${eventtime} - ${CYAN}$(date +'%Y-%m-%d %H:%M:%S (%Z)')${NC}"
        time1=$(date +%s)

        if [[ " ${jobs[*]} " =~ " mpas " ]]; then
            #------------------------------------------------------
            # 1. Model forecast for all members
            #------------------------------------------------------
            if [[ $verb -eq 1 ]]; then echo "  Run MPAS model at $eventtime"; fi

            mpas_jobscript="run_mpas.${mach}"
            run_mpas $fcstwrkdir $ilaunch

            #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
            check_job_status "fcst" $fcstwrkdir $ENS_SIZE $mpas_jobscript ${num_resubmit}
        fi

        if [[ " ${jobs[*]} " =~ " mpassit " ]]; then
            #------------------------------------------------------
            # 2. Interpolate the forecast datasets to a virtual WRF grid
            #------------------------------------------------------
            if [[ $verb -eq 1 ]]; then echo "  Run MPASSIT at $eventtime"; fi

            run_mpassit $fcstwrkdir $ilaunch

            if [[ $rt_run == true ]]; then
                for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
                    minstr=$(printf "%03d" $((i/60)))
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_job_status "mpassit$minstr mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit_$minstr.${mach} ${num_resubmit}
                done
            else
                check_job_status "mpassit mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit.${mach} ${num_resubmit}
            fi
        fi

        if [[ " ${jobs[*]} " =~ " upp " ]]; then
            #------------------------------------------------------
            # 3. Post-processing the data on the WRF grid
            #------------------------------------------------------
            if [[ $dorun == true ]]; then
                if [[ $rt_run == true ]]; then
                    for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
                        minstr=$(printf "%03d" $((i/60)))
                        if [[ ! -e $fcstwrkdir/mpassit/done.mpassit$minstr ]]; then
                            #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                            check_job_status "mpassit$minstr mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit_$minstr.slurm
                        fi
                    done
                else
                    check_job_status "mpassit mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit.slurm
                fi
            fi

            if [[ $verb -eq 1 ]]; then echo "  Run UPP at $eventtime"; fi

            run_upp $fcstwrkdir $ilaunch

            if [[ $dorun == true && $jobwait -eq 1 ]]; then
                for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
                    minstr=$(printf "%03d" $((i/60)))
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_job_status "upp$minstr mem" $fcstwrkdir/upp $ENS_SIZE run_upp_$minstr.slurm ${num_resubmit}
                done
            fi
        fi

        #------------------------------------------------------
        # This FCST cycle is done
        #------------------------------------------------------
        time2=$(date +%s)
        if [[ $time2 -gt $time1 ]]; then
            (( secoffset = time2-time1 )); (( minoffset = secoffset/60 )); (( secoffset = secoffset%60 ))
            echo -e "= Cycle ${eventtime} took ${CYAN}${minoffset}:${secoffset}${NC} minutes:seconds."
        fi

    done
}

########################################################################

function run_clean {
    # $1     $2    $3      $4
    # start  end   option  tasks
    local start_sec=$1
    local end_sec=$2
    local coption=$3
    local jobs
    read -r -a jobs <<< "$4"

    wrkdir=$rundir/fcst${daffix}

    if [[ "$coption" == "-a" ]]; then
        declare -A cleanmsg=(
            [mpas]="all MPAS forecast files"
            [mpassit]="all MPASSIT converted files on WRF grid"
            [upp]="all UPP converted grib2 files"
        )
        for job in "${jobs[@]}"; do
            echo    ""
            mecho0  "${BROWN}WARNING${NC}: Delete ${cleanmsg[$job]} from $(date -u -d @${start_sec} +%Y%m%d_%H:%M:%S) to $(date -u -d @${end_sec} +%Y%m%d_%H:%M:%S)"
            mecho0  "         in ${CYAN}${wrkdir}${NC} ?\n"
            mecho0n "[${YELLOW}YES,NO${NC}]? "
            read -r doit
            if [[ ${doit^^} == "YES" ]]; then
                mecho0 "${BROWN}WARNING${NC}: ${cleanmsg[$job]} will be cleaned."
            else
                mecho0 "Got ${PURPLE}${doit^^}${NC}, do nothing."
                return
            fi
        done
    fi

    local show="echo"
    if [[ $dorun == true ]]; then
        show=""
    fi

    for isec in $(seq ${start_sec} ${fcst_launch_intvl} ${end_sec} ); do
        #timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date -u -d @$isec +%H%M)

        eventMM=$(date -u -d @$isec +%M)
        fcstindex=1
        if [[ "${eventMM}" == "00" ]]; then fcstindex=0; fi
        fcst_seconds=${fcst_length_seconds[$fcstindex]}

        fcstwrkdir=$wrkdir/$eventtime
        if [[ -d $fcstwrkdir ]]; then
            cd $fcstwrkdir || return

            if [[ $verb -eq 1 ]]; then mecho0 "    Cleaning working directory ${CYAN}${fcstwrkdir}${NC}"; fi

            for dirname in "${jobs[@]}"; do

                cd $fcstwrkdir || return

                case $dirname in
                mpas )
                    ${show} rm -f fcst_??/error.fcst_* fcst_??/log.????.abort fcst_??/dart_log.*
                    ${show} rm -f fcst_??/log.atmosphere.????.{out,err}  fcst_??/namelist.output fcst_*_*.log
                    #echo "clean mpas in $fcstwrkdir"
                    #clean_mem_runfiles "fcst" $fcstwrkdir $ENS_SIZE
                    done=0
                    for mem in $(seq 1 $ENS_SIZE); do
                        memstr=$(printf "%02d" $mem)
                        memdir="$fcstwrkdir/fcst_$memstr"

                        if [[ "$coption" == "-a" ]]; then
                            ${show} rm -rf $memdir
                            ${show} rm -f fcst_${mem}_*.log
                            (( done+=1 ))
                        else
                            donefile="$memdir/done.fcst_$memstr"
                            if [[ -e $donefile ]]; then
                                ${show} rm -f fcst_${mem}_*.log
                                #rm $donefile
                                (( done+=1 ))
                            fi
                            #ls $memdir/${domname}_??.{diag,history}.*.nc
                            if [[ "$coption" == "-c" ]]; then
                                ${show} rm -f $memdir/${domname}_??.{diag,history}.*.nc
                            elif [[ "$coption" == "-d" ]]; then
                                ${show} rm -f $memdir/${domname}_??.{diag,history}.*.nc
                                ${show} rm -f fcst_??/done.fcst_* done.fcst
                            fi
                        fi
                    done
                    if [[ $done -eq $ENS_SIZE ]]; then
                        rm -f queue.fcst
                        rm -f fcst_*/done.fcst_*
                        touch done.fcst
                    fi
                    ;;
                mpassit )
                    mywrkdir=$fcstwrkdir/mpassit
                    if [[ -d $mywrkdir ]]; then
                        if [[ "$coption" == "-a" ]]; then
                            cd $fcstwrkdir || return
                            ${show} rm -rf mpassit
                        else
                            cd $mywrkdir || return
                            for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
                                minstr=$(printf "%03d" $((i/60)))

                                done=0
                                for mem in $(seq 1 $ENS_SIZE); do
                                    memstr=$(printf "%02d" $mem)
                                    memdir="$mywrkdir/mem$memstr"

                                    donefile="$memdir/done.mpassit${minstr}_$memstr"
                                    if [[ -e $donefile ]]; then
                                        ${show} rm -f $mywrkdir/mpassit${minstr}_${mem}_*.log
                                        #rm $donefile
                                        (( done+=1 ))
                                    fi
                                    ${show} rm -f $memdir/PET*.ESMF_LogFile
                                done

                                if [[ $done -eq $ENS_SIZE ]]; then
                                    rm -f queue.mpassit${minstr} running.mpassit$minstr
                                    rm -f mem*/done.mpassit${minstr}_*
                                    touch done.mpassit${minstr}
                                fi
                            done
                            if [[ "$coption" == "-c" ]]; then
                                ${show} rm -f ${mywrkdir}/mem??/MPASSIT_*.nc
                            elif [[ "$coption" == "-d" ]]; then
                                ${show} rm -f ${mywrkdir}/mem??/MPASSIT_*.nc
                                ${show} rm -f done.mpassit done.mpassit* mem*/done.mpassit*
                            fi
                        fi
                    fi
                    ;;
                upp )
                    mywrkdir=$fcstwrkdir/upp
                    if [[ -r $mywrkdir ]]; then
                        cd $mywrkdir || return
                        for ((i=diag_start;i<=fcst_seconds;i+=OUTINVL)); do
                            minstr=$(printf "%03d" $((i/60)))

                            done=0
                            for mem in $(seq 1 $ENS_SIZE); do
                                memstr=$(printf "%02d" $mem)
                                memdir="$mywrkdir/mem$memstr"

                                postdir="$memdir/post_${minstr}"

                                if [[ "$coption" == "-a" ]]; then
                                    ${show} rm -rf $memdir
                                    ${show} rm -f $mywrkdir/upp${minstr}_${mem}_*.log
                                    (( done+=1 ))
                                else
                                    donefile="$memdir/done.upp${minstr}_$memstr"
                                    if [[ -e $donefile ]]; then
                                        ${show} rm -f $mywrkdir/upp${minstr}_${mem}_*.log
                                        ${show} rm -rf $postdir
                                        (( done+=1 ))
                                    fi
                                fi
                            done

                            if [[ $done -eq $ENS_SIZE ]]; then
                                rm -f queue.upp${minstr} running.upp$minstr
                                rm -f mem*/done.upp${minstr}_*
                                touch done.upp${minstr}
                            fi
                        done
                    fi
                    ;;
                esac
            done
        else
            mecho0 "${RED}ERROR${NC}: Working directory ${CYAN}${fcstwrkdir}${NC} does not exist."
        fi
    done
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
#@ MAIN entry
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

source $scpdir/Common_Utilfuncs.sh || exit $?

#-----------------------------------------------------------------------
#
# Handle command line arguments (override default settings)
#
#-----------------------------------------------------------------------
#% ARGS

parse_args "$@"

[[ -v args["verb"] ]]        && verb=${args["verb"]}           || verb=0
[[ -v args["overwrite"] ]]   && overwrite=${args["overwrite"]} || overwrite=0

[[ -v args["dorun"] ]]       && dorun=${args["dorun"]}         || dorun=true
[[ -v args["rt_run"] ]]      && rt_run=${args["rt_run"]}       || rt_run=false  # realtime run?
[[ -v args["jobwait"] ]]     && jobwait=${args["jobwait"]}     || jobwait=0

[[ -v args["cleanoption"] ]] && cleanoption=${args["cleanoption"]}              || cleanoption="clean"
[[ -v args["cleanjobs"] ]]   && read -r -a cleanjobs <<< "${args['cleanjobs']}" || cleanjobs=()

#-----------------------------------------------------------------------
#
# Get jobs to run
#
#-----------------------------------------------------------------------

[[ -v args["jobs"] ]] && read -r -a jobs <<< "${args['jobs']}" || jobs=(mpas mpassit clean)

#-----------------------------------------------------------------------
#
# Set up working environment
#
#-----------------------------------------------------------------------
FIXDIR="${rootdir}/fix_files"
# shellcheck disable=SC2034
EXEDIR="${rootdir}/exec"                                                # use inside submit_a_job

source "${scpdir}/Site_Runtime.sh" || exit $?

setup_machine "${args['machine']}" "$rootdir" false false

[[ $dorun == false ]] && runcmd="echo $runcmd"

[[ -v args["WORKDIR"] ]] && WORKDIR=${args["WORKDIR"]} || WORKDIR="${workdirDF}"
[[ -v args["TEMPDIR"] ]] && TEMPDIR=${args["TEMPDIR"]} || TEMPDIR="${rootdir}/templates"

#-----------------------------------------------------------------------
#
# Set Event Date and Time
#
#-----------------------------------------------------------------------
[[ -v args["eventdate"] ]] && eventdate="${args['eventdate']}" || eventdate="$eventdateDF"
[[ -v args["eventtime"] ]] && eventtime="${args['eventtime']}" || eventtime="1700"
#[[ -v args["initdatetime"] ]] && initdatetime="${args['initdatetime']}" || initdatetime="${eventdate}1700"

eventhour=${eventtime:0:2}
if ((10#$eventhour < 12)); then
    startday="1 day"
else
    startday=""
fi

if [[ -v args["endhrmin"] ]]; then
    endhrmin="${args['endhrmin']}"
    endhour=${endhrmin:0:2}
    if ((10#$endhour < 12)); then
        enddatetime=$(date -u -d "$eventdate $endhrmin 1 day" +%Y%m%d%H%M)
    else
        enddatetime=$(date -u -d "$eventdate $endhrmin" +%Y%m%d%H%M)
    fi
elif [[ -v args["enddatetime"] ]]; then
    enddatetime="${args['enddatetime']}"
else
    enddatetime=$(date -u -d "$eventdate 03:00 1 day" +%Y%m%d%H%M)
fi

#inittime_sec=$(date -u -d "${initdatetime:0:8} ${initdatetime:8:4}" +%s)
starttime_sec=$(date -u -d "${eventdate} ${eventtime} $startday"     +%s)
stoptime_sec=$(date  -u -d "${enddatetime:0:8}  ${enddatetime:8:4}"  +%s)

#-----------------------------------------------------------------------
#
# read configurations that is not set from command line
#
#-----------------------------------------------------------------------
if [[  -v args["config_file"] ]]; then
    config_file="${args['config_file']}"

    if [[ -r ${config_file} ]]; then
        :
    elif [[ -e ${WORKDIR}/${config_file} ]]; then
        config_file="${WORKDIR}/${config_file}"
    else
        echo -e "${RED}ERROR${NC}: file ${CYAN}${config_file}${NC} not exist."
        usage 1
    fi
else
    config_file="$WORKDIR/config.${eventdate}"
fi

if [[ ! -r ${config_file} ]]; then
    echo -e "${RED}ERROR${NC}: Configuration file ${CYAN}${config_file}${NC} is not found."
    echo -e "       Please run ${GREEN}setup_mpas-wofs.sh${NC} first or use ${BLUE}-h${NC} to show help."
    exit 2
else
    echo -e "Reading case (${GREEN}${eventdate}${NC}) configuration file: ${CYAN}${config_file}${NC} ...."
fi
readconf ${config_file} COMMON MPAS_OPTIONS fcst || exit $?
# get ENS_SIZE, time_step, EXTINVL, OUTINVL, OUTIOTYPE

#
# Check configurations reading in
#
if [[ "${damode}" == "restart" ]]; then
    diag_start=${OUTINVL}
elif [[ "${damode}" == "init" ]]; then
    diag_start=0
else
    echo -e "${RED}ERROR${NC}: damode=${damode} is not supported."
    usage 1
fi

if [[ "${mpscheme}" =~ ^(mp_nssl2m|mp_thompson)$ ]]; then
    :
else
    echo -e "${RED}ERROR${NC}: mpscheme=${mpscheme} is not supported."
    usage 1
fi

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Perform FCST cycles
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#% ENTRY

rundir="$WORKDIR/${eventdate}"
if [[ ! -d $rundir ]]; then
    mkdir -p $rundir
fi

echo    "---- Jobs ($$) started $(date '+%m-%d_%H:%M:%S (%Z)') on host $(hostname) ----"
echo -e "  Event date : ${GREEN}$eventdate${NC} ${YELLOW}${eventtime}${NC} --> ${LIGHT_BLUE}${enddatetime:0:8}${NC} ${YELLOW}${enddatetime:8:4}${NC}"
echo -e "  Root    dir: $rootdir${GREEN}/exec${NC}|${PURPLE}/templates${NC}|${DARK}/fix_files${NC}|${BROWN}/scripts${NC}"
echo -e "  Working dir: $WORKDIR${LIGHT_BLUE}/${eventdate}/fcst${daffix}${NC}"
echo -e "  Domain name: ${PURPLE}$domname${NC};  MP scheme: ${BROWN}${mpscheme}${NC}"
echo    " "

EXTINVL_STR=$(printf "%02d:00:00" $((EXTINVL/3600)) )
OUTINVL_STR=$(printf "00:%02d:00" $((OUTINVL/60)) )
RSTINVL_STR="10:00:00"         # turn off restart file output

#
# Start the forecast driver
#
if [[ " ${jobs[*]} " =~ " mpas " || " ${jobs[*]} " =~ " mpassit " || " ${jobs[*]} " =~ " upp " ]]; then
    fcst_driver $starttime_sec $stoptime_sec          #  $1: start     $2: end      in seconds
elif [[ " ${jobs[*]} " =~ " clean " ]]; then
    if [[ ${#cleanjobs[@]} -eq 0 ]]; then
        cleanjobs=("mpas" "mpassit" "upp")
    fi
    run_clean "${starttime_sec}" "${stoptime_sec}" "${cleanoption}" "${cleanjobs[*]}"
fi


echo " "
echo "==== Jobs done $(date '+%m-%d_%H:%M:%S (%Z)') ===="
echo " "

exit 0
