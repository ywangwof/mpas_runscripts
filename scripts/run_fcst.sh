#!/bin/bash
# shellcheck disable=SC1090,SC1091,SC2086

#rootdir="/scratch/ywang/MPAS/mpas_runscripts"
scpdir="$( cd "$( dirname "$0" )" && pwd )"              # dir of script
rootdir=$(realpath "$(dirname "${scpdir}")")

eventdateDF=$(date -u +%Y%m%d)

#-----------------------------------------------------------------------
#
# This is the 5th step of th WOFS-MPAS workflow. It run program atmosphere_model
# and its associated post-processing programs.
#
# Required files from ROOTDIR
#
# 0. module files in modules
#     build_jet_intel18_1.11_smiol
#     build_jet_intel18_1.11                # PIO version
#
# 1. exec                                   # The executables
#     atmosphere_model.single
#     mpassit
#     unipost.exe
#
# 2. templates                              # templates used in this scripts
#    README
#
#    2.1 SLURM scripts on Jet
#        run_mpas_array.slurm                or run_mpas_array.pbs
#        run_mpassit_array.slurm             or run_mpassit_array.pbs
#        run_upp_array.slurm
#
# 3. fix_files                              # runtime fix files for MPAS model and accompany programs
#
#    3.1 tables for Thompson cloud microphysics scheme
#        *MP_THOMPSON_QIautQS_DATA.DBL
#        *MP_THOMPSON_QRacrQG_DATA.DBL
#        *MP_THOMPSON_QRacrQS_DATA.DBL
#        *MP_THOMPSON_freezeH2O_DATA.DBL
#
#        Can be generated by submitting job script templates/build_tables.slurm
#
#    3.2 MPASS run-time static files
#        stream_list.atmosphere.diagnostics
#        stream_list.atmosphere.output
#        stream_list.atmosphere.surface
#
#        *CAM_ABS_DATA.DBL
#        *CAM_AEROPT_DATA.DBL
#        *GENPARM.TBL
#        *LANDUSE.TBL
#        *OZONE_DAT.TBL
#        *OZONE_LAT.TBL
#        *OZONE_PLEV.TBL
#        *RRTMG_LW_DATA
#        *RRTMG_LW_DATA.DBL
#        *RRTMG_SW_DATA
#        *RRTMG_SW_DATA.DBL SOILPARM.TBL
#        *VEGPARM.TBL
#
#    3.3 Parameters for program MPASSIT
#        MPASSIT/diaglist
#        MPASSIT/histlist_2d
#        MPASSIT/histlist_3d.NSSL and MPASSIT/histlist_3d.THOM
#        MPASSIT/histlist_soil
#
#    3.4 UPP parameters (copied from "/lfs4/NAGAPE/hpc-wof1/ywang/MPAS/UPP_KATE_kjet")
#                    originally from "/lfs4/NAGAPE/wof/wrfout_3km-1km/UPP_KATE_kjet"
#
#        hrrr_params_grib2_tbl_new
#        hrrr_post_avblflds.xml
#        hrrr_postcntrl.xml
#        hrrr_postxconfig-NT.txt
#        crtm2_fix
#
#
#    NOTE:
#         * not in the git repository
#
# INSTRUCTIONS:
#
#  Use existing domain (wofs_mpas)
#     1. Copy these directories to rootdir (or clone using git)
#        modules
#        exec
#        scripts
#        templates
#        fix_files (link needed files use script lnwrkfiles.sh, see README in that directory)
#
#     2. make a run directory under rootdir
#        run_dirs
#
#     3. Copy existing domain directories $rootdir/run_dirs/wofs_maps & geo_mpas to
#        your run_dirs
#
#     4. run_fcst.sh [YYYYmmddHH] [run_dirs] [jobnames]
#
#-----------------------------------------------------------------------

function usage {
    echo " "
    echo "    USAGE: $0 [options] DATETIME [WORKDIR] [JOBS]"
    echo " "
    echo "    PURPOSE: Run MPAS free forecast based on analysis from the WoFS workflow."
    echo " "
    echo "    DATETIME - Case date and time in YYYYmmddHHMM/YYYYmmdd, Default eventdate is ${eventdateDF}"
    echo "               YYYYmmdd:     run all cycles from $eventtime to 0300. Or use options \"-s\" & \"-e\" to specify cycles."
    echo "               YYYYmmddHHMM: run this forecast cycle only."
    echo "    WORKDIR  - Run Directory"
    echo "    JOBS     - One or more jobs from [mpas,mpassit,upp] or [clean_fcst,clean_mpassit, clean_upp]"
    echo "               Default all jobs in sequence"
    echo " "
    echo "    OPTIONS:"
    echo "              -h              Display this message"
    echo "              -n              Show command to be run and generate job scripts only"
    echo "              -v              Verbose mode"
    echo "              -k  [0,1,2]     Keep working directory if exist, 0- keep as is; 1- overwrite; 2- make a backup as xxxx.bak?"
    echo "                              Default is 0 for ungrib, mpassit, upp and 1 for others"
    echo "              -t  DIR         Template directory for runtime files"
    echo "              -w              Hold script to wait for all job conditions are satified and submitted (for mpassit & upp)."
    echo "                              By default, the script will exit after submitting all possible jobs."
    echo "              -m  Machine     Machine name to run on, [Jet, Cheyenne, Vecna]."
    echo "              -d  wofs_mpas   Domain name to be used"
    echo "              -i  YYYYmmddHHMM    Initial time, default: same as start time from the command line argument"
    echo "              -s  YYYYmmddHHMM    Start date & time of the forecast cycles"
    echo "                  HHMM            Start time of the forecast cycles"
    echo "              -e  YYYYmmddHHMM    End date & time of the forecast cycles"
    echo "                  HHMM            End time of the forecast cycles"
    echo "              -p  nssl        MP scheme, [nssl, thompson], default: nssl"
    echo "              -r              Realtime run, default: retrospective run"
    echo " "
    echo "   DEFAULTS:"
    echo "              eventdt = $eventdateDF"
    echo "              rootdir = $rootdir"
    echo "              WORKDIR = $rootdir/run_dirs"
    echo "              TEMPDIR = $rootdir/templates"
    echo "              FIXDIR  = $rootdir/fix_files"
    echo " "
    echo "                                     -- By Y. Wang (2023.06.01)"
    echo " "
    exit "$1"
}

########################################################################

function run_mpas {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, npefcst
    # RETURN: mpas_jobscript

    local isec jsec dawrkdir

    #
    # Build working directory
    #
    mkwrkdir ${wrkdir} 0
    cd ${wrkdir} || return

    timestr=$(date -u -d @${iseconds} +%H%M)
    dawrkdir=${rundir}/dacycles/${timestr}
    #
    # Waiting for job conditions
    #
    conditions=("${rundir}/lbc/done.lbc" "${dawrkdir}/done.update_states" "${dawrkdir}/done.update_bc")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                #if [[ $verb -eq 1 ]]; then
                #    echo "Waiting for file: $cond"
                #fi
                sleep 10
            done
        done
    fi

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.fcst || -f $wrkdir/done.fcst || -f $wrkdir/queue.fcst ]]; then
        return
    fi

    #
    # Preparation for all members
    #
    # shellcheck disable=SC2154
    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefcst} ]]; then
        cd $rundir/$domname || return
        if [[ $verb -eq 1 ]]; then
            echo "Generating ${domname}.graph.info.part.${npefcst} in $rundir/$domname using $exedir/gpmetis"
        fi
        $exedir/gpmetis -minconn -contig -niter=200 ${domname}.graph.info ${npefcst} > gpmetis.out$npefcst
        estatus=$?
        if [[ ${estatus} -ne 0 ]]; then
            echo "${estatus}: $exedir/gpmetis -minconn -contig -niter=200 ${domname}.graph.info ${npefcst}"
            exit ${estatus}
        fi
        cd $wrkdir || return
    fi

    currtime_str=$(date -u -d @$iseconds +%Y-%m-%d_%H:%M:%S)
    currtime_fil=${currtime_str//:/.}

    #
    # Preparation for each member
    # nenslbc/pbl_schemes/sfclayer_schemes are from the config file
    #
    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        basen=$(( (iens-1)%6 ))
        if [[ $basen -lt 2 ]]; then     # map to 0,1,2
            idx=0
        elif [[ $basen -lt 4 ]]; then
            idx=1
        else
            idx=2
        fi
        # shellcheck disable=SC2154
        pblscheme=${pbl_schemes[$idx]}
        # shellcheck disable=SC2154
        sfcscheme=${sfclayer_schemes[$idx]}

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 1
        cd $memwrkdir || return

        #
        # init files
        #
        ln -sf $dawrkdir/fcst_${memstr}/${domname}_${memstr}.restart.${currtime_fil}.nc .
        do_restart="true"
        do_dacyle="true"

        #
        # lbc files
        #
        # shellcheck disable=SC2154         #undefined variable nenslbc
        jens=$(( (iens-1)%nenslbc+1 ))
        mlbcstr=$(printf "%02d" $jens)

        mpastime_str=$(date -u -d @$iseconds +%Y-%m-%d_%H.%M.%S)
        lbc_dafile=${dawrkdir}/fcst_${memstr}/${domname}_${memstr}.lbc.${mpastime_str}.nc
        lbc_myfile=${domname}_${memstr}.lbc.${mpastime_str}.nc
        if [[ $dorun == true ]]; then
            if [[ ! -e ${lbc_dafile} ]]; then     # impossible condition unless not actual run
                echo "File: ${lbc_dafile} not exist."
                exit 1
            fi
        fi
        ln -sf ${lbc_dafile} ${lbc_myfile}

        for ((i=EXTINVL;i<=fcst_seconds;i+=EXTINVL)); do
            isec=$(( iseconds+i ))           # MPAS expects time string
            jsec=$(( iseconds/3600*3600+i )) # External GRIB file provided around to whole hour
            lbctime_str=$(date -u -d @$jsec +%Y-%m-%d_%H.%M.%S)
            mpastime_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)
            ln -sf $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str}.nc ${domname}_${memstr}.lbc.${mpastime_str}.nc
        done

        ln -sf $rundir/$domname/$domname.graph.info.part.${npefcst} .


        streamlists=(stream_list.atmosphere.diagnostics stream_list.atmosphere.output stream_list.atmosphere.surface)
        for fn in "${streamlists[@]}"; do
            cp -f ${FIXDIR}/$fn .
        done

        datafiles=(  CAM_ABS_DATA.DBL  CAM_AEROPT_DATA.DBL GENPARM.TBL       LANDUSE.TBL    \
                     OZONE_DAT.TBL     OZONE_LAT.TBL       OZONE_PLEV.TBL    RRTMG_LW_DATA  \
                     RRTMG_LW_DATA.DBL RRTMG_SW_DATA       RRTMG_SW_DATA.DBL SOILPARM.TBL   \
                     VEGPARM.TBL )

        for fn in "${datafiles[@]}"; do
            ln -sf ${FIXDIR}/$fn .
        done

        if [[ "${mpscheme}" == "Thompson" ]]; then
            thompson_tables=( MP_THOMPSON_QRacrQG_DATA.DBL   MP_THOMPSON_QRacrQS_DATA.DBL   \
                              MP_THOMPSON_freezeH2O_DATA.DBL MP_THOMPSON_QIautQS_DATA.DBL )

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        fi

        fcsthr_str=$(printf "%02d:00:00" $((fcst_seconds/3600)))

        # shellcheck disable=SC2154
        cat << EOF > namelist.atmosphere
&nhyd_model
    config_time_integration_order   = 2
    config_dt                       = ${time_step}
    config_start_time               = '${currtime_str}'
    config_run_duration             = '${fcsthr_str}'
    config_split_dynamics_transport = true
    config_number_of_sub_steps      = 2
    config_dynamics_split_steps     = 3
    config_h_mom_eddy_visc2         = 0.0
    config_h_mom_eddy_visc4         = 0.0
    config_v_mom_eddy_visc2         = 0.0
    config_h_theta_eddy_visc2       = 0.0
    config_h_theta_eddy_visc4       = 0.0
    config_v_theta_eddy_visc2       = 0.0
    config_horiz_mixing             = '2d_smagorinsky'
    config_len_disp                 = 3000.0
    config_visc4_2dsmag             = 0.05
    config_w_adv_order              = 3
    config_theta_adv_order          = 3
    config_scalar_adv_order         = 3
    config_u_vadv_order             = 3
    config_w_vadv_order             = 3
    config_theta_vadv_order         = 3
    config_scalar_vadv_order        = 3
    config_scalar_advection         = true
    config_positive_definite        = false
    config_monotonic                = true
    config_coef_3rd_order           = 0.25
    config_epssm                    = 0.1
    config_smdiv                    = 0.1
/
&damping
    config_mpas_cam_coef             = 2.0
    config_rayleigh_damp_u           = true
    config_zd                        = 16000.0
    config_xnutr                     = 0.2
    config_number_cam_damping_levels = 8
/
&limited_area
    config_apply_lbcs                = true
/
&io
    config_pio_num_iotasks           = NNNODE
    config_pio_stride                = NNCORE
/
&decomposition
    config_block_decomp_file_prefix  = '${domname}.graph.info.part.'
/
&restart
    config_do_restart                = ${do_restart}
    config_do_DAcycling              = ${do_dacyle}
/
&printout
    config_print_global_minmax_sca   = true
    config_print_global_minmax_vel   = true
    config_print_detailed_minmax_vel = false
/
&IAU
    config_IAU_option                = 'off'
    config_IAU_window_length_s       = 21600.
/
&physics
    config_sst_update                = false
    config_sstdiurn_update           = false
    config_deepsoiltemp_update       = false
    config_radtlw_interval           = '00:05:00'
    config_radtsw_interval           = '00:05:00'
    config_bucket_update             = 'none'
    config_lsm_scheme                = '${MPASLSM}'
    num_soil_layers                  = ${MPASNFLS}
    config_microp_re                 = true
    config_physics_suite             = 'convection_permitting'
    config_frac_seaice               = false
    config_pbl_scheme                = '${pblscheme}'
    config_sfclayer_scheme           = '${sfcscheme}'
EOF

        if [[ ${mpscheme} == "mp_nssl2m" ]]; then

            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
/
&nssl_mp_params
    ehw0                             = 0.9
    ehlw0                            = 0.9
    icefallfac                       = 1.5
    snowfallfac                      = 1.25
    iusewetsnow                      = 0
EOF

        fi

        cat << EOF >> namelist.atmosphere
/
&soundings
    config_sounding_interval         = 'none'
/
&assimilation
    config_jedi_da                   = false
/
&development
    config_halo_exch_method          = 'mpas_halo'
/
EOF

        cat << EOF > streams.atmosphere
<streams>
<immutable_stream name="input"
                  type="input"
                  filename_template="${domname}_${memstr}.init.nc"
                  input_interval="initial_only" />

<immutable_stream name="restart"
                  type="input;output"
                  filename_template="${domname}_${memstr}.restart.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  input_interval="initial_only"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" />

<stream name="output"
                  type="output"
                  filename_template="${domname}_${memstr}.history.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.output"/>
</stream>

<stream name="diagnostics"
                  type="output"
                  filename_template="${domname}_${memstr}.diag.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.diagnostics"/>
</stream>

<stream name="surface"
                  type="input"
                  filename_template="${domname}_${memstr}.sfc_update.nc"
                  filename_interval="none"
                  input_interval="none" >

    <file name="stream_list.atmosphere.surface"/>
</stream>

<immutable_stream name="iau"
                  type="input"
                  filename_template="${domname}_${memstr}.AmB.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="none"
                  packages="iau"
                  input_interval="initial_only" />

<immutable_stream name="lbc_in"
                  type="input"
                  filename_template="${domname}_${memstr}.lbc.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="input_interval"
                  packages="limited_area"
                  input_interval="${EXTINVL_STR}" />

</streams>
EOF
        jobarrays+=("$iens")
    done

    #
    # Create job script and submit it
    #
    cd $wrkdir || return

    # shellcheck disable=SC2154
    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    # undefined variables are from the config file
    sedfile=$(mktemp -t mpas_${eventtime}.sed_XXXX)
    # shellcheck disable=SC2154
    cat <<EOF > $sedfile
s/PARTION/${partition_fcst}/
s/NOPART/$npefcst/
s/JOBNAME/mpas_${eventtime}/
s/CPUSPEC/${claim_cpu_fcst}/g
s/CLAIMTIME/${claim_time_fcst}/
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
s/SAVETAG/nothing_xxx/
EOF
    # shellcheck disable=SC2154
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/${nnodes_fcst}/;s/NCORES/${ncores_fcst}/" >> $sedfile
    fi

    submit_a_jobscript "${wrkdir}" "fcst" "${sedfile}" "${TEMPDIR}/run_mpas_array.${mach}" "${mpas_jobscript}" "${jobarraystr}"
}

########################################################################

function run_mpassit {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # Build working directory
    #
    wrkdir=$wrkdir/mpassit
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    #
    # Check MPASSIT status
    #
    if [[ -f done.mpassit ]]; then
        echo "$$-${FUNCNAME[0]}: MPASSIT done for all forecast minutes"
        return
    fi

    if [[ -f running.mpassit || -f queue.mpassit ]]; then
        echo "$$-${FUNCNAME[0]}: MPASSIT is running/queued for all forecast minutes"
        return
    fi

    if [[ -f error.mpassit ]]; then
        echo "$$-${FUNCNAME[0]}: MPASSIT failed for all forecast minutes "
        return
    fi

    n=0; fcst_minutes=()
    for ((i=OUTINVL;i<=fcst_seconds;i+=OUTINVL)); do
        minstr=$(printf "%03d" $((i/60)))

        if [[ -f done.mpassit$minstr ]]; then
            echo "$$-${FUNCNAME[0]}: MPASSIT done for forecast at ${minstr}"
            (( n+=1 ))
            continue
        fi

        if [[ -f running.mpassit$minstr || -f queue.mpassit$minstr ]]; then
            echo "$$-${FUNCNAME[0]}: MPASSIT is running/queued for forecast at ${minstr}"
            continue
        fi

        if [[ -f error.mpassit$minstr ]]; then
            echo "$$-${FUNCNAME[0]}: MPASSIT failed for forecast at ${minstr}"
            continue
        fi

        fcst_minutes+=("${minstr}")
    done

    n_fcst=$((fcst_seconds/OUTINVL))
    if [[ $n -eq $n_fcst ]]; then
        touch done.mpassit
        rm -rf done.mpassit???
        echo "$$-${FUNCNAME[0]}: MPASSIT done for all forecast minutes"
    fi

    #
    # Prepare MPASSIT working files
    #
    if [[ ${#fcst_minutes[@]} -gt 0 ]]; then
        if [[ "${mpscheme}" == "Thompson" ]]; then
            fileappend="THOM"
        else
            fileappend="NSSL"
        fi

        jobarrays=()
        for mem in $(seq 1 $ENS_SIZE); do
            memstr=$(printf "%02d" $mem)
            memdir=$wrkdir/mem$memstr
            mkwrkdir $memdir 0
            cd $memdir || return

            rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

            # Linking working file for this member
            parmfiles=(diaglist histlist_2d histlist_3d histlist_soil)
            for fn in "${parmfiles[@]}"; do
                if [[ ! -e $fn ]]; then
                    #if [[ $verb -eq 1 ]]; then echo "Linking $fn ..."; fi
                    if [[ -e $FIXDIR/MPASSIT/${fn}.${fileappend} ]]; then
                        ln -sf $FIXDIR/MPASSIT/${fn}.${fileappend} $fn
                    elif [[ -e $FIXDIR/MPASSIT/${fn} ]]; then
                        ln -sf $FIXDIR/MPASSIT/$fn .
                    else
                        echo "ERROR: file \"$FIXDIR/MPASSIT/${fn}\" not exist."
                        return
                    fi
                fi
            done
            jobarrays+=("$mem")
        done

        jobarrays_str=$(get_jobarray_str "${mach}" "${jobarrays[@]}")

        cd $wrkdir || return

        if [[ $rt_run == true ]]; then
            run_mpassit_oneAtime "${wrkdir}" "${iseconds}" "${fcst_minutes[*]}" "${jobarrays_str}"
        else
            run_mpassit_alltimes "${wrkdir}" "${iseconds}" "${fcst_minutes[*]}" "${jobarrays_str}"
        fi
    fi
}

########################################################################

function run_mpassit_oneAtime {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local fcsttimes
    local -r jobarraystr=$4

    IFS=" " read -r -a fcsttimes <<< "$3"

    cd $wrkdir || return

    # Loop over forecast minutes
    for minstr in "${fcsttimes[@]}"; do

        (( i=10#${minstr}*60 ))
        mpassit_wait_create_nml_onetime $wrkdir ${iseconds} $i 30
        local estatus=$?               # number of missing members
        if [[ ${estatus} -gt 0 ]]; then
            continue
        fi

        #
        # Create job script and submit it
        #
        jobscript="run_mpassit_$minstr.${mach}"

        sedfile=$(mktemp -t mpassit_${eventtime}_$minstr.sed_XXXX)
        # shellcheck disable=SC2154
        cat <<EOF > $sedfile
s/PARTION/${partition_post}/
s/NOPART/$npepost/
s/JOBNAME/mpassit${minstr}_${eventtime}/
s/CPUSPEC/${claim_cpu_post}/
s/CLAIMTIME/${claim_time_mpassit_onetime}/
s/HHMINSTR/$minstr/g
s/FCST_START/${i}/
s/FCST_END/${i}/
s/FCST_INTVL/${OUTINVL}/
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
EOF

        # shellcheck disable=SC2154
        if [[ "${mach}" == "pbs" ]]; then
            echo "s/NNODES/${nnodes_post}/;s/NCORES/${ncores_post}/" >> $sedfile
        fi

        submit_a_jobscript "${wrkdir}" "mpassit$minstr" "${sedfile}" "${TEMPDIR}/run_mpassit_array.${mach}" "${jobscript}" "${jobarraystr}"
    done
}

########################################################################

function run_mpassit_alltimes {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local fcsttimes
    local -r jobarraystr=$4

    IFS=" " read -r -a fcsttimes <<< "$3"

    cd $wrkdir || return

    # Loop over forecast minutes
    local missed=false
    local minsec=${fcst_seconds}
    local maxsec=0

    for minstr in "${fcsttimes[@]}"; do
        (( i=10#${minstr}*60 ))
        (( i > maxsec )) && maxsec=$i
        (( i < minsec )) && minsec=$i

        mpassit_wait_create_nml_onetime $wrkdir ${iseconds} $i 2
        local estatus=$?               # number of missing members
        if [[ ${estatus} -gt 0 ]]; then
            echo "$$-${FUNCNAME[0]}: ${estatus} files missing"
            missed=true
            continue
        fi
    done

    if [[ ${#fcsttimes[@]} -gt 0 && ${missed} == false ]]; then
        #
        # Create job script and submit it
        #
        cd $wrkdir || return
        jobscript="run_mpassit.${mach}"

        sedfile=$(mktemp -t mpassit_${eventtime}.sed_XXXX)
        # shellcheck disable=SC2154
        cat <<EOF > $sedfile
s/PARTION/${partition_post}/
s/NOPART/$npepost/
s/JOBNAME/mpassit_${eventtime}/
s/CPUSPEC/${claim_cpu_post}/
s/CLAIMTIME/${claim_time_mpassit_alltimes}/
s/HHMINSTR//g
s/FCST_START/${minsec}/
s/FCST_END/${maxsec}/
s/FCST_INTVL/${OUTINVL}/
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
EOF

        # shellcheck disable=SC2154
        if [[ "${mach}" == "pbs" ]]; then
            echo "s/NNODES/${nnodes_post}/;s/NCORES/${ncores_post}/" >> $sedfile
        fi

        submit_a_jobscript "$wrkdir" "mpassit" "$sedfile" "$TEMPDIR/run_mpassit_array.${mach}" "$jobscript" "$jobarraystr"
    fi
}

########################################################################

function mpassit_wait_create_nml_onetime {
    # Work for one forecast time and all ensemble members
    # 1. Wait for the history/diag files
    # 2. Create namelist files

    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local -r fctseconds=$3
    local -r waitseconds=$4   # run all time together, it does not have to wait

    cd $wrkdir || return

    minstr=$(printf "%03d" $((fctseconds/60)))
    fcst_lauch_time=$(date -u -d @${iseconds} +%H%M)

    isec=$(( iseconds+fctseconds ))
    fcst_time_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

    outdone=false
    jobarrays=()
    missing=0
    for mem in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $mem)
        memdir=$wrkdir/mem$memstr
        mkwrkdir $memdir 0
        cd $memdir || return

        rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

        fcstmemdir=$(upnlevels $memdir 2)
        histfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.history.${fcst_time_str}.nc"
        diagfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.diag.${fcst_time_str}.nc"

        if [[ $dorun == true ]]; then
            for fn in $histfile $diagfile; do
                #echo "$$-${FUNCNAME[0]}: Checking ${fn##$rundir/} ..."
                if [[ $outdone == false ]]; then
                    echo "$$-${FUNCNAME[0]}: Checking forecast files at $minstr for all $ENS_SIZE memebers from fcst/${fcst_lauch_time} ..."
                    outdone=true
                fi
                while [[ ! -f $fn ]]; do
                    if [[ $jobwait -eq 0 ]]; then    # do not wait for it
                        (( missing+=1 ))
                        continue 3                   # go ahead to process next hour
                    fi

                    if [[ $verb -eq 1 ]]; then
                        echo "Waiting for $fn ..."
                    fi
                    sleep 10
                done
                fileage=$(( $(date +%s) - $(stat -c %Y -- "$fn") ))
                if [[ $fileage -lt $waitseconds ]]; then
                    if [[ $verb -eq 1 ]]; then echo "$$-${FUNCNAME[0]}: Waiting for $fn ..."; fi
                    sleep "$waitseconds"
                fi
            done
        fi

        nmlfile="namelist.fcst_$minstr"
        cat << EOF > $nmlfile
&config
    grid_file_input_grid = "$rundir/init/${domname}_${memstr}.init.nc"
    hist_file_input_grid = "$histfile"
    diag_file_input_grid = "$diagfile"
    file_target_grid     = "$rundir/${domname/*_/geo_}/geo_em.d01.nc"
    target_grid_type     = "file"
    output_file          = "$memdir/MPASSIT_${memstr}.${fcst_time_str}.nc"
    interp_diag          = .true.
    interp_hist          = .true.
    wrf_mod_vars         = .true.
    esmf_log             = .false.
/
EOF
    done

    cd $wrkdir || return

    return ${missing}
}

########################################################################

function run_upp {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # Build working directory
    #
    wrkdir=$wrkdir/upp
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    # these arrays are referred indirectly later
    # shellcheck disable=SC2034
    fixfiles_AerosolCoeff=( AerosolCoeff.bin )
    # shellcheck disable=SC2034
    fixfiles_CloudCoeff=( CloudCoeff.bin )
    # shellcheck disable=SC2034
    fixfiles_EmisCoeff=( EmisCoeff.bin )

    # shellcheck disable=SC2034
    fixfiles_SpcCoeff=( amsre_aqua.SpcCoeff.bin       imgr_g11.SpcCoeff.bin    \
        imgr_g12.SpcCoeff.bin     imgr_g13.SpcCoeff.bin  imgr_g15.SpcCoeff.bin  \
        imgr_insat3d.SpcCoeff.bin imgr_mt1r.SpcCoeff.bin imgr_mt2.SpcCoeff.bin  \
        seviri_m10.SpcCoeff.bin   ssmi_f13.SpcCoeff.bin  ssmi_f14.SpcCoeff.bin  \
        ssmi_f15.SpcCoeff.bin     ssmis_f16.SpcCoeff.bin ssmis_f17.SpcCoeff.bin \
        ssmis_f18.SpcCoeff.bin    ssmis_f19.SpcCoeff.bin ssmis_f20.SpcCoeff.bin \
        tmi_trmm.SpcCoeff.bin     v.seviri_m10.SpcCoeff.bin)

    # shellcheck disable=SC2034
    fixfiles_TauCoeff=( amsre_aqua.TauCoeff.bin       imgr_g11.TauCoeff.bin    \
        imgr_g12.TauCoeff.bin     imgr_g13.TauCoeff.bin  imgr_g15.TauCoeff.bin  \
        imgr_insat3d.TauCoeff.bin imgr_mt1r.TauCoeff.bin imgr_mt2.TauCoeff.bin  \
        seviri_m10.TauCoeff.bin   ssmi_f13.TauCoeff.bin  ssmi_f14.TauCoeff.bin  \
        ssmi_f15.TauCoeff.bin     ssmis_f16.TauCoeff.bin ssmis_f17.TauCoeff.bin \
        ssmis_f18.TauCoeff.bin    ssmis_f19.TauCoeff.bin ssmis_f20.TauCoeff.bin \
        tmi_trmm.TauCoeff.bin )

    declare -A fixdirs
    #declare -A fixfiles fixdirs
    #fixfiles[AerosolCoeff]=fixfiles_AerosolCoeff[@]
    #fixfiles[CloudCoeff]=fixfiles_CloudCoeff[@]
    #fixfiles[EmisCoeff]=fixfiles_EmisCoeff[@]
    #fixfiles[SpcCoeff]=fixfiles_SpcCoeff[@]
    #fixfiles[TauCoeff]=fixfiles_TauCoeff[@]
    fixfiles=( AerosolCoeff CloudCoeff EmisCoeff SpcCoeff TauCoeff )

    fixdirs[AerosolCoeff]="$FIXDIR/UPP/crtm2_fix/AerosolCoeff/Big_Endian"
    fixdirs[CloudCoeff]="$FIXDIR/UPP/crtm2_fix/CloudCoeff/Big_Endian"
    fixdirs[EmisCoeff]="$FIXDIR/UPP/crtm2_fix/EmisCoeff/Big_Endian"
    fixdirs[SpcCoeff]="$FIXDIR/UPP/crtm2_fix/SpcCoeff/Big_Endian"
    fixdirs[TauCoeff]="$FIXDIR/UPP/crtm2_fix/TauCoeff/ODPS/Big_Endian"

    eventtimestr=$(date -u -d @$iseconds +%Y%m%d%H%M)

    for ((i=OUTINVL;i<=fcst_seconds;i+=OUTINVL)); do
        imin=$((i/60))
        minstr=$(printf "%03d" $imin)
        ihour=$((imin/60))
        iminute=$((imin%60))
        if [[ $iminute -eq 0 ]]; then
            upptimestr=$(printf "%02d" $ihour)
        else
            upptimestr=$(printf "%02d.%02d" $ihour $iminute)
        fi

        if [[  -f $wrkdir/done.upp$minstr || -f $wrkdir/queue.upp$minstr ]]; then
            continue      # already done, or is in queue, skip this hour
        fi

        if [[  -f $wrkdir/running.upp$minstr ]]; then
            fileage=$(( $(date +%s) - $(stat -c %Y -- "$wrkdir/running.upp$minstr") ))
            if [[ $fileage -lt 300 ]]; then
                continue                        # Job is running, skip
            else                                # > 5 minutes, May be a time out issue
                rm $wrkdir/running.upp$minstr
            fi
        fi

        #if [[  -f $wrkdir/error.upp_$minstr ]]; then
            # resubmission may solve the problem
        #fi

        mpassitdir=$(upnlevels $wrkdir 1)

        donefile="$mpassitdir/mpassit/done.mpassit$minstr"

        if [[ $dorun == true ]]; then
            echo "$$-${FUNCNAME[0]}: Checking $donefile ...."
            while [[ ! -f $donefile && ! -f "$mpassitdir/mpassit/done.mpassit" ]]; do
                if [[ $jobwait -eq 0 ]]; then     # do not wait
                    continue 2                    # go ahread to process next forecast hour
                fi

                #if [[ $verb -eq 1 ]]; then
                #    echo "Waiting for $donefile ..."
                #fi
                sleep 10
            done
        fi

        isec=$(( iseconds+i ))
        fcst_time_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

        jobarrays=()
        for mem in $(seq 1 $ENS_SIZE); do
            memstr=$(printf "%02d" $mem)
            memdir=$wrkdir/mem$memstr
            mkwrkdir $memdir 0
            cd $memdir || return

            mpassitmemdir=${memdir/upp/mpassit}

            mpasfile="$mpassitmemdir/MPASSIT_${memstr}.${fcst_time_str}.nc"

            mkwrkdir $memdir/post_$minstr 1
            cd $memdir/post_$minstr || return

            #for coeff in ${!fixfiles[@]}; do
            #    echo "$coeff"
            #    for fn in ${!fixfiles[$coeff][@]}; do
            for coeff in "${fixfiles[@]}"; do
                #eval filearray=\( \${fixfiles_${coeff}[@]} \)
                fixfilename="fixfiles_${coeff}[@]"
                for fn in "${!fixfilename}"; do
                    #echo "$coeff -> ${fixdirs[$coeff]}/$fn"
                    ln -sf ${fixdirs[$coeff]}/$fn .
                done
            done

            #
            #...Link microphysic's tables - code will use based on mp_physics option
            #   found in data
            #
            ln -sf $FIXDIR/WRFV4.0/ETAMPNEW_DATA               nam_micro_lookup.dat
            ln -sf $FIXDIR/WRFV4.0/ETAMPNEW_DATA.expanded_rain hires_micro_lookup.dat

            #
            #...For GRIB2 the code uses postcntrl.xml to select variables for output
            #   the available fields are defined in post_avlbflds.xml -- while we
            #   set a link to this file for reading during runtime it is not typical
            #   for one to update this file, therefore the link goes back to the
            #   program directory - this is true for params_grib2_tbl_new also - a
            #   file which defines the GRIB2 table values
            #
            parmfiles=(params_grib2_tbl_new post_avblflds.xml postcntrl.xml postxconfig-NT.txt )
            for fn in "${parmfiles[@]}"; do
                ln -sf $FIXDIR/UPP/hrrr_$fn $fn
            done

            nmlfile="itag"
            cat << EOF > $nmlfile
$mpasfile
netcdf
grib2
${fcst_time_str//./:}
RAPR
EOF
            jobarrays+=("$mem")
        done

        #
        # Create job script and submit it
        #
        cd $wrkdir || return
        if [[ ${#jobarrays} -gt 0 ]]; then

            jobscript="run_upp$minstr.slurm"
            jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

            sedfile=$(mktemp -t upp_${eventtime}_$minstr.sed_XXXX)
            cat <<EOF > $sedfile
s/PARTION/${partition_post}/
s/NOPART/$npepost/
s/CPUSPEC/${claim_cpu_post}/
s/JOBNAME/upp${minstr}_${eventtime}/
s/HHMINSTR/$minstr/g
s/UPPDATE/$upptimestr/g
s/EVENTDATE/$eventtimestr/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
EOF
            submit_a_jobscript $wrkdir "upp$minstr" $sedfile $TEMPDIR/run_upp_array.slurm $jobscript $jobarraystr
        fi
    done
}

########################################################################

function fcst_driver() {
    #
    #  Free forecast driver from an analysis cycle
    #

    # $1     $2
    # start  end       in seconds
    local start_sec=$1
    local end_sec=$2

    #
    # Build working directory
    #
    wrkdir=$rundir/fcst
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg date_end
    date_beg=$(date -u -d @$start_sec +%Y%m%d%H%M)
    date_end=$(date -u -d @$end_sec +%Y%m%d%H%M)

    echo "Forecasting cycles from $date_beg to $date_end ...."

    # fcst_length_seconds/fcst_launch_intvl from the config file
    # shellcheck disable=SC2154
    for ilaunch in $(seq $start_sec ${fcst_launch_intvl} $end_sec ); do
        #timestr_curr=$(date -u -d @$ilaunch +%Y%m%d%H%M)
        eventtime=$(date -u -d @$ilaunch +%H%M)

        eventMM=$(date -u -d @$ilaunch +%M)
        fcstindex=1
        if [[ "${eventMM}" == "00" ]]; then fcstindex=0; fi
        fcst_seconds=${fcst_length_seconds[$fcstindex]}

        fcstwrkdir=$wrkdir/${eventtime}
        mkwrkdir $fcstwrkdir 0        # keep original directory
        cd $fcstwrkdir || return

        if [[ $dorun == true && $jobwait -eq 1 ]]; then
            num_resubmit=2               # resubmit failed jobs
        else
            num_resubmit=-1              # Just check job status
        fi

        echo ""
        echo "- FCST Cycle at ${eventtime}"

        if [[ " ${jobs[*]} " =~ " mpas " ]]; then
            #------------------------------------------------------
            # 1. Model forecast for all members
            #------------------------------------------------------
            if [[ $verb -eq 1 ]]; then echo "    Run MPAS model at $eventtime"; fi

            mpas_jobscript="run_mpas.${mach}"
            run_mpas $fcstwrkdir $ilaunch

            #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
            check_and_resubmit "fcst" $fcstwrkdir $ENS_SIZE $mpas_jobscript ${num_resubmit}
        fi

        if [[ " ${jobs[*]} " =~ " mpassit " ]]; then
            #------------------------------------------------------
            # 2. Interpolate the forecast datasets to a virtual WRF grid
            #------------------------------------------------------
            if [[ $verb -eq 1 ]]; then echo "    Run MPASSIT at $eventtime"; fi

            run_mpassit $fcstwrkdir $ilaunch

            if [[ $rt_run == true ]]; then
                for ((i=OUTINVL;i<=fcst_seconds;i+=OUTINVL)); do
                    minstr=$(printf "%03d" $((i/60)))
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "mpassit$minstr mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit_$minstr.${mach} ${num_resubmit}
                done
            else
                check_and_resubmit "mpassit mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit.${mach} ${num_resubmit}
            fi
        fi

        if [[ " ${jobs[*]} " =~ " upp " ]]; then
            #------------------------------------------------------
            # 3. Post-processing the data on the WRF grid
            #------------------------------------------------------
            if [[ $dorun == true ]]; then
                if [[ $rt_run == true ]]; then
                    for ((i=OUTINVL;i<=fcst_seconds;i+=OUTINVL)); do
                        minstr=$(printf "%03d" $((i/60)))
                        if [[ ! -e $fcstwrkdir/mpassit/done.mpassit$minstr ]]; then
                            #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                            check_and_resubmit "mpassit$minstr mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit_$minstr.slurm 0
                        fi
                    done
                else
                    check_and_resubmit "mpassit mem" $fcstwrkdir/mpassit $ENS_SIZE run_mpassit.slurm 0
                fi
            fi

            if [[ $verb -eq 1 ]]; then echo "    Run UPP at $eventtime"; fi

            run_upp $fcstwrkdir $ilaunch

            if [[ $dorun == true && $jobwait -eq 1 ]]; then
                for ((i=OUTINVL;i<=fcst_seconds;i+=OUTINVL)); do
                    minstr=$(printf "%03d" $((i/60)))
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "upp$minstr mem" $fcstwrkdir/upp $ENS_SIZE run_upp_$minstr.slurm  2
                done
            fi
        fi

    done
}

########################################################################

function run_clean {
    # $1     $2    $3
    # start  end   what
    local start_sec=$1
    local end_sec=$2
    local what=$3

    wrkdir=$rundir/fcst

    for isec in $(seq ${start_sec} ${fcst_launch_intvl} ${end_sec} ); do
        #timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date -u -d @$isec +%H%M)

        eventMM=$(date -u -d @$isec +%M)
        fcstindex=1
        if [[ "${eventMM}" == "00" ]]; then fcstindex=0; fi
        fcst_seconds=${fcst_length_seconds[$fcstindex]}

        fcstwrkdir=$wrkdir/$eventtime
        if [[ -d $fcstwrkdir ]]; then
            cd $fcstwrkdir || return

            if [[ $verb -eq 1 ]]; then echo "    Cleaning working directory $fcstwrkdir"; fi

            for dirname in mpas mpassit upp; do

                cd $fcstwrkdir || return

                case $dirname in
                mpas )
                    rm -f error.fcst_* log.????.abort
                    #rm -f log.atmosphere.????.out log.atmosphere.????.err fcst_*_*.log
                    #echo "clean mpas in $fcstwrkdir"
                    #clean_mem_runfiles "fcst" $fcstwrkdir $ENS_SIZE
                    done=0
                    for mem in $(seq 1 $ENS_SIZE); do
                        memstr=$(printf "%02d" $mem)
                        memdir="$fcstwrkdir/fcst_$memstr"

                        if [[ "$what" == "clean_fcst" ]]; then
                            rm -rf $memdir
                            rm -f fcst_${mem}_*.log
                            (( done+=1 ))
                        else
                            donefile="$memdir/done.fcst_$memstr"
                            if [[ -e $donefile ]]; then
                                rm -f fcst_${mem}_*.log
                                #rm $donefile
                                (( done+=1 ))
                            fi
                        fi
                    done
                    if [[ $done -eq $ENS_SIZE ]]; then
                        rm -f queue.fcst
                        rm -f fcst_*/done.fcst_*
                        touch done.fcst
                    fi
                    ;;
                mpassit )
                    mywrkdir=$fcstwrkdir/mpassit
                    if [[ -d $mywrkdir ]]; then
                        cd $mywrkdir || return
                        for ((i=0;i<=fcst_seconds;i+=OUTINVL)); do
                            minstr=$(printf "%03d" $((i/60)))

                            done=0
                            for mem in $(seq 1 $ENS_SIZE); do
                                memstr=$(printf "%02d" $mem)
                                memdir="$mywrkdir/mem$memstr"

                                if [[ "$what" == "clean_mpassit" ]]; then
                                    rm -rf $memdir
                                    rm -f $mywrkdir/mpassit${minstr}_${mem}_*.log
                                    (( done+=1 ))
                                else
                                    donefile="$memdir/done.mpassit${minstr}_$memstr"
                                    if [[ -e $donefile ]]; then
                                        rm -f $mywrkdir/mpassit${minstr}_${mem}_*.log
                                        #rm $donefile
                                        (( done+=1 ))
                                    fi
                                fi
                            done

                            if [[ $done -eq $ENS_SIZE ]]; then
                                rm -f queue.mpassit${minstr} running.mpassit$minstr
                                rm -f mem*/done.mpassit${minstr}_*
                                touch done.mpassit${minstr}
                            fi
                        done
                    fi
                    ;;
                upp )
                    mywrkdir=$fcstwrkdir/upp
                    if [[ -r $mywrkdir ]]; then
                        cd $mywrkdir || return
                        for ((i=0;i<=fcst_seconds;i+=OUTINVL)); do
                            minstr=$(printf "%03d" $((i/60)))

                            done=0
                            for mem in $(seq 1 $ENS_SIZE); do
                                memstr=$(printf "%02d" $mem)
                                memdir="$mywrkdir/mem$memstr"

                                postdir="$memdir/post_${minstr}"

                                if [[ "$what" == "clean_mpassit" ]]; then
                                    rm -rf $memdir
                                    rm -f $mywrkdir/upp${minstr}_${mem}_*.log
                                    (( done+=1 ))
                                else
                                    donefile="$memdir/done.upp${minstr}_$memstr"
                                    if [[ -e $donefile ]]; then
                                        rm -f $mywrkdir/upp${minstr}_${mem}_*.log
                                        rm -rf $postdir
                                        (( done+=1 ))
                                    fi
                                fi
                            done

                            if [[ $done -eq $ENS_SIZE ]]; then
                                rm -f queue.upp${minstr} running.upp$minstr
                                rm -f mem*/done.upp${minstr}_*
                                touch done.upp${minstr}
                            fi
                        done
                    fi
                    ;;
                esac
            done
        fi
    done
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
# Default Settings
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#@ MAIN

WORKDIR="${rootdir}/run_dirs"
TEMPDIR="${rootdir}/templates"
FIXDIR="${rootdir}/fix_files"

eventdate="$eventdateDF"
eventtime="1700"
initdatetime=""
enddatetime=""

domname="wofs_mpas"
mpscheme="mp_nssl2m"

verb=0
overwrite=0
jobwait=0
runcmd="sbatch"
dorun=true
rt_run=false            # realtime run?

myhostname=$(hostname)
if [[ "${myhostname}" == ln? ]]; then
    machine="Vecna"
elif [[ "${myhostname}" == hercules* ]]; then
    machine="Hercules"
elif [[ "${myhostname}" == cheyenne* || "${myhostname}" == derecho* ]]; then
    machine="Cheyenne"
else
    machine="Jet"
fi

jobs=(mpas mpassit clean)

source $scpdir/Common_Utilfuncs.sh || exit $?

#-----------------------------------------------------------------------
#
# Handle command line arguments (override default settings)
#
#-----------------------------------------------------------------------
#% ARGS

while [[ $# -gt 0 ]]
    do
    key="$1"

    case $key in
        -h)
            usage 0
            ;;
        -n)
            dorun=false
            ;;
        -v)
            verb=1
            ;;
        -r)
            rt_run=true
            ;;
        -k)
            if [[ $2 =~ [012] ]]; then
                overwrite=$2
                shift
            else
                echo "ERROR: option for '-k' can only be [0-2], but got \"$2\"."
                usage 1
            fi
            ;;
        -w)
            jobwait=1
            ;;
        -t)
            if [[ -d $2 ]]; then
                TEMPDIR=$2
            else
                echo "ERROR: Template directory \"$2\" does not exist."
                usage 1
            fi
            shift
            ;;
        -m)
            if [[ ${2^^} == "JET" ]]; then
                machine=Jet
            elif [[ ${2^^} == "VECNA" ]]; then
                machine=Vecna
            elif [[ ${2^^} == "HERCULES" ]]; then
                machine=Hercules
            elif [[ ${2^^} == "CHEYENNE" ]]; then
                machine=Cheyenne
            else
                echo "ERROR: Unsupported machine name, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -d)
            domname=$2
            shift
            ;;
        -i)
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                initdatetime=$2
            else
                echo "ERROR: Initial time should be YYYYmmddHHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -s )
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                eventtime=${2:8:4}
                eventhour=${2:8:2}
                if [[ $((10#$eventhour)) -lt 12 ]]; then
                    eventdate=$(date -u -d "${2:0:8} 1 day ago" +%Y%m%d)
                else
                    eventdate=${2:0:8}
                fi
            elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                eventtime=${2}
            else
                echo "ERROR: Start time should be in YYYYmmddHHMM or HHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -e )
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                enddatetime=$2
            elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                endhrmin=$2
                endhour=${endhrmin:0:2}
                if [[ $((10#$endhour)) -lt 12 ]]; then
                    enddatetime=$(date -u -d "$eventdate $endhrmin 1 day" +%Y%m%d%H%M)
                else
                    enddatetime=$(date -u -d "$eventdate $endhrmin" +%Y%m%d%H%M)
                fi
            else
                echo "ERROR: End time should be in YYYYmmddHHMM or HHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -p)
            if [[ ${2^^} == "NSSL" ]]; then
                mpscheme="mp_nssl2m"
            elif [[ ${2^^} == "THOMPSON" ]]; then
                mpscheme="Thompson"
            else
                echo "ERROR: Unsupported MP scheme name, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -*)
            echo "Unknown option: $key"
            usage 2
            ;;
        mpassit* | mpas* | upp* | clean* )
            #jobs=(${key//,/ })
            IFS="," read -r -a jobs <<< "$key"
            ;;
        *)
            if [[ $key =~ ^[0-9]{12}$ ]]; then
                enddatetime=${key}
                eventtime=${key:8:4}
                eventhour=${key:8:2}
                if [[ $((10#$eventhour)) -lt 12 ]]; then
                    eventdate=$(date -u -d "${key:0:8} 1 day ago" +%Y%m%d)
                else
                    eventdate=${key:0:8}
                fi
            elif [[ $key =~ ^[0-9]{8}$ ]]; then
                eventdate=${key}
            elif [[ $key =~ ^[0-9]{4}$ ]]; then
                eventtime=${key}
            elif [[ -d $key ]]; then
                WORKDIR=$key
                lastdir=$(basename $WORKDIR)
                if [[ $lastdir =~ ^[0-9]{8}$ ]]; then
                    WORKDIR=$(dirname ${WORKDIR})
                    eventdate=${lastdir}
                elif [[ $lastdir =~ ^[0-9]{12}$ ]]; then
                    WORKDIR=$(upnlevels ${WORKDIR} 3)
                    eventdate=${lastdir:0:8}
                    eventtime=${lastdir:8:4}
                    eventhour=${lastdir:8:2}
                    if [[ $eventhour -lt 12 ]]; then
                        eventdate=$(date -u -d "$eventdate 1 day ago" +%Y%m%d)
                    fi
                fi
                #echo $WORKDIR,$eventdate,$eventtime
            else
                echo ""
                echo "ERROR: unknown argument, get [$key]."
                usage 3
            fi
            ;;
    esac
    shift # past argument or value
done

#-----------------------------------------------------------------------
#
# Handle machine specific configuraitons
#
#-----------------------------------------------------------------------
#% PLATFORM

if [[ $machine == "Jet" ]]; then
    modulename="build_jet_intel18_1.11_smiol"

    source /etc/profile.d/modules.sh
    module purge
    module use ${rootdir}/modules
    module load $modulename
elif [[ $machine == "Hercules" ]]; then
    modulename="build_hercules_intel"

    module purge
    module use ${rootdir}/modules
    module load $modulename
elif [[ $machine == "Cheyenne" ]]; then
    runcmd="qsub"
    modulename="defaults"
else    # Vecna at NSSL
    modulename="env.mpas_smiol"
    source ${modulename}
fi

if [[ $dorun == false ]]; then
    runcmd="echo $runcmd"
fi

eventhour=${eventtime:0:2}
if [[ $((10#$eventhour)) -lt 12 ]]; then
    startday="1 day"
else
    startday=""
fi

if [[ "$initdatetime" == "" ]]; then
    initdatetime="${eventdate}1500"
fi

if [[ "$enddatetime" == "" ]]; then
    enddatetime=$(date -u -d "$eventdate 03:00 1 day" +%Y%m%d%H%M)
fi

#inittime_sec=$(date -u -d "${initdatetime:0:8} ${initdatetime:8:4}" +%s)
starttime_sec=$(date -u -d "${eventdate} ${eventtime} $startday"     +%s)
stoptime_sec=$(date  -u -d "${enddatetime:0:8}  ${enddatetime:8:4}"  +%s)

rundir="$WORKDIR/${eventdate}"
if [[ ! -d $rundir ]]; then
    mkdir -p $rundir
fi

exedir="$rootdir/exec"

#
# read configurations that is not set from command line
#
if [[ ! -r $WORKDIR/config.${eventdate} ]]; then
    echo "ERROR: Configuration file $WORKDIR/config.${eventdate} is not found. Please run \"setup_mpas-wofs_grid.sh\" first."
    exit 2
fi
readconf $WORKDIR/config.${eventdate} COMMON fcst || exit $?
# get ENS_SIZE, time_step, EXTINVL, OUTINVL, OUTIOTYPE

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Perform FCST cycles
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#% ENTRY

echo "---- Jobs ($$) started $(date +%m-%d_%H:%M:%S) on host $(hostname) ----"
echo "     Event date : $eventdate ${eventtime} UTC"
echo "     Root    dir: $rootdir"
echo "     Working dir: $WORKDIR"
echo "     Domain name: $domname;  MP scheme: ${mpscheme}"
echo " "

EXTINVL_STR=$(printf "%02d:00:00" $((EXTINVL/3600)) )
OUTINVL_STR=$(printf "00:%02d:00" $((OUTINVL/60)) )
RSTINVL_STR="10:00:00"         # turn off restart file output

#
# Start the forecast driver
#
if [[ " ${jobs[*]} " =~ " mpas " || " ${jobs[*]} " =~ " mpassit " || " ${jobs[*]} " =~ " upp " ]]; then
    # $1    $2    $3
    # init start  end
    fcst_driver $starttime_sec $stoptime_sec
elif [[ " ${jobs[*]} " =~ " clean " ]]; then
    run_clean $starttime_sec $stoptime_sec
elif [[ "${jobs[*]}" == @(clean_fcst|clean_mpassit|clean_upp) ]]; then
    declare -A cleanmsg=(
        [clean_fcst]="all MPAS forecast files"
        [clean_mpassit]="all MPASSIT converted files on WRF grid"
        [clean_upp]="all UPP converted grib2 files"
    )
    cleanjob="${jobs[*]}"

    echo -e "\nWARNING: Clean ${cleanmsg[$cleanjob]} from $(date -u -d @${starttime_sec} +%Y%m%d_%H:%M:%S) to $(date -u -d @${stoptime_sec} +%Y%m%d_%H:%M:%S)"
    echo -e   "         in ${WORKDIR}/${eventdate}/fcst?\n"
    echo -n "[YES,NO]? "
    read -r doit
    if [[ ${doit^^} == "YES" ]]; then
        echo -e "\nWARNING: ${cleanmsg[$cleanjob]} will be cleaned."
        run_clean $starttime_sec $stoptime_sec ${cleanjob}
    else
        echo -e "\nGot \"${doit^^}\", do nothing."
    fi
fi


echo " "
echo "==== Jobs done $(date +%m-%d_%H:%M:%S) ===="
echo " "

exit 0
