#!/bin/bash
# shellcheck disable=SC2317,SC1090,SC1091,SC2086,SC2154

scpdir="$( cd "$( dirname "$0" )" && pwd )"              # dir of script
rootdir=$(realpath "$(dirname "${scpdir}")")

mpasworkdir="/scratch/wofs_mpas"     # platform dependent, it will be reset in Site_Runtime.sh

eventdateDF=$(date -u +%Y%m%d)
eventtimeDF="1500"

#-----------------------------------------------------------------------
#
# This is the 4th step of th WOFS-MPAS workflow. It run program filter,
# update_mpas_states, and atmosphere_model to perform the DA cycles and the forward forecasting.
#
# Required files from ROOTDIR
#
# 0. module files in modules
#     build_jet_Rocky8_intel_smiol
#     env.mpas_smiol
#
# 1. exec                                   # The executables
#     atmosphere_model
#     filter
#     update_mpas_states
#     update_bc
#
# 2. templates                              # templates used in this scripts
#    README
#
#    2.1 SLURM scripts on Jet
#        run_filter.slurm                    or run_filter.pbs
#        run_mpas_array.slurm                or run_mpas_array.pbs
#        run_update_states.slurm             or run_update_states.pbs
#        run_update_sbc.slurm                or run_update_bc.pbs
#
# 3. fix_files                              # runtime fix files for MPAS model and accompany programs
#
#    3.1 tables for Thompson cloud microphysics scheme
#        *MP_THOMPSON_QIautQS_DATA.DBL
#        *MP_THOMPSON_QRacrQG_DATA.DBL
#        *MP_THOMPSON_QRacrQS_DATA.DBL
#        *MP_THOMPSON_freezeH2O_DATA.DBL
#        CCN_ACTIVATE.BIN
#
#        Can be generated by submitting job script templates/build_tables.slurm
#
#    3.2 MPASS run-time static files
#        stream_list.atmosphere.diagnostics_da
#        stream_list.atmosphere.output
#        stream_list.atmosphere.surface
#
#        *CAM_ABS_DATA.DBL
#        *CAM_AEROPT_DATA.DBL
#        *GENPARM.TBL
#        *LANDUSE.TBL
#        *OZONE_DAT.TBL
#        *OZONE_LAT.TBL
#        *OZONE_PLEV.TBL
#        *RRTMG_LW_DATA
#        *RRTMG_LW_DATA.DBL
#        *RRTMG_SW_DATA
#        *RRTMG_SW_DATA.DBL SOILPARM.TBL
#        *VEGPARM.TBL
#
#    3.3 DART filter static files
#        *sampling_error_correction_table.nc
#
#    NOTE:
#         * not in the git repository
#
# INSTRUCTIONS:
#
#  Use an existing domain (wofs_mpas)
#
#     0. It should be run after "setup_mpas-wofs.sh", "make_ics.sh" & "make_lbc.sh"
#
#     1. Copy these directories to rootdir (or clone using git)
#        modules
#        exec
#        scripts
#        templates
#        fix_files (link needed files use script lnwrkfiles.sh, see README in that directory)
#
#     2. run_dacycles.sh [YYYYmmddHH] [run_dirs] [jobnames]
#        Option "-h" gives a brief instruction about all the available options
#
# HOW THE CLEAN COMMAND WORKS:
#
#     1. By default "clean" will only delete working files, log files and
#        intermediated files for each task (both filter and mpas), but leave
#        the output file from these tasks as is.
#     2. "-c" option will delete the output files from this task, but
#        leave the runtime file and job script. So that user can run this
#        task again manually. By default it works for both tasks (filter and mpas),
#        if a task name is given, it will clean that task only.
#     3. "-a" option will clean the whole work directory for the corresponding task.
#
#-----------------------------------------------------------------------

function usage {
    echo " "
    echo "    USAGE: $0 [options] [DATETIME] [WORKDIR] [CONFIG] [JOBS]"
    echo " "
    echo "    PURPOSE: Run MPAS-WOFS DA cycles."
    echo " "
    echo "    DATETIME - Case date as YYYYmmdd, Default eventdate is ${eventdateDF}."
    echo "               YYYYmmdd:     run all cycles from $eventtimeDF to 0300 UTC. Or use options \"-s\" & \"-e\" to specify cycles."
    echo "    WORKDIR  - Run Directory"
    echo "    CONFIG   - MPAS-WoFS runtime configuration file with full path."
    echo "               WORKDIR & DATETIME will be extracted from the CONFIG name unless they are given explicitly."
    echo "    JOBS     - One or more jobs from [filter,update_states,update_bc,mpas,obs_diag,obs_final2nc,clean]"
    echo "               Default all jobs in [filter,update_states,update_bc,mpas] for a DA cyle"
    echo " "
    echo "    OPTIONS:"
    echo "              -h                  Display this message"
    echo "              -n                  Show command to be run and generate job scripts only"
    echo "              -v                  Verbose mode"
    echo "              -k  [0,1,2]         Keep working directory if exist, 0- keep as is; 1- overwrite; 2- make a backup as xxxx.bak?"
    echo "                                  Default is 0 for ungrib, mpassit, upp and 1 for others"
    echo "              -m  Machine         Machine name to run on, [Jet, Cheyenne, Vecna]."
    echo "              -a/-c/-d            Works with the Clean command only, accept one argument {filter,mpas} or nothing."
    echo "                                  Default (Nothing): Deletes output files (log/standard output, etc.) only."
    echo "                                  -a: Deep clean of the whole working directory"
    echo "                                  -c: Delete output (netCDF) files from the specific task but keep done files."
    echo "                                  -d: Delete all done files"
    echo "              -i  HHMM            Initial time, default: 1500."
    echo "              -s  HHMM            Start time of the DA cycles, or YYYYmmddHHMM."
    echo "              -e  HHMM            End time of the DA cycles, or YYYYmmddHHMM."
    echo "              -r                  Realtime run, will wait for observations, default: research mode (no waiting)."
    echo "              -f conf_file        Configuration file for this case. Default: \${WORKDIR}/config.\${eventdate}"
    echo " "
    echo "   DEFAULTS:"
    echo "              eventdate = $eventdateDF"
    echo "              rootdir   = $rootdir"
    echo "              WORKDIR   = $mpasworkdir/run_dirs"
    echo " "
    echo "                                     -- By Y. Wang (2023.05.31)"
    echo " "
    exit "$1"
}

########################################################################
#
# Handle command line arguments
#
########################################################################

function parse_args {

    declare -Ag args

    #-------------------------------------------------------------------
    # Parse command line arguments
    #-------------------------------------------------------------------

    while [[ $# -gt 0 ]]; do
        key="$1"

        case $key in
            -h)
                usage 0
                ;;
            -n)
                args["dorun"]=false
                ;;
            -v)
                args["verb"]=1
                ;;
            -r)
                args["rt_run"]=true
                ;;
            -k)
                if [[ $2 =~ [012] ]]; then
                    args["overwrite"]=$2
                    shift
                else
                    echo -e "${RED}ERROR${NC}: option for ${BLUE}-k${NC} can only be [${YELLOW}0-2${NC}], but got ${PURPLE}$2${NC}."
                    usage 1
                fi
                ;;
            -c | -a | -d )
                args["cleanoption"]="$key"
                if [[ "$2" == "filter" || "$2" == "mpas" ]]; then
                    args["cleanjobs"]+=" $2"
                    shift
                fi
                ;;
            -m)
                if [[ ${2^^} == "JET" ]]; then
                    args["machine"]=Jet
                elif [[ ${2^^} == "VECNA" ]]; then
                    args["machine"]=Vecna
                elif [[ ${2^^} == "HERCULES" ]]; then
                    args["machine"]=Hercules
                elif [[ ${2^^} == "CHEYENNE" || ${2^^} == "DERECHO" ]]; then
                    args["machine"]=Cheyenne
                else
                    echo -e "${RED}ERROR${NC}: Unsupported machine name, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -f)
                args["config_file"]="$2"
                shift
                ;;
            -i)
                if [[ $2 =~ ^[0-9]{4}$ ]]; then
                    args["inittime"]=$2
                else
                    echo -e "${RED}ERROR${NC}: Initial time should be ${GREEN}HHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -s )
                if [[ $2 =~ ^[0-9]{4}$ || $2 =~ ^[0-9]{12}$ ]]; then
                    args["eventtime"]="${2}"
                else
                    echo -e "${RED}ERROR${NC}: Start time should be in ${GREEN}HHMM${NC} or ${GREEN}YYYYmmddHHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -e )
                if [[ $2 =~ ^[0-9]{4}$ || $2 =~ ^[0-9]{12}$ ]]; then
                    args["endtime"]=$2
                else
                    echo -e "${RED}ERROR${NC}: End time should be in ${GREEN}HHMM${NC} or ${GREEN}YYYYmmddHHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -*)
                echo -e "${RED}ERROR${NC}: Unknown option: ${PURPLE}$key${NC}"
                usage 2
                ;;
            ioda* | getkf_* | mpas* | clean* )
                args["jobs"]="${key//,/ }"
                ;;
            *)
                if [[ $key =~ ^[0-9]{8}$ ]]; then
                    args["eventdate"]="${key}"
                elif [[ -d $key ]]; then
                    args["WORKDIR"]="${key}"
                elif [[ -f $key ]]; then
                    args["config_file"]="${key}"
                else
                    echo  -e "${RED}ERROR${NC}: unknown argument, get ${PURPLE}$key${NC}."
                    usage 3
                fi
                ;;
        esac
        shift # past argument or value
    done
}

########################################################################

function run_ioda {
    # $1        $2
    # wrkdir    iseconds

    local wrkdir=$1               # DA directory for this cycle
    local iseconds=$2

    if [[ ! -d $wrkdir ]]; then
        mecho0 "run_ioda: Working directory $wrkdir not exist"
        exit 1
    fi

    anlys_date=$(date -u -d @$iseconds  +%Y%m%d%H)
    anlys_hour=$(date -u -d @$iseconds  +%H)
    anlys_min=$(date -u -d @$iseconds   +%M)

    #------------------------------------------------------
    # Run ioda_bufr for all bufr observation files
    #------------------------------------------------------

    if [[ ${anlys_min} == "00" ]]; then
        run_ioda_bufr ${wrkdir} ${iseconds}
    fi

    #------------------------------------------------------
    # Run ioda_mrms_refl for reflectivity
    #------------------------------------------------------
    run_ioda_mrms_refl ${wrkdir} ${iseconds}
}

########################################################################

function run_ioda_bufr {
    # $1        $2
    # wrkdir    iseconds

    local wrkdir=$1               # DA directory for this cycle
    local iseconds=$2

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/ioda_bufr/running.ioda_bufr || -f $wrkdir/ioda_bufr/done.ioda_bufr || -f $wrkdir/ioda_bufr/queue.ioda_bufr ]]; then
        return
    fi

    #------------------------------------------------------
    # Run ioda_bufr for all bufr observation files
    #------------------------------------------------------

    mkwrkdir $wrkdir/ioda_bufr 1     # 0: Keep existing directory as is
                                     # 1: Remove existing same name directory
    cd $wrkdir/ioda_bufr || exit $?


    jobscript="run_ioda_bufr.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="1"
        [JOBNAME]="ioda_bufr_${eventtime}"
        [CPUSPEC]="${claim_cpu_ioda}"
        [EXEDIR]="${EXEDIR}/jedi"
        [CPCMD]="${cpcmd}"
        [CURRDATE]="${anlys_date}"
        [CYCHR]="${anlys_hour}"
        [OBSDIR]="${OBS_DIR}/obs_rap"
        [FIXDIR]="${FIXDIR}"
        [ROOTDIR]="${rootdir}"
        [GRIDFILE]="${rundir}/$domname/${domname}.grid.nc"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="1"
        jobParms[NCORES]="1"
    fi

    submit_a_job $wrkdir/ioda_bufr "ioda_bufr" jobParms $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function run_ioda_mrms_refl {
    # $1        $2
    # wrkdir    iseconds

    local wrkdir=$1               # DA directory for this cycle
    local iseconds=$2

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/ioda_mrms_refl/running.ioda_refl || -f $wrkdir/ioda_mrms_refl/done.ioda_refl || -f $wrkdir/ioda_mrms_refl/queue.ioda_refl ]]; then
        return
    fi

    #------------------------------------------------------
    # Run ioda_mrms_refl for MRMS observation files
    #------------------------------------------------------

    mkwrkdir $wrkdir/ioda_mrms_refl 1     # 0: Keep existing directory as is
                                     # 1: Remove existing same name directory
    cd $wrkdir/ioda_mrms_refl || exit $?

    jobscript="run_ioda_mrms_refl.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="33"
        [JOBNAME]="ioda_refl_${eventtime}"
        [CPUSPEC]="${claim_cpu_ioda_refl}"
        [EXEDIR]="${EXEDIR}/jedi"
        [CPCMD]="${cpcmd}"
        [CURRDATE]="${anlys_date}${anlys_min}"
        [OBSDIR]="${OBS_DIR}/reflectivity"
        [FIXDIR]="${FIXDIR}"
        [ROOTDIR]="${rootdir}"
        [GRIDFILE]="${rundir}/$domname/${domname}.grid.nc"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="1"
        jobParms[NCORES]="1"
    fi

    submit_a_job $wrkdir/ioda_mrms_refl "ioda_refl" jobParms $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function mpasjedi_preq {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    cd $wrkdir || return

    timesec_pre=$((iseconds-intvl_sec))
    event_pre=$(date -u -d @${timesec_pre}   +%H%M)


    #if $relative_path; then
    #    parentdir='..'  #$(realpath -m --relative-to=${wrkdir} ${parentdir_a})
    #    casedir=$(realpath -m --relative-to=${wrkdir} ${rundir})
    #else
        parentdir=$(dirname $(dirname ${wrkdir}))
        casedir="${rundir}"
    #fi

    #------------------------------------------------------
    # Prepare runtime files
    #------------------------------------------------------
    # DATA=wrkdir
    physics_convection_permitting=( CAM_ABS_DATA.DBL CAM_AEROPT_DATA.DBL CCN_ACTIVATE_DATA   \
                                    GENPARM.TBL      LANDUSE.TBL                             \
                                    MP_TEMPO_HAILAWARE_QRacrQG_DATA.DBL MP_TEMPO_QIautQS_DATA.DBL \
                                    MP_TEMPO_QRacrQG_DATA.DBL           MP_TEMPO_QRacrQS_DATA.DBL \
                                    MP_TEMPO_freezeH2O_DATA.DBL         MP_THOMPSON_QIautQS_DATA.DBL \
                                    MP_THOMPSON_QRacrQG_DATA.DBL        MP_THOMPSON_QRacrQS_DATA.DBL \
                                    MP_THOMPSON_freezeH2O_DATA.DBL      \
                                    OZONE_DAT.TBL    OZONE_LAT.TBL      OZONE_PLEV.TBL \
                                    QNWFA_QNIFA_SIGMA_MONTHLY.dat       \
                                    RRTMG_LW_DATA RRTMG_LW_DATA.DBL     \
                                    RRTMG_SW_DATA RRTMG_SW_DATA.DBL     \
                                    SOILPARM.TBL VEGPARM.TBL )

    for fn in "${physics_convection_permitting[@]}"; do
        ln -sf "${FIXDIR}/${fn}" .
    done

    #ln -snf "${FIXDIR}/${domname}.ugwp_oro_data.nc" ./ugwp_oro_data.nc

    ln -snf "${rundir}/init/${domname}.invariant.nc" ./invariant.nc

    #mkdir -p graphinfo stream_list
    #ln -snf "${FIXrrfs}"/graphinfo/* graphinfo/
    #ln -snf "${FIXrrfs}/stream_list/${PHYSICS_SUITE}"/* stream_list/
    ${cpcmd} "${FIXDIR}"/jedi/obsop_name_map.yaml .
    ${cpcmd} "${FIXDIR}"/jedi/keptvars.yaml .
    ${cpcmd} "${FIXDIR}"/jedi/geovars.yaml .

    #
    # create data directory
    #
    mkdir -p data

    cd data || exit 1

    mkdir -p obs ens jdiag

    # link ensembles to data/ens/
    for mem in $(seq -w 01 "${ENS_SIZE}"); do
        if [[ $icycle -eq 0 ]]; then
            input_file_="${casedir}/init/${domname}_${mem}.init.nc"
            mkdir -p ana
        else
            input_file_="${parentdir}/${event_pre}/fcst_${mem}/${domname}_${mem}.restart.$currtime_str.nc"
        fi

        ln -snf "${input_file_}" "ens/mem0${mem}.nc"
    done

    #
    # enter the working directory again
    #
    cd "${wrkdir}" || exit 1
    #
    # generate namelist, streams, and getkf.yaml on the fly
    file_content=$(< "${FIXDIR}/jedi/namelist.atmosphere") # read in all content
    dt=${time_step}
    start_time="${currtime_str}"
    run_duration="00:${fcstmin_str}:00"
    substeps=4
    pio_num_iotasks=4
    pio_stride=20
    MESH_NAME="${domname}"
    do_DAcycling='false'
    radt="05"
    jedi_da="true"
    eval "echo \"${file_content}\"" > namelist.atmosphere
    cp "${FIXDIR}/jedi/streams.atmosphere.getkf" streams.atmosphere

    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefilter} ]]; then
        split_graph "${gpmetis}" "${domname}.graph.info" "${npefilter}" "$rundir/$domname" "$dorun" "$verb"
    fi
    ln -sf $rundir/$domname/$domname.graph.info.part.${npefilter} .

    mkdir -p stream_list
    ln -snf "${FIXDIR}"/jedi/stream_list/* stream_list/
}

########################################################################

function run_getkf_observer {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local datimedir=$1
    local icycle=$2
    local iseconds=$3

    wrkdir="$datimedir/getkf_observer"

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.observer || -f $wrkdir/done.observer || -f $wrkdir/queue.getkf_observer ]]; then
        return
    fi

    #
    # GLOBAL: ENS_SIZE, rundir, ADAPTIVE_INF, OBS_DIR
    #         intvl_sec, ncores_filter
    # RETURN: input_file_list, output_file_list
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0              # 0: Keep existing directory as is
                                    # 1: Remove existing same name directory
    cd $wrkdir || return

    #
    # Waiting for job conditions
    #
    conditions=("${datimedir}/ioda_bufr/done.ioda_bufr" "${datimedir}/ioda_mrms_refl/done.ioda_mrms_refl")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    anlys_datehour=$(date -u -d @$iseconds  +%Y%m%d%H)
    anlys_hour=$(date -u -d @$iseconds  +%H)
    anlys_min=$(date -u -d @$iseconds   +%M)

    mpasjedi_preq "${wrkdir}" $2 $3

    #
    # Copy ioda observation files

    cd data || exit $?

    obspath="${datimedir}/ioda_bufr"

    declare -A mappings  # Declare an associative array

    mappings=(  ["ioda_adpsfc.nc"]="${obspath}/ioda_adpsfc.nc"          \
                ["ioda_adpupa.nc"]="${obspath}/ioda_adpupa.nc"          \
                ["ioda_aircar.nc"]="${obspath}/ioda_aircar.nc"          \
                ["ioda_aircft.nc"]="${obspath}/ioda_aircft.nc"          \
                ["ioda_ascatw.nc"]="${obspath}/ioda_ascatw.nc"          \
                ["ioda_msonet.nc"]="${obspath}/ioda_msonet.nc"          \
                ["ioda_proflr.nc"]="${obspath}/ioda_proflr.nc"          \
                ["ioda_rassda.nc"]="${obspath}/ioda_rassda.nc"          \
                ["ioda_sfcshp.nc"]="${obspath}/ioda_sfcshp.nc"          \
                ["ioda_vadwnd.nc"]="${obspath}/ioda_vadwnd.nc"          \
                ["ioda_gnss_ztd.nc"]="${obspath}/ioda_gnss_ztd.nc"      \
    # satellite observations
                ["ioda_abi_g16.nc"]="${obspath}/ioda_abi_g16.nc"        \
                ["ioda_abi_g18.nc"]="${obspath}/ioda_abi_g18.nc"        \
                ["ioda_atms_npp.nc"]="${obspath}/ioda_atms_npp.nc"      \
                ["ioda_atms_n20.nc"]="${obspath}/ioda_atms_n20.nc"      \
                ["ioda_atms_n21.nc"]="${obspath}/ioda_atms_n21.nc"      \
                ["ioda_crisf4_n20.nc"]="${obspath}/ioda_crisf4_n20.nc"  \
                ["ioda_crisf4_n21.nc"]="${obspath}/ioda_crisf4_n21.nc"  \
    # Radar observations
                ["ioda_mrms_refl.nc"]="${datimedir}/ioda_mrms_refl/ioda_mrms_${anlys_datehour}_${anlys_min}.nc4"
            )

    # loop through and copy files
    for dst_file in "${!mappings[@]}"; do
        src_file=${mappings[${dst_file}]}
        if [[ -s "${src_file}" ]]; then
            ${cpcmd} "${src_file}"  "obs/${dst_file}"
        else
            mecho0 "WARNING: ${src_file} does not exist!"
        fi
    done

    #
    # enter the run directory again
    #
    cd "${wrkdir}" || exit 1

    #
    # generate getkf.yaml based on how YAML_GEN_METHOD is set
    analysisDate="$(date -u -d @${iseconds} +%Y-%m-%dT%H:%M:%SZ)"
    bseconds=$((iseconds - 600))
    beginDate="$(date -u -d @${bseconds} +%Y-%m-%dT%H:%M:%SZ)"
    lenwind="PT15M"

    USHrrfs="${rootdir}/RRFS_USH"
    # generate the JEDI yaml files using templates from the parm/ directory
    #source "${USHrrfs}"/yaml_from_parm.sh "getkf"

    sed -e "s/@analysisDate@/${analysisDate}/;s/@beginDate@/${beginDate}/;s/@lenWin@/${lenwind}/" \
           "${FIXDIR}/jedi/getkf_observer.yaml" > getkf.yaml
    #
    #  Generate the final YAML configuration file based on convinfo and available ioda files
    #
    cp "${FIXDIR}/jedi/convinfo" .
    [[ -s "${FIXDIR}/jedi/satinfo" ]] && cp "${FIXDIR}/jedi/satinfo" .
    "${USHrrfs}/yaml_finalize" "getkf.yaml"

    ## For post task, change a few yaml settings and remove "reduce obs space"
    #if [[ "${TYPE}" == "post" ]]; then
    #  "${USHrrfs}"/yaml_getkf_post getkf.yaml
    #fi

    #------------------------------------------------------
    # Run mpasjedi_enkf.x
    #------------------------------------------------------

    taskname="observer"
    jobscript="run_mpasjedi.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="${npefilter}"
        [JOBNAME]="${taskname}-${jobname}_${eventtime}"
        [CPUSPEC]="${claim_cpu_filter}"
        [EXEDIR]="${EXEDIR}/jedi"
        [WRKDIR]="${wrkdir}"
        [TASKNAME]="${taskname}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_filter}"
        jobParms[NCORES]="${ncores_filter}"
    fi

    submit_a_job "${wrkdir}" "getkf_${taskname}" "jobParms" "$TEMPDIR/$jobscript" "run_getkf_${taskname}.${mach}" ""
}

########################################################################

function run_getkf_solver {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local datimedir=$1
    local icycle=$2
    local iseconds=$3

    wrkdir="$datimedir/getkf_solver"

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.solver || -f $wrkdir/done.solver || -f $wrkdir/queue.getkf_solver ]]; then
        return
    fi

    #
    # GLOBAL: ENS_SIZE, rundir, ADAPTIVE_INF, OBS_DIR
    #         intvl_sec, ncores_filter
    # RETURN: input_file_list, output_file_list
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0               # 0: Keep existing directory as is
                                     # 1: Remove existing same name directory
    cd $wrkdir || return

    #
    # Waiting for job conditions
    #
    conditions=("${datimedir}/getkf_observer/done.observer")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # Prepare runtime files
    #------------------------------------------------------
    # DATA=wrkdir

    mpasjedi_preq $1 $2 $3

    #
    # Copy ioda observation files

    ln -snf "${datimedir}/getkf_observer"/jdiag* jdiag/

    #
    # enter the run directory again
    #
    cd "${wrkdir}" || exit 1

    #
    # generate getkf.yaml based on how YAML_GEN_METHOD is set
    analysisDate="$(date -u -d @${iseconds} +%Y-%m-%dT%H:%M:%sZ)"
    bseconds=$((iseonds - 600))
    beginDate="$(date -u -d @${bseconds} +%Y-%m-%dT%H:%M:%sZ)"
    lenwind="PT15M"

    USHrrfs="${rootdir}/RRFS_USH"
    # generate the JEDI yaml files using templates from the parm/ directory
    #source "${USHrrfs}"/yaml_from_parm.sh "getkf"

    sed -e "s/@analysisDate@/${analysisDate}/;s/@beginDate@/${beginDate}/;s/@lenWin@/${lenwind}/" \
           "${FIXDIR}/jedi/getkf_solver.yaml" > getkf.yaml
    #
    #  Generate the final YAML configuration file based on convinfo and available ioda files
    #
    cp "${FIXDIR}/jedi/convinfo" .
    [[ -s "${FIXDIR}/jedi/satinfo" ]] && cp "${FIXDIR}/jedi/satinfo" .
    "${USHrrfs}/yaml_finalize" "getkf.yaml"

    #------------------------------------------------------
    # Run mpasjedi_enkf.x
    #------------------------------------------------------

    taskname="solver"
    jobscript="run_mpasjedi_solver.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="$npefilter"
        [JOBNAME]="${taskname}-${jobname}_${eventtime}"
        [CPUSPEC]="${claim_cpu_filter}"
        [EXEDIR]="${EXEDIR}/jedi"
        [WRKDIR]="${wrkdir}"
        [TASKNAME]="${taskname}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_filter}"
        jobParms[NCORES]="${ncores_filter}"
    fi

    submit_a_job "${wrkdir}" "getkf_${taskname}" "jobParms" "$TEMPDIR/run_mpasjedi.${mach}" "$jobscript" ""
}

########################################################################

function run_getkf_post {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, ADAPTIVE_INF, OBS_DIR
    #         intvl_sec, ncores_filter
    # RETURN: input_file_list, output_file_list
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0               # 0: Keep existing directory as is
                                     # 1: Remove existing same name directory
    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.post || -f $wrkdir/done.post || -f $wrkdir/queue.post ]]; then
        return
    fi

    #if $relative_path; then
    #    parentdir='..'  #$(realpath -m --relative-to=${wrkdir} ${parentdir_a})
    #    casedir=$(realpath -m --relative-to=${wrkdir} ${rundir})
    #else
        parentdir=$(dirname ${wrkdir})
        casedir="${rundir}"
    #fi

    #------------------------------------------------------
    # Prepare runtime files
    #------------------------------------------------------
    # DATA=wrkdir

    # generate getkf.yaml based on how YAML_GEN_METHOD is set
    analysisDate="$(date -u -d @${iseconds} +%Y-%m-%dT%H:%M:%sZ)"
    bseconds=$((iseonds - 600))
    beginDate="$(date -u -d @${bseconds} +%Y-%m-%dT%H:%M:%sZ)"
    lenwind="PT15M"

    USHrrfs="${rootdir}/RRFS_ush"
    # generate the JEDI yaml files using templates from the parm/ directory
    #source "${USHrrfs}"/yaml_from_parm.sh "getkf"

    sed -e "s/@analysisDate@/${analysisDate}/;s/@beginDate@/${beginDate}/;s/@lenWin@/${lenwind}/" \
           "${FIXDIR}/jedi/getkf_solver.yaml" > getkf.yaml
    #
    #  Generate the final YAML configuration file based on convinfo and available ioda files
    #
    "${cpcmd}" "${EXPDIR}/config/convinfo" .
    [[ -s "${EXPDIR}/config/satinfo" ]] && cp "${EXPDIR}/config/satinfo" .
    "${USHrrfs}/yaml_finalize" "getkf.yaml"

    ## For post task, change a few yaml settings and remove "reduce obs space"
    "${USHrrfs}"/yaml_getkf_post getkf.yaml

    #------------------------------------------------------
    # 5. Run mpasjedi_enkf.x
    #------------------------------------------------------

    jobscript="run_mpasjedi_post.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="$npefilter"
        [JOBNAME]="jedi-${jobname}_${eventtime}"
        [CPUSPEC]="${claim_cpu_filter}"
        [EXEDIR]="${EXEDIR}/jedi"
        [TASKNAME]="post"
    )

    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_filter}"
        jobParms[NCORES]="${ncores_filter}"
    fi

    submit_a_job "${wrkdir}" "mpasjedi" "jobParms" "$TEMPDIR/run_mpasjedi.${mach}" "$jobscript" ""
}

########################################################################

function run_add_noise {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, update_in_place
    #         input_file_list
    #

    #
    # Build working directory
    #
    cd $wrkdir || return

    timestr_cur=$(date  -u -d @$iseconds    +%Y%m%d%H%M)
    read -r -a days_secs < <(convertS2days "${iseconds}")

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/done.add_noise ]]; then
        #mecho0 "add_noise is already done"
        return
    fi

    if [[ -f $wrkdir/running.noise_pert || -f $wrkdir/queue.noise_pert ]]; then
        #mecho0 "add_noise is running/queued."
        return
    fi

    seqfile="obs_seq.final.${timestr_cur}.nc"

    #------------------------------------------------------
    # Run grid_refl_obs.py for noise mask files
    #------------------------------------------------------

    if [[ ${no_observation} == true ]]; then
        mecho0 "${YELLOW}WARNING${NC}: no observation, skipping ...."
        touch done.add_noise done.noise_mask
        return
    fi

    #
    # Waiting for done.update_states
    #
    conditions=("${wrkdir}/done.update_states" "${seqfile}")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking ${CYAN}$cond${NC} ...."
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: ${CYAN}$cond${NC}"
                fi
                sleep 10
            done
        done
    fi

    if [[ ! -e done.noise_mask && ! -e running.noise_mask && ! -e queue.noise_mask && ! -e missed.noise_mask ]]; then
        if [[ $verb -eq 1 ]]; then mecho0 "Running ${WHITE}grid_refl_obs.py${NC} at ${YELLOW}${timestr_cur}${NC}"; fi

        invfile="$rundir/init/${domname}.invariant.nc"
        #
        # Create job script and submit it
        #
        runexe_str="${job_runexe_str} -n 1"

        jobscript="run_noise_mask.${mach}"

        declare -A jobParms=(
            [PARTION]="${partition_filter}"
            [NOPART]="1"
            [JOBNAME]="noise_mask_${eventtime}"
            [CPUSPEC]="${claim_cpu_update}"
            [MACHINE]="${machine}"
            [SEQFILE]="${seqfile}"
            [INVFILE]="${invfile}"
            [WAN_PATH]="${WOFSAN_PATH}"
            [EVENTDAYS]="${days_secs[0]}"
            [EVENTSECS]="${days_secs[1]}"
            [RUNCMD]="${runexe_str}"
        )
        if [[ "${mach}" == "pbs" ]]; then
            jobParms[NNODES]="1"
            jobParms[NCORES]="1"
        fi

        submit_a_job $wrkdir "noise_mask" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" ""
    fi

    #------------------------------------------------------
    # Run add_pert_where_high_refl.py for all members
    #------------------------------------------------------

    #
    # Waiting for done.noise_mask
    #
    conditions=("${wrkdir}/done.noise_mask")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking ${CYAN}$cond${NC} ...."
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: ${CYAN}$cond${NC}"
                fi
                if [[ -e "${wrkdir}/missed.noise_mask" ]]; then
                    mecho0 "${YELLOW}WARNING${NC}: No radar reflectivity obs for this cycle. Skip ${WHITE}add_noise${NC}."
                    touch "${wrkdir}/done.add_noise"
                    return
                fi
                sleep 10
            done
        done
    fi

    if [[ $verb -eq 1 ]]; then mecho0 "Running ${WHITE}add_pert_where_high_refl.py${NC} at ${YELLOW}${timestr_cur}${NC}"; fi

    invfile="$rundir/init/${domname}.invariant.nc"

    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        if [[ ! -e done.add_noise_${memstr} && ! -e running.add_noise_${memstr} ]]; then
            days_str=$(printf "%5.5i_%6.6i" ${days_secs[0]} ${days_secs[1]})
            ln -sf ../refl_obs_${days_str}.pkl ../wofs_mpas_grid_kdtree.pkl ../mpas_XYZ.pkl .
            jobarrays+=("$iens")
        fi
    done

    cd "${wrkdir}" || return

    #
    # Create job script and submit it
    #
    if [[ ${#jobarrays[@]} -gt 0 ]]; then
        jobscript="run_noise_pert.${mach}"

        runexe_str="${job_runexe_str} -n 1"

        declare -A jobParms=(
            [PARTION]="${partition_filter}"
            [NOPART]="1"
            [JOBNAME]="noist_pert_${eventtime}"
            [CPUSPEC]="${claim_cpu_update}"
            [INVFILE]="${invfile}"
            [MACHINE]="${machine}"
            [SEQFILE]="${seqfile}"
            [WAN_PATH]="${WOFSAN_PATH}"
            [EVENTDAYS]="${days_secs[0]}"
            [EVENTSECS]="${days_secs[1]}"
            [RUNCMD]="${runexe_str}"
        )
        if [[ "${mach}" == "pbs" ]]; then
            jobParms[NNODES]="1"
            jobParms[NCORES]="1"
        fi

        jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")
        submit_a_job $wrkdir "add_noise" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" "${jobarraystr}"
    fi
}

########################################################################

function run_mpas {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, intvl_sec, npefcst
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir || exit $?

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.fcst || -f $wrkdir/done.fcst || -f $wrkdir/queue.fcst ]]; then
        return
    fi

    #
    # Waiting for job conditions
    #
    conditions=("${wrkdir}/done.update_bc")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #
    # Preparation for all members
    #
    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefcst} ]]; then
        split_graph "${gpmetis}" "${domname}.graph.info" "${npefcst}" "$rundir/$domname" "$dorun" "$verb"
    fi

    currtime_fil=${currtime_str//:/.}
    #fcst_sec=$(( iseconds + intvl_sec ))
    #fcsttime_fil=$(date -u -d @${fcst_sec} +%Y-%m-%d_%H.%M.%S)

    #
    # Default runtime parameters for MPAS model
    #
    [[ ! -v coef_3rd_order ]]      && coef_3rd_order=1.0
    [[ ! -v smagorinsky_coe ]]     && smagorinsky_coef=0.25
    [[ ! -v visc4_2dsmag ]]        && visc4_2dsmag=0.125
    [[ ! -v h_mom_eddy_visc4 ]]    && h_mom_eddy_visc4=0.0
    [[ ! -v h_theta_eddy_visc4 ]]  && h_theta_eddy_visc4=0.25
    [[ ! -v h_scalar_eddy_visc4 ]] && h_scalar_eddy_visc4=0.25
    [[ ! -v smdiv ]]               && smdiv=0.1
    [[ ! -v physics_suite ]]       && physics_suite='convection_permitting'

    #
    # Preparation for each member
    #
    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        basen=$(( (iens-1)%6 ))
        if [[ $basen -lt 2 ]]; then     # map to 0,1,2
            idx=0
        elif [[ $basen -lt 4 ]]; then
            idx=1
        else
            idx=2
        fi
        pblscheme=${pbl_schemes[$idx]}
        sfcscheme=${sfclayer_schemes[$idx]}

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        #
        # init files
        #
        if [[ $icycle -eq 0 || ${damode} == "init" ]]; then
            do_restart="false"
            do_dacyle="false"
            mpas_inputfile_template="${domname}_${memstr}.init.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
            initfile="./${domname}_${memstr}.init.${currtime_fil}.nc"
        else
            do_restart="true"
            do_dacyle="true"
            mpas_inputfile_template="${domname}_${memstr}.init.nc"
            initfile="./${domname}_${memstr}.restart.${currtime_fil}.nc"
        fi

        if [[ $verb -eq 1 ]]; then
            realinit=$(realpath -m --relative-to=. ${initfile})
            mecho0 "Member $iens init file: ${realinit}";
        fi

        if [[ ! -e ${initfile} && ${dorun} == true ]]; then
            mecho0 "${RED}ERROR${NC}: ${damode} file: ${CYAN}${initfile}${NC} not exists"
            exit 1              # something wrong should never happen
        fi

        if $relative_path; then
            casedir=$(realpath -m --relative-to=. ${rundir})
        else
            casedir="${rundir}"
        fi

        ln -sf ${casedir}/$domname/$domname.graph.info.part.${npefcst} .
        ln -sf ${casedir}/init/${domname}.invariant.nc .

        diag_stream="stream_list.atmosphere.diagnostics_da"
        if [[ ${outwrf} == true ]]; then
            diag_stream="stream_list.atmosphere.diagnostics_fcst"
        fi

        streamlists=("${diag_stream}" stream_list.atmosphere.output stream_list.atmosphere.surface)
        for fn in "${streamlists[@]}"; do
            cp -f ${FIXDIR}/$fn .
        done

        datafiles=(  CAM_ABS_DATA.DBL  CAM_AEROPT_DATA.DBL GENPARM.TBL       LANDUSE.TBL    \
                     OZONE_DAT.TBL     OZONE_LAT.TBL       OZONE_PLEV.TBL    RRTMG_LW_DATA  \
                     RRTMG_LW_DATA.DBL RRTMG_SW_DATA       RRTMG_SW_DATA.DBL SOILPARM.TBL   \
                     VEGPARM.TBL )

        for fn in "${datafiles[@]}"; do
            ln -sf ${FIXDIR}/$fn .
        done

        if [[ "${mpscheme}" == "mp_tempo" ]]; then
            thompson_tables=( MP_TEMPO_HAILAWARE_QRacrQG_DATA.DBL MP_TEMPO_QRacrQS_DATA.DBL   \
                              MP_TEMPO_freezeH2O_DATA.DBL         MP_TEMPO_QIautQS_DATA.DBL   CCN_ACTIVATE_DATA )

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        elif [[ "${mpscheme}" == "mp_thompson" ]]; then
            thompson_tables=( MP_THOMPSON_QRacrQG_DATA.DBL   MP_THOMPSON_QRacrQS_DATA.DBL   \
                              MP_THOMPSON_freezeH2O_DATA.DBL MP_THOMPSON_QIautQS_DATA.DBL CCN_ACTIVATE.BIN )

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        fi

        # the ratio of radt to dt is 15
        cat << EOF > namelist.atmosphere
&nhyd_model
    config_time_integration_order   = 2
    config_dt                       = ${time_step}
    config_start_time               = '${currtime_str}'
    config_run_duration             = '00:${fcstmin_str}:00'
    config_split_dynamics_transport = true
    config_number_of_sub_steps      = 4
    config_dynamics_split_steps     = 3
    config_h_mom_eddy_visc2         = 0.0
    config_h_mom_eddy_visc4         = ${h_mom_eddy_visc4}
    config_v_mom_eddy_visc2         = 0.0
    config_h_theta_eddy_visc2       = 0.0
    config_h_theta_eddy_visc4       = ${h_theta_eddy_visc4}
    config_v_theta_eddy_visc2       = 0.0
    config_h_scalar_eddy_visc4      = ${h_scalar_eddy_visc4}
    config_horiz_mixing             = '2d_smagorinsky'
    config_len_disp                 = 3000.0
    config_visc4_2dsmag             = ${visc4_2dsmag}
    config_w_adv_order              = 3
    config_theta_adv_order          = 3
    config_scalar_adv_order         = 3
    config_u_vadv_order             = 3
    config_w_vadv_order             = 3
    config_theta_vadv_order         = 3
    config_scalar_vadv_order        = 3
    config_scalar_advection         = true
    config_monotonic                = true
    config_coef_3rd_order           = ${coef_3rd_order}
    config_epssm                    = 0.1
    config_smdiv                    = ${smdiv}
    config_smagorinsky_coef         = ${smagorinsky_coef}
/
&damping
    config_mpas_cam_coef             = 2.0
    config_rayleigh_damp_u           = true
    config_zd                        = 16000.0
    config_xnutr                     = 0.2
    config_number_cam_damping_levels = 8
/
&limited_area
    config_apply_lbcs                = true
/
&io
    config_pio_num_iotasks           = NNNODE
    config_pio_stride                = NNCORE
/
&decomposition
    config_block_decomp_file_prefix  = '${domname}.graph.info.part.'
/
&restart
    config_do_restart                = ${do_restart}
    config_do_DAcycling              = ${do_dacyle}
/
&printout
    config_print_global_minmax_sca   = true
    config_print_global_minmax_vel   = true
    config_print_detailed_minmax_vel = false
/
&IAU
    config_IAU_option                = 'off'
    config_IAU_window_length_s       = 21600.
/
&physics
    config_sst_update                = false
    config_sstdiurn_update           = false
    config_deepsoiltemp_update       = false
    config_radtlw_interval           = '00:05:00'
    config_radtsw_interval           = '00:05:00'
    config_bucket_update             = 'none'
    config_lsm_scheme                = '${MPASLSM}'
    num_soil_layers                  = ${MPASNFLS}
    config_microp_re                 = true
    config_physics_suite             = '${physics_suite}'
    config_convection_scheme         = 'off'
    config_sfclayer_scheme           = '${sfcscheme}'

    config_frac_seaice         = true
    config_gwdo_scheme         = 'bl_ugwp_gwdo'
    config_gvf_update          = false
EOF
        if [[ ${sfcscheme} == "sf_mynn" ]]; then
            cat << EOF >> namelist.atmosphere
    config_pbl_scheme          = 'bl_mynnedmf'
EOF
        else
            cat << EOF >> namelist.atmosphere
    config_pbl_scheme          = '${pblscheme}'
EOF
        fi

        if [[ ${mpscheme} == "mp_nssl2m" ]]; then
            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
/
&nssl_mp_params
    ehw0                             = 0.9
    ehlw0                            = 0.9
    icefallfac                       = 1.5
    snowfallfac                      = 1.25
    iusewetsnow                      = 0
/
EOF
        elif [[ ${mpscheme} == "mp_tempo" ]]; then
            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
    config_tempo_hailaware           = .true.
    config_tempo_aerosolaware        = .true.
/
EOF
        else
            echo "/" >> namelist.atmosphere
        fi

        cat << EOF >> namelist.atmosphere
&soundings
    config_sounding_interval         = 'none'
/
&assimilation
    config_jedi_da                   = false
/
&development
    config_halo_exch_method          = 'mpas_halo'
/
EOF

        icycle_extinvl_str=$(date -d@${icycle_lbcgap} -u +%H:%M:%S)
        #echo "icycle_extinvl_str=${icycle_extinvl_str}"

        cat << EOF > streams.atmosphere
<streams>
<immutable_stream name="input"
                  type="input"
                  filename_template="${mpas_inputfile_template}"
                  input_interval="initial_only" />

<immutable_stream name="invariant"
                  type="input"
                  filename_template="${domname}.invariant.nc"
                  input_interval="initial_only" />

<immutable_stream name="restart"
                  type="input;output"
                  filename_template="${domname}_${memstr}.restart.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  input_interval="initial_only"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" />

<stream name="output"
                  type="output"
                  filename_template="${domname}_${memstr}.history.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

                <file name="stream_list.atmosphere.output"/>
</stream>

<stream name="diagnostics"
                  type="output"
                  filename_template="${domname}_${memstr}.diag.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" >

                <file name="${diag_stream}"/>
</stream>

<stream name="surface"
                  type="input"
                  filename_template="${domname}_${memstr}.sfc_update.nc"
                  filename_interval="none"
                  input_interval="none" >

                <file name="stream_list.atmosphere.surface"/>
</stream>

<immutable_stream name="iau"
                  type="input"
                  filename_template="${domname}_${memstr}.AmB.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="none"
                  packages="iau"
                  input_interval="initial_only" />

<immutable_stream name="lbc_in"
                  type="input"
                  filename_template="${domname}_${memstr}.lbc.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="input_interval"
                  packages="limited_area"
                  input_interval="${icycle_extinvl_str}" />

</streams>
EOF
        jobarrays+=("$iens")
    done

    cd $wrkdir || return

    #
    # Create job script for MPAS forecast and submit it
    #
    declare -A jobParms=(
        [PARTION]="${partition_fcst}"
        [NOPART]="$npefcst"
        [NNODES]="${nnodes_fcst}"
        [JOBNAME]="mfrd-${jobname}_${eventtime}"
        [CPUSPEC]="${claim_cpu_fcst}"
        [CLAIMTIME]="${claim_time_fcst}"
    )
    #mpas_jobscript="run_mpas.${mach}"
    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_fcst}"
        jobParms[NCORES]="${ncores_fcst}"
    fi

    submit_a_job "$wrkdir" "fcst" "jobParms" "$TEMPDIR/run_mpas_array.${mach}" "$mpas_jobscript" "${jobarraystr}"
}

########################################################################

function dacycle_driver() {
    #
    #  based on driver_mpas_dart.csh in the DART package
    #
    #  THIS IS A TOP-LEVEL DRIVER SCRIPT FOR CYCLING RUNS.
    #
    #  Required files to run this driver:
    #  1. executables:
    #       filter
    #       update_mpas_states
    #       update_bc
    #       atmosphere_model
    #
    #  Input files to run this script:
    #  A. input_state_file_list  - a list of input ensemble netcdf files for DART/filter
    #  B. output_state_file_list - a list of output ensemble netcdf files from DART/filter
    #  C. RUN_DIR/fcst_??/${mpas_filename}    - the input file listed in input_state_file_list for each member
    #  D. OBS_DIR/${obs_seq_in}.${YYYYMMDDHH} - obs sequence files for each analysis cycle (YYYYMMDDHH)
    #
    ##############################################################################################
    # USER SPECIFIED PARAMETERS
    ##############################################################################################
    # $1    $2    $3
    # init start  end
    local init_sec=$1
    local start_sec=$2
    local end_sec=$3

    #
    # Build working directory
    #
    wrkdir="$rundir/dacycles${daffix}"
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg date_end intvl_min n_cycles
    date_beg=$(date -u -d @$start_sec +%Y%m%d%H%M)
    date_end=$(date -u -d @$end_sec +%Y%m%d%H%M)
    intvl_min=$((intvl_sec/60))
    n_cycles=$(( (end_sec-start_sec)/intvl_sec+1 ))

    echo -e "Total ${n_cycles} cycles from ${GREEN}$date_beg${NC} to ${LIGHT_BLUE}$date_end${NC} will be run every $intvl_min minutes."

    if [[ $dorun == true ]]; then
        num_resubmit=2               # resubmit failed jobs
    else
        num_resubmit=0               # Just check job status
    fi

    local icyc=$(( (start_sec-init_sec)/intvl_sec ))
    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date -u -d @$isec +%H%M)

        dawrkdir=${wrkdir}/${eventtime}
        mkwrkdir $dawrkdir 0    # keep original directory
        cd $dawrkdir || return

        echo ""
        echo -e "- Cycle $icyc at ${WHITE}${timestr_curr}${NC} - ${CYAN}$(date +'%Y-%m-%d %H:%M:%S (%Z)')${NC}"
        time1=$(date +%s)

        no_observation=false

        #------------------------------------------------------
        # Lateral boundary times for this cycle
        #------------------------------------------------------

        isec_nlbc1=$(( isec - isec%3600 ))            # get whole hour in seconds
        isec_nlbc2=$(( isec_nlbc1 + EXTINVL ))        # next whole hour
        isec_elbc=$(( isec + intvl_sec ))
        while [[ $isec_elbc -gt $isec_nlbc2 ]]; do
            (( isec_nlbc2+=EXTINVL ))
        done
        isec_elbc=${isec_nlbc2}                      # use variant lbc interval or not
        icycle_lbcgap=$((isec_elbc-isec))

        #------------------------------------------------------
        # 0. Check forecast status of the early cycle or inital boundary status
        #------------------------------------------------------
        if [[ $dorun == true ]]; then
            if [[ $icyc -eq 0 ]]; then
                if [[ ! -e $rundir/lbc/done.lbc ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "${domname}" $rundir/lbc $nenslbc run_lbc.${mach}
                fi
            else   #if [[ $icyc -gt 0 ]]; then
                timesec_pre=$((isec-intvl_sec))
                event_pre=$(date -u -d @$timesec_pre  +%H%M)
                wrkdir_pre=${wrkdir}/${event_pre}
                if [[ ! -e ${wrkdir_pre}/done.fcst ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "fcst" $wrkdir_pre $ENS_SIZE run_mpas.${mach}
                fi
            fi
        fi

        intvl_min=$((intvl_sec/60))

        currtime_str=$(date -u -d @${isec} +%Y-%m-%d_%H:%M:%S)
        fcstmin_str=$(printf "%02d" "${intvl_min}")

        #------------------------------------------------------
        # 1. Run ioda
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " ioda " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run ioda_bufr at $eventtime"; fi
            run_ioda $dawrkdir $isec
        fi

        #------------------------------------------------------
        # 2. Run observer
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " getkf_observer " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run getkf_observer at $eventtime"; fi
            run_getkf_observer $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 3. Run solver
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " getkf_solver " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run getkf_observer at $eventtime"; fi
            run_getkf_solver $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 4. Run post (if requested)
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " getkf_post " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run getkf_post at $eventtime"; fi
            run_getkf_post $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 5. Add noise (must run after update_states)
        #------------------------------------------------------

        if [[ $run_addnoise == true && $icyc -gt 0 ]]; then
            # check and set update_states status
            if [[ ! -e done.update_states ]]; then
                #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                check_job_status "update_states fcst_" $dawrkdir $ENS_SIZE run_update_states.${mach} ${num_resubmit}
            fi

            if [[ $verb -eq 1 ]]; then echo "  Run add_noise at $eventtime"; fi
            run_add_noise $dawrkdir $isec
        fi

        #------------------------------------------------------
        # 6. Advance model for each member
        #------------------------------------------------------
        # Run forecast for ensemble members until the next analysis time
        if [[ " ${jobs[*]} " =~ " mpas " ]]; then
            # check and set update_bc status
            if [[ ! -e done.update_bc ]]; then
                #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                check_job_status "update_bc fcst_" $dawrkdir $ENS_SIZE run_update_bc.${mach} ${num_resubmit}
            fi

            if [[ $verb -eq 1 ]]; then echo "  Run advance model at $eventtime"; fi

            mpas_jobscript="run_mpas.${mach}"
            run_mpas $dawrkdir $icyc $isec

            if [[ ! -e done.fcst ]]; then
                #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                check_job_status "fcst" $dawrkdir $ENS_SIZE $mpas_jobscript ${num_resubmit}
            fi
        fi
        #------------------------------------------------------
        # 7. MPASSIT for each member, diagnostic purpose
        #------------------------------------------------------
        # Interpolate the forecast datasets to a virtual WRF grid

        if [[ " ${jobs[*]} " =~ " mpassit " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run MPASSIT at $eventtime"; fi

            run_mpassit $dawrkdir ${isec}

            check_job_status "mpassit mem" $dawrkdir/mpassit $ENS_SIZE run_mpassit.${mach} ${num_resubmit}
        else
            # Clean not needed files in each member's forecast directory after
            # the MPAS forward forecast
            if [[ $outwrf == false && $icyc -gt 0 ]]; then
                rm -rf ${dawrkdir}/fcst_??/${domname}_??.{diag,history}.*
            fi
        fi

        #------------------------------------------------------
        # This DA cycle is done
        #------------------------------------------------------
        time2=$(date +%s)
        if [[ $time2 -gt $time1 ]]; then
            (( secoffset = time2-time1 )); (( minoffset = secoffset/60 )); (( secoffset = secoffset%60 ))
            echo -e "= Cycle ${eventtime} took ${CYAN}${minoffset}:${secoffset}${NC} minutes:seconds."
        fi

        (( icyc+=1 ))
    done
}

########################################################################

function run_mpassit {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # Build working directory
    #
    wrkdir=$wrkdir/mpassit
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    #
    # Check MPASSIT status
    #
    if [[ -f done.mpassit ]]; then
        mecho0 "MPASSIT done for all forecast minutes"
        return
    fi

    if [[ -f running.mpassit || -f queue.mpassit ]]; then
        mecho0 "MPASSIT is running/queued for all forecast minutes"
        return
    fi

    if [[ -f error.mpassit ]]; then
        mecho0 "MPASSIT failed for all forecast minutes "
        return
    fi

    minstr=$(printf "%02d" $((intvl_sec/60)) )
    #minstr="00"
    fcst_minutes=()
    if [[ ${damode} == "init" || $icyc -eq 0 ]]; then
        fcst_minutes=("00")
    fi
    fcst_minutes+=("${minstr}")

    #
    # Prepare MPASSIT working files
    #
    if [[ ${#fcst_minutes[@]} -gt 0 ]]; then
        if [[ "${mpscheme}" == "mp_nssl2m" ]]; then
            fileappend="NSSL"
        else
            fileappend="THOM"
        fi

        jobarrays=()
        for mem in $(seq 1 $ENS_SIZE); do
            memstr=$(printf "%02d" $mem)
            memdir=$wrkdir/mem$memstr
            mkwrkdir $memdir 0
            cd $memdir || return

            rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

            # Linking working file for this member
            parmfiles=(diaglist histlist_2d histlist_3d histlist_soil)
            for fn in "${parmfiles[@]}"; do
                if [[ ! -e $fn ]]; then
                    #if [[ $verb -eq 1 ]]; then echo "Linking $fn ..."; fi
                    if [[ -e $FIXDIR/MPASSIT/${fn}.${fileappend} ]]; then
                        ln -sf $FIXDIR/MPASSIT/${fn}.${fileappend} $fn
                    elif [[ -e $FIXDIR/MPASSIT/${fn} ]]; then
                        ln -sf $FIXDIR/MPASSIT/$fn .
                    else
                        mecho0 "${RED}ERROR${NC}: file ${BLUE}$FIXDIR/MPASSIT/${fn}${NC} not exist."
                        return
                    fi
                fi
            done
            jobarrays+=("$mem")
        done

        jobarrays_str=$(get_jobarray_str "${mach}" "${jobarrays[@]}")

        cd $wrkdir || return

        run_mpassit_alltimes "${wrkdir}" "${iseconds}" "${fcst_minutes[*]}" "${jobarrays_str}"
    fi
}

########################################################################

function run_mpassit_alltimes {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local fcsttimes
    local -r jobarraystr=$4

    IFS=" " read -r -a fcsttimes <<< "$3"

    cd $wrkdir || return

    # Loop over forecast minutes
    local minsec=3600
    local maxsec=0

    for minstr in "${fcsttimes[@]}"; do
        (( i=10#${minstr}*60 ))
        (( i > maxsec )) && maxsec=$i
        (( i < minsec )) && minsec=$i

        prepare_mpassit_onetime $wrkdir ${iseconds} $i 5
        local estatus=$?               # number of missing members
        if [[ ${estatus} -gt 0 ]]; then
            echo -e "${PURPLE}${estatus}${NC} files missing"
            exit 1
        fi
    done

    #
    # Create job script and submit it
    #
    cd $wrkdir || return

    jobscript="run_mpassit.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="$npepost"
        [JOBNAME]="mpassit_${eventtime}"
        [CPUSPEC]="${claim_cpu_post}"
        [CLAIMTIME]="${claim_time_mpassit_alltimes}"
        [HHMINSTR]=""
        [FCST_START]="${minsec}"
        [FCST_END]="${maxsec}"
        [FCST_INTVL]="${intvl_sec}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_post}"
        jobParms[NCORES]="${ncores_post}"
    fi

    submit_a_job "$wrkdir" "mpassit" "jobParms" "$TEMPDIR/run_mpassit_array.${mach}" "$jobscript" "$jobarraystr"
}

########################################################################

function prepare_mpassit_onetime {
    # Work for one forecast time and all ensemble members
    # 1. Wait for the history/diag files
    # 2. Create namelist files

    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local -r fctseconds=$3
    local -r waitseconds=$4   # run all time together, it does not have to wait

    cd $wrkdir || return

    fminstr=$(printf "%03d" $((fctseconds/60)))
    fcst_lauch_time=$(date -u -d @${iseconds} +%H%M)

    isec=$(( iseconds+fctseconds ))
    fcst_time_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

    outdone=false
    jobarrays=()
    for mem in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $mem)
        memdir=$wrkdir/mem$memstr
        mkwrkdir $memdir 0
        cd $memdir || return

        rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

        fcstmemdir=$(upnlevels $memdir 2)
        histfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.history.${fcst_time_str}.nc"
        diagfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.diag.${fcst_time_str}.nc"

        if [[ $dorun == true ]]; then
            for fn in $histfile $diagfile; do
                if [[ $outdone == false ]]; then
                    mecho0 "Checking forecast files at $fminstr for all $ENS_SIZE memebers from dacycles${daffix}/${fcst_lauch_time} ..."
                    outdone=true
                fi
                while [[ ! -f $fn ]]; do
                    if [[ $verb -eq 1 ]]; then
                        mecho0 "Waiting for $fn ..."
                    fi
                    sleep 10
                done
                fileage=$(( $(date +%s) - $(stat -c %Y -- "$fn") ))
                if [[ $fileage -lt $waitseconds ]]; then
                    if [[ $verb -eq 1 ]]; then mecho0 "Waiting for $fn ..."; fi
                    sleep "$waitseconds"
                fi
            done
        fi

        nmlfile="namelist.fcst_$fminstr"
        cat << EOF > $nmlfile
&config
    grid_file_input_grid = "$rundir/init/${domname}_${memstr}.init.nc"
    hist_file_input_grid = "$histfile"
    diag_file_input_grid = "$diagfile"
    file_target_grid     = "$rundir/${domname/*_/geo_}/geo_em.d01.nc"
    target_grid_type     = "file"
    output_file          = "$memdir/MPASSIT_${memstr}.${fcst_time_str}.nc"
    interp_diag          = .true.
    interp_hist          = .true.
    wrf_mod_vars         = .true.
    esmf_log             = .false.
/
EOF
    done

    cd $wrkdir || return

    return 0
}

########################################################################

function run_clean {
    # $1     $2    $3      $4
    # start  end   option  tasks
    local start_sec=$1
    local end_sec=$2
    local coption=$3
    local jobs
    read -r -a jobs <<< "$4"

    wrkdir="$rundir/dacycles${daffix}"

    if [[ "$coption" == "-a" ]]; then
        declare -A cleanmsg=(
            [mpas]="all MPAS forecast files"
            [filter]="the whole DA cycle directory"
            [update_states]="all update_states files"
            [update_bc]="all update_bc files"
        )
        for job in "${jobs[@]}"; do
            mecho0  "${YELLOW}WARNING${NC}: Delete ${cleanmsg[$job]} from $(date -u -d @${start_sec} +%Y%m%d_%H:%M:%S) to $(date -u -d @${end_sec} +%Y%m%d_%H:%M:%S)"
            mecho0  "         in ${CYAN}${wrkdir}${NC}\n"
            mecho0n "[${YELLOW}YES,NO${NC}]? "
            read -r doit
            if [[ ${doit^^} == "YES" ]]; then
                mecho0 "${YELLOW}WARNING${NC}: ${cleanmsg[$job]} will be cleaned."
            else
                mecho0 "Got ${PURPLE}${doit^^}${NC}, do nothing."
                return
            fi
        done
    fi

    local isec
    local show="echo"
    if [[ $dorun == true ]]; then
        show=""
    fi

    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date    -u -d @$isec +%H%M)
        timestr_file=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

        dawrkdir=$wrkdir/$eventtime
        if [[ -d $dawrkdir ]]; then
            cd $dawrkdir || return

            if [[ $verb -eq 1 ]]; then mecho0 "Cleaning working directory ${CYAN}$dawrkdir${NC}"; fi

            for dirname in "${jobs[@]}"; do

                cd $dawrkdir || continue

                case $dirname in
                mpas )
                    ${show} rm -f fcst_??/error.fcst_* fcst_??/log.????.abort fcst_??/dart_log.*
                    ${show} rm -f fcst_??/log.atmosphere.????.{out,err}  fcst_??/namelist.output fcst_*_*.log
                    ${show} rm -f fcst_??/${domname}_??.{diag,history}.*.nc

                    if [[ "${eventtime}" =~ ??00 ]]; then
                        :       # keep lbc/{restart,init} for run MPAS free forecasts later
                    else
                        ${show} rm -f fcst_??/${domname}_??.lbc.${timestr_file}.nc
                        ${show} rm -f fcst_??/${domname}_??.{restart,init,prior}.${timestr_file}.nc
                    fi

                    ${show} rm -f fcst_??/mpas_XYZ.pkl fcst_??/wofs_mpas_grid_kdtree.pkl fcst_??/refl_*.{txt,pkl}
                    if [[ "$coption" == "-c" ]]; then
                        ${show} rm -f fcst_??/${domname}_??.{restart,init,prior}.*.nc
                    elif [[ "$coption" == "-a" ]]; then
                        ${show} rm -rf fcst_??
                    elif [[ "$coption" == "-d" ]]; then
                        ${show} rm -f fcst_??/${domname}_??.{restart,init,prior}.*.nc
                        ${show} rm -rf fcst_??/done.fcst_* fcst_??/done.update_{bc,states}_*
                    fi
                    ;;
                filter )
                    if [[ -e done.filter ]]; then
                        ${show} rm -f error.filter dart_log.{nml,out} obs_seq_to_netcdf.log filter_*.log obs_diag.log
                        ${show} rm -f preassim_*.nc #output_*.nc
                        ${show} find OBSDIR -type f -not -name "obs_seq.${timestr_curr}" -exec rm -f {} \;
                        ${show} rm -f noise_mask_*.log noise_pert_*.log mpas_XYZ.pkl wofs_mpas_grid_kdtree.pkl refl_*.{txt,pkl}
                        if [[ "$coption" == "-c" ]]; then
                            ${show} rm -f ${domname}_??.analysis
                        elif [[ "$coption" == "-a" ]]; then
                            cd $wrkdir || return
                            ${show} rm -rf $eventtime
                            break
                        elif [[ "$coption" == "-d" ]]; then
                            ${show} rm -f ${domname}_??.analysis
                            ${show} rm -f done.fcst done.filter done.update_bc done.update_states
                        fi
                    fi
                    ;;
                update_states )
                    if [[ -e done.update_states ]]; then
                        ${show} rm -f error.update_states update_states_*.log
                    fi
                    ;;
                update_bc )
                    if [[ -e done.update_bc ]]; then
                        ${show} rm -f error.update_bc update_bc_*.log
                    fi
                    ;;
                esac
            done
        else
            mecho0 "${RED}ERROR${NC}: ${CYAN}$dawrkdir${NC} not exist."
        fi
    done
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
#@ MAIN entry
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

source $scpdir/Common_Utilfuncs.sh || exit $?

#-----------------------------------------------------------------------
#
# Handle command line arguments (override default settings)
#
#-----------------------------------------------------------------------
#% ARGS

parse_args "$@"

[[ -v args["verb"] ]]      && verb=${args["verb"]}           || verb=0
[[ -v args["overwrite"] ]] && overwrite=${args["overwrite"]} || overwrite=0

[[ -v args["dorun"] ]]     && dorun=${args["dorun"]}   || dorun=true
[[ -v args["rt_run"] ]]    && rt_run=${args["rt_run"]} || rt_run=false

[[ -v args["cleanoption"] ]] && cleanoption=${args["cleanoption"]}              || cleanoption="clean"
[[ -v args["cleanjobs"] ]]   && read -r -a cleanjobs <<< "${args['cleanjobs']}" || cleanjobs=()

#-----------------------------------------------------------------------
#
# Get jobs to run
#
#-----------------------------------------------------------------------

[[ -v args["jobs"] ]] && read -r -a jobs <<< "${args['jobs']}" || jobs=(filter update_states update_bc mpas clean)

#-----------------------------------------------------------------------
#
# Set up working environment
#
#-----------------------------------------------------------------------

source "${scpdir}/Site_Runtime.sh" || exit $?

#[[ ${run_trimvr} == true || ${run_addnoise} == true ]] && use_python=true || use_python=false
setup_machine "${args['machine']}" "$rootdir" true false

[[ $dorun == false ]] && runcmd="echo $runcmd"

[[ -v args["WORKDIR"] ]] && WORKDIR=${args["WORKDIR"]} || WORKDIR="${workdirDF}"

#-----------------------------------------------------------------------
# Set Event Date
#-----------------------------------------------------------------------

[[ -v args["eventdate"] ]] && eventdate="${args['eventdate']}" || eventdate="$eventdateDF"

#-----------------------------------------------------------------------
# read configurations that is not set from command line
#-----------------------------------------------------------------------

if [[ -v args["config_file"] ]]; then
    config_file="${args['config_file']}"

    if [[ "$config_file" =~ "/" ]]; then
        WORKDIR=$(realpath "$(dirname ${config_file})")
    else
        config_file="${WORKDIR}/${config_file}"
    fi
    if [[ ${config_file} =~ config\.([0-9]{8})(.*) ]]; then
        [[ -v args["eventdate"] ]] || eventdate="${BASH_REMATCH[1]}"
        daffix="${BASH_REMATCH[2]}"
    elif [[ ${config_file} =~ config\.(.*)$ ]]; then
        daffix="_${BASH_REMATCH[1]}"
    else
        echo -e "${RED}ERROR${NC}: Config file ${CYAN}${config_file}${NC} not the right format config.YYYYmmdd[_*]."
        exit 1
    fi
else
    config_file="$WORKDIR/config.${eventdate}"
    daffix=""
fi

if [[ -r ${config_file} ]]; then
    echo -e "Reading case configuration file: ${CYAN}${config_file}${NC} ...."
else
    echo -e "${RED}ERROR${NC}: Configuration file ${CYAN}${config_file}${NC} is not found."
    echo -e "       Please run ${GREEN}setup_mpas-wofs.sh${NC} first."
    exit 2
fi

readconf ${config_file} COMMON MPAS_OPTIONS dacycles || exit $?
# get ENS_SIZE, time_step, EXTINVL, ADAPTIVE_INF, update_in_place

#
# Check configurations reading in
#
if [[ "${damode}" == "restart" || "${damode}" == "init" ]]; then
    :
else
    echo -e "${RED}ERROR${NC}: damode=${damode} is not supported."
    usage 1
fi

if [[ "${mpscheme}" =~ ^(mp_nssl2m|mp_thompson|mp_tempo)$ ]]; then
    :
else
    echo -e "${RED}ERROR${NC}: mpscheme=${PURPLE}${mpscheme}${NC} is not supported."
    usage 1
fi

if [[ $update_in_place == true ]]; then
    cpcmd="ln -sf"
else
    cpcmd="cp"
    #cpcmd="rsync -a"
fi

#-----------------------------------------------------------------------
# Set Event End Date and Time
#-----------------------------------------------------------------------

[[ -v args["inittime"] ]]  && inittime="${args['inittime']}"   || inittime="1500"
[[ -v args["eventtime"] ]] && eventtime="${args['eventtime']}" || eventtime="1500"
[[ -v args["endtime"] ]]   && endtime="${args['endtime']}"     || endtime="0300"

startday=""
if [[ ${#eventtime} -eq 12 ]]; then
    startdatetime=${eventtime}
    eventtime=${eventtime:8:4}
else
    (( 10#$eventtime < 10#$inittime )) && startday="1 day"
    startdatetime="${eventdate}${eventtime}"
fi

endday=""
if [[ ${#endtime} -eq 12 ]]; then
    enddatetime=${endtime}
else
    (( 10#$endtime < 10#$inittime )) && endday="1 day"
    enddatetime="${eventdate}${endtime}"
fi

inittime_sec=$(date  -u -d "${eventdate}         ${inittime}"                    +%s)
starttime_sec=$(date -u -d "${startdatetime:0:8} ${startdatetime:8:4} $startday" +%s)
stoptime_sec=$(date  -u -d "${enddatetime:0:8}   ${enddatetime:8:4}   $endday"   +%s)

enddatetime=$(date   -u -d @$stoptime_sec +%Y%m%d%H%M)

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Perform DA cycles
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#% ENTRY

rundir="$WORKDIR/${eventdate}"
if [[ ! -d $rundir ]]; then
    mkdir -p $rundir
fi

echo    ""
echo -e "---- Jobs (${YELLOW}$$${NC}) started at $(date +'%m-%d %H:%M:%S (%Z)') on host ${LIGHT_RED}$(hostname)${NC} ----\n"
echo -e "  Event  date: ${WHITE}$eventdate${NC} ${YELLOW}${eventtime}${NC} --> ${WHITE}${enddatetime:0:8}${NC} ${YELLOW}${enddatetime:8:4}${NC}"
echo -e "  ROOT    dir: ${rootdir}${BROWN}/scripts${NC}"
echo -e "  TEMP    dir: ${PURPLE}${TEMPDIR}${NC}"
echo -e "  FIXED   dir: ${DARK}${FIXDIR}${NC}"
echo -e "  EXEC    dir: ${GREEN}${EXEDIR}${NC}"
echo -e "  Working dir: ${WHITE}${WORKDIR}${LIGHT_BLUE}/${eventdate}/dacycles${daffix}${NC}"
echo -e "  Domain name: ${RED}$domname${NC};  MP scheme: ${CYAN}${mpscheme}${NC}"
echo    " "

jobname="${eventdate:4:4}"

RSTINVL=${intvl_sec}
if [[ ${outwrf} == true ]]; then
    jobs+=(mpassit)
    OUTINVL=${RSTINVL}
else
    OUTINVL=$((2*RSTINVL))
fi


RSTINVL_STR=$(printf "00:%02d:00" $((RSTINVL/60)) )
OUTINVL_STR=$(printf "00:%02d:00" $((OUTINVL/60)) )

#
# Start the data assimilation cycles
#

# $1    $2    $3
# init start  end
if [[ " ${jobs[*]} " =~ " "(getkf_observer|getkf_solver|getkf_post|mpas|ioda)" " ]]; then
    dacycle_driver $inittime_sec $starttime_sec $stoptime_sec
elif [[ " ${jobs[*]} " =~ " clean " ]]; then

    if [[ ${#cleanjobs[@]} -eq 0 ]]; then
        cleanjobs=(mpas filter update_states update_bc)
    fi
    run_clean "${starttime_sec}" "${stoptime_sec}" "${cleanoption}" "${cleanjobs[*]}"
fi

echo -e "\n==== Jobs done $(date +'%m-%d %H:%M:%S (%Z)') ====\n"

exit 0
