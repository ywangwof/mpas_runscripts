#!/bin/bash

#rootdir="/scratch/ywang/MPAS/mpas_runscripts"
scpdir="$( cd "$( dirname "$0" )" && pwd )"              # dir of script
rootdir=$(realpath $(dirname $scpdir))

eventdateDF=$(date +%Y%m%d)

#-----------------------------------------------------------------------
#
# This is the 4th step of th WOFS-MPAS workflow. It run program filter,
# update_mpas_states, and atmosphere_model to perform the DA cycles and the forward forecasting.
#
# Required files from ROOTDIR
#
# 0. module files in modules
#     build_jet_intel18_1.11_smiol
#     build_jet_intel18_1.11                # PIO version
#
# 1. exec                                   # The executables
#     atmosphere_model.single
#     filter
#     update_mpas_states
#
# 2. templates                              # templates used in this scripts
#    README
#
#    2.1 SLURM scripts on Jet
#        run_filter.slurm                    or run_filter.pbs
#        run_mpas_array.slurm                or run_mpas_array.pbs
#        run_update_states.slurm             or run_update_states.pbs
#
# 3. fix_files                              # runtime fix files for MPAS model and accompany programs
#
#    3.1 tables for Thompson cloud microphysics scheme
#        *MP_THOMPSON_QIautQS_DATA.DBL
#        *MP_THOMPSON_QRacrQG_DATA.DBL
#        *MP_THOMPSON_QRacrQS_DATA.DBL
#        *MP_THOMPSON_freezeH2O_DATA.DBL
#
#        Can be generated by submitting job script templates/build_tables.slurm
#
#    3.2 MPASS run-time static files
#        stream_list.atmosphere.diagnostics
#        stream_list.atmosphere.output
#        stream_list.atmosphere.surface
#
#        *CAM_ABS_DATA.DBL
#        *CAM_AEROPT_DATA.DBL
#        *GENPARM.TBL
#        *LANDUSE.TBL
#        *OZONE_DAT.TBL
#        *OZONE_LAT.TBL
#        *OZONE_PLEV.TBL
#        *RRTMG_LW_DATA
#        *RRTMG_LW_DATA.DBL
#        *RRTMG_SW_DATA
#        *RRTMG_SW_DATA.DBL SOILPARM.TBL
#        *VEGPARM.TBL
#
#    NOTE:
#         * not in the git repository
#
# INSTRUCTIONS:
#
#  Use existing domain (wofs_mpas)
#     1. Copy these directories to rootdir (or clone using git)
#        modules
#        exec
#        scripts
#        templates
#        fix_files (link needed files use script lnwrkfiles.sh, see README in that directory)
#
#     2. make a run directory under rootdir
#        run_dirs
#
#     3. Copy existing domain directories $rootdir/run_dirs/wofs_maps & geo_mpas to
#        your run_dirs
#
#     4. run_dacycles.sh [YYYYmmddHH] [run_dirs] [jobnames]
#
#-----------------------------------------------------------------------

function usage {
    echo " "
    echo "    USAGE: $0 [options] DATETIME [WORKDIR] [JOBS]"
    echo " "
    echo "    PURPOSE: Run MPAS-WOFS DA cycles."
    echo " "
    echo "    DATETIME - Case date and time in YYYYmmddHHMM, Default for now"
    echo "    WORKDIR  - Run Directory"
    echo "    JOBS     - One or more jobs from [filter,update_states,mpas]"
    echo "               Default all jobs in a DA cyle"
    echo " "
    echo "    OPTIONS:"
    echo "              -h                  Display this message"
    echo "              -n                  Show command to be run and generate job scripts only"
    echo "              -v                  Verbose mode"
    echo "              -k  [0,1,2]         Keep working directory if exist, 0- keep as is; 1- overwrite; 2- make a backup as xxxx.bak?"
    echo "                                  Default is 0 for ungrib, mpassit, upp and 1 for others"
    echo "              -t  DIR             Template directory for runtime files"
    echo "              -w                  Hold script to wait for all job conditions are satified and submitted (for mpassit & upp)."
    echo "                                  By default, the script will exit after submitting all possible jobs."
    echo "              -m  Machine         Machine name to run on, [Jet, Cheyenne, Vecna]."
    echo "              -a  wof             Account name for job submission."
    echo "              -d  wofs_mpas       Domain name to be used"
    echo "              -i  YYYYmmddHHMM    Initial time, default: same as start time from the command line argument"
    echo "              -e  YYYYmmddHHMM    End date & time of the DA cycles"
    echo "                  HHMM            End time of the DA cycles"
    echo "              -p  nssl            MP scheme, [nssl, thompson], default: nssl"
    echo " "
    echo "   DEFAULTS:"
    echo "              eventdt = $eventdateDF"
    echo "              rootdir = $rootdir"
    echo "              WORKDIR = $rootdir/run_dirs"
    echo "              TEMPDIR = $rootdir/templates"
    echo "              FIXDIR  = $rootdir/fix_files"
    echo " "
    echo "                                     -- By Y. Wang (2023.05.31)"
    echo " "
    exit $1
}

########################################################################

function run_obsmerge {
    # $1        $2          $3
    # wrkdir    iseconds    seqfilename
    local wrkdir=$1
    local iseconds=$2
    local outfilename=$3

    if [[ ! -d $wrkdir ]]; then
        echo "run_obsmerge: Working directory $wrkdir not exist"
        exit 1
    fi

    anlys_date=$(date -d @$iseconds  +%Y%m%d)
    anlys_time=$(date -d @$iseconds  +%H%M)

    if [[ $verb -eq 1 ]]; then
        srunout="1"
    else
        srunout="output.srun"
    fi

    if [[ $verb -eq 1 ]]; then echo "Runing ${exedir}/dart/convertdate"; fi
    g_datestr=($(${exedir}/dart/convertdate << EOF
1
${anlys_date:0:4} ${anlys_date:4:2} ${anlys_date:6:2} ${anlys_time:0:2} ${anlys_time:2:2} 00
EOF
))
    g_date=${g_datestr[-2]}
    g_sec=${g_datestr[-1]}
    #echo $g_date, $g_sec

    mkwrkdir $wrkdir/OBSDIR 1     # 0: Keep existing directory as is
                                  # 1: Remove existing same name directory
    cd $wrkdir/OBSDIR

    rm -fr obsflist.hfmetar obsflist.meso obsflist.sat obsflist.rad obsflist obs_seq.*

    obspreprocess=${exedir}/dart/mpas_dart_obs_preprocess

    #ln -sf ${wrkdir}/input.nml ./input.nml
    cp ${wrkdir}/input.nml input.nml
    template_inputfile=$(head -1 $wrkdir/filter_in.txt)
    ln -sf $template_inputfile init.nc

    obsflists=()
    #=================================================
    # PREPROCESS OK MESONET DATA
    #=================================================

    if [[ -e ${OBS_DIR}/Mesonet/obs_seq_okmeso.${anlys_date}${anlys_time} ]]; then
        echo "    Using Mesonet observations in ${OBS_DIR}/Mesonet/obs_seq_okmeso.${anlys_date}${anlys_time}"
        echo ${OBSDIR}/Mesonet/obs_seq_okmeso.${anlys_date}${anlys_time} > obsflist.meso
        obsflists+=(obsflist.meso)
    else
        echo "    Mesonet not found: ${OBS_DIR}/Mesonet/obs_seq_okmeso.${anlys_date}${anlys_time}"
    fi

    #=================================================
    # PREPROCESS GOES SATELLITE CWP DATA
    #=================================================

    CWP_DIR=${OBS_DIR}/CWP
    if [[ -e ${CWP_DIR}/obs_seq_cwp.G16_V04.${anlys_date}${anlys_time} ]]; then
        echo "    Using CWP data in ${CWP_DIR}/obs_seq_cwp.G16_V04.${anlys_date}${anlys_time}"

        cp ${CWP_DIR}/obs_seq_cwp.G16_V04.${anlys_date}${anlys_time} ./obs_seq.old

        if [[ $verb -eq 1 ]]; then
            echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi
        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >& $srunout

        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.cwp

            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.cwp > obsflist.cwp

            obsflists+=(obsflist.cwp)
        else
            echo "Error with command ${obspreprocess} for CWP data"
        fi
    else
        echo "    CWP not found: ${CWP_DIR}/obs_seq_cwp.GOES-16_V04.${anlys_date}${anlys_time}"
    fi

    #=================================================
    # PREPROCESS RADAR DATA
    #=================================================

    ############
    ### MRMS ###
    ############

    DBZ_DIR=${OBS_DIR}/REF
    if [[ -e ${DBZ_DIR}/${eventdate}/obs_seq_RF_${anlys_date}_${anlys_time}.out ]]; then

        echo "    Using REF data in ${DBZ_DIR}/${eventdate}/obs_seq_RF_${anlys_date}_${anlys_time}.out"

        cp ${DBZ_DIR}/${eventdate}/obs_seq_RF_${anlys_date}_${anlys_time}.out ./obs_seq.old

        if [[ $verb -eq 1 ]]; then
            echo "    Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi
        ${runcmd_str} echo "$g_date $g_sec" | ${obspreprocess} >& $srunout

        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.mrms

            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.mrms > obsflist.mrms

            obsflists+=(obsflist.mrms)
        else
            echo "Error with command ${obspreprocess} for REF data"
        fi
    else
        echo "    REF data not found: ${DBZ_DIR}/${eventdate}/obs_seq_RF_${anlys_date}_${anlys_time}.out"
    fi
    echo "    "

    #############
    ### Radial Velocity
    #############

    #
    # Source environment for radars
    #

    if [[ -e $rundir/$domname/radars.${eventdate}.sh ]]; then
        source $rundir/$domname/radars.${eventdate}.sh
    else
        echo "ERROR: File $rundir/$domname/radars.${eventdate}.sh not exist"
        exit 0
    fi

    VR_DIR=${OBS_DIR}/VEL

    j=0; n=0
    while [[ ${j} -lt ${num_rad} ]]; do

        if [[ -e ${VR_DIR}/${eventdate}/obs_seq_${rad_name[$j]}_VR_${anlys_date}_${anlys_time}.out ]]; then

            echo "    Using VEL data in ${VR_DIR}/${eventdate}/obs_seq_${rad_name[$j]}_VR_${anlys_date}_${anlys_time}.out"

            cp ${VR_DIR}/${eventdate}/obs_seq_${rad_name[$j]}_VR_${anlys_date}_${anlys_time}.out ./obs_seq.old

            if [[ $verb -eq 1 ]]; then
                echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
            fi
            ${runcmd_str} echo "$g_date $g_sec" | ${obspreprocess} >& $srunout

            if [[ -e ./obs_seq.new ]]; then
                mv ./obs_seq.new ./obs_seq.vr${j}
                rm ./obs_seq.old
                echo $wrkdir/OBSDIR/obs_seq.vr${j} >> obsflist.rad
                let n++
            fi

        fi

        let j++
    done

    if [[ $n -gt 0 ]]; then
        obsflists+=(obsflist.rad)
    else
        echo "    No valid radial velocity data is processed"
    fi

    #=================================================

    if [[ ${#obsflists[@]} -gt 0 ]]; then
        cat ${obsflists[*]} > obsflist
    else
        echo "    No valid observation was found"
        exit 0
    fi

    #=================================================

    if [[ $verb -eq 1 ]]; then echo "Runing ${exedir}/dart/advance_time"; fi
    gobef=($(echo ${anlys_date}${anlys_time} -5m-29s -g | ${exedir}/dart/advance_time))
    goaft=($(echo ${anlys_date}${anlys_time} +2m+30s -g |  ${exedir}/dart/advance_time))

    sedfile=$(mktemp -t input.nml_${eventtime}.sed_XXXX)

    cat <<EOF > $sedfile
/first_obs_days/s/-1/${gobef[0]}/
/first_obs_seconds/s/-1/${gobef[1]}/
/last_obs_days/s/-1/${goaft[0]}/
/last_obs_seconds/s/-1/${goaft[1]}/
EOF

    sed -f $sedfile -i input.nml

    #=================================================

    #COMBINE obs-seq FILES HERE
    if [[ $verb -eq 1 ]]; then echo "Runing ${exedir}/dart/obs_sequence_tool"; fi
    ${runcmd_str} ${exedir}/dart/obs_sequence_tool >& $srunout

    if [[ $? -eq 0 && -e obs_seq.${anlys_date}${anlys_time} ]]; then
        echo "    Observation file ${wrkdir}/OBSDIR/obs_seq.${anlys_date}${anlys_time} created"
    else
        echo "ERROR: srun ${exedir}/dart/obs_sequence_tool"
    fi

#    # Recover input.nml to the original state
#    cat <<EOF > $sedfile
#/first_obs_days/s/=.*$/= -1/
#/first_obs_seconds/s/=.*$/= -1/
#/last_obs_days/s/=.*$/= -1/
#/last_obs_seconds/s/=.*$/= -1/
#EOF
#
#    sed -f $sedfile -i input.nml

    rm -f $sedfile

    #rm -f ./obs_seq.hfmetar ./obs_seq.meso ./obs_seq.cwp ./obs_seq.mrms ./obs_seq.rad ./obs_seq.vr*

    #rm -f dart_log.* obsflist* init.nc
    #rm -f obsflist* wrfinput_d0*

    echo " "
    cd $wrkdir
}

########################################################################

function run_filter {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, ADAPTIVE_INF, OBS_DIR
    #         intvl_sec, ncores_filter
    # RETURN: input_file_list, output_file_list
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/filter.running || -f $wrkdir/done.filter || -f $wrkdir/queue.filter ]]; then
        return
    fi

    timesec_pre=$((iseconds-intvl_sec))
    event_pre=$(date -d @$timesec_pre   +%H%M)
    timestr_cur=$(date -d @$iseconds    +%Y%m%d%H%M)

    parentdir=$(dirname $wrkdir)

    #------------------------------------------------------
    # Waiting for job conditions before submit the job
    #------------------------------------------------------

    if [[ $icycle -eq 0 ]]; then
        conditions=($rundir/init/done.init)
    else
        conditions=($parentdir/${event_pre}/done.fcst)
    fi

    if [[ $dorun == true ]]; then
        for cond in ${conditions[@]}; do
            echo "$$-${FUNCNAME[0]}: Checking: $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # 1. Update input files to get filter started
    #------------------------------------------------------

    currtime_str=$(date -d @$iseconds +%Y-%m-%d_%H.%M.%S)

    rm -f filter_in.txt filter_out.txt
    input_file_list=()
    output_file_list=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        if [[ $icycle -eq 0 ]]; then
            input_file="$rundir/init/wofs_mpas_${memstr}.init.nc"
        else
            input_file="$parentdir/${event_pre}/wofs_mpas_${memstr}.restart.$currtime_str.nc"
        fi

        if [[ ! -f $input_file ]]; then
            echo "File $input_file not exist."
            exit 1
        fi
        echo $input_file >> filter_in.txt
        input_file_list+=($input_file)

        #output_file="${domname}_${memstr}.analysis.$currtime_str.nc"
        output_file="${domname}_${memstr}.analysis"
        echo $output_file >> filter_out.txt
        output_file_list+=($output_file)
    done

    if [[ $icycle -eq 0 ]]; then
        # Skip filter at cycle 0 temporarily
        return
    fi

    firstfile=$(head -1 filter_in.txt)
    ln -sf $firstfile init.nc             # The name of the MPAS analysis file to
                                         # be read and/or written by the DART
                                         # programs for the state data.
    #------------------------------------------------------
    # 2. Adaptive inflation
    #------------------------------------------------------

    inf_initial=(".false" ".false.")
    if [[ $ADAPTIVE_INF == true && $icycle -gt 1 ]]; then
        if [[ ! -e ${parentdir}/${event_pre}/output_priorinf_mean.nc ]]; then
          echo "File ${parentdir}/${event_pre}/output_priorinf_mean.nc does not exist. Stop."
          exit 2
        fi
        ln -sf ${parentdir}/${event_pre}/output_priorinf_mean.nc input_priorinf_mean.nc
        ln -sf ${parentdir}/${event_pre}/output_priorinf_sd.nc   input_priorinf_sd.nc

        inf_initial=(".true" ".true.")
    fi

    #------------------------------------------------------
    # 3. Prepare namelist file
    #------------------------------------------------------
    cat << EOF > input.nml
&perfect_model_obs_nml
   read_input_state_from_file = .true.
   single_file_in             = .false.
   input_state_files          = 'mpas_init.nc'
   init_time_days             = -1
   init_time_seconds          = -1

   write_output_state_to_file = .false.
   single_file_out            = .false.
   output_state_files         = 'perfect_restart.nc'
   output_interval            = 1

   async                      = 0
   adv_ens_command            = './advance_model.csh'

   obs_seq_in_file_name       = 'obs_seq.in'
   obs_seq_out_file_name      = 'obs_seq.out'
   first_obs_days             = -1
   first_obs_seconds          = -1
   last_obs_days              = -1
   last_obs_seconds           = -1

   trace_execution            = .true.
   output_timestamps          = .false.
   print_every_nth_obs        = 0
   output_forward_op_errors   = .false.
   silence                    = .false.
  /

&filter_nml
   async                    = 0
   adv_ens_command          = 'no_model_advance'
   ens_size                 = ${ENS_SIZE}
   output_members           = .true.
   obs_sequence_in_name     = 'obs_seq.in'
   obs_sequence_out_name    = 'obs_seq.final'
   input_state_file_list    = 'filter_in.txt'
   output_state_file_list   = 'filter_out.txt'
   init_time_days           = -1
   init_time_seconds        = -1
   first_obs_days           = -1
   first_obs_seconds        = -1
   last_obs_days            = -1
   last_obs_seconds         = -1
   num_output_state_members = 0
   num_output_obs_members   = 3
   output_interval          = 1
   num_groups               = 1
   distributed_state        = .true.
   compute_posterior        = .true.
   output_forward_op_errors = .false.
   output_timestamps        = .false.
   trace_execution          = .false.
   silence                  = .false.

   stages_to_write          = 'preassim', 'output'
   output_members           = .true.
   output_mean              = .true.
   output_sd                = .true.
   write_all_stages_at_end  = .false.

   inf_flavor                  = 2,                       0,
   inf_initial_from_restart    = $(join_by_comma ${inf_initial[@]}),
   inf_sd_initial_from_restart = $(join_by_comma ${inf_initial[@]}),
   inf_deterministic           = .true.,                  .true.,
   inf_initial                 = 1.0,                     1.0
   inf_sd_initial              = 0.6,                     0.0
   inf_damping                 = 0.9,                     1.0
   inf_lower_bound             = 1.0,                     1.0
   inf_upper_bound             = 1000.0,               1000000.0
   inf_sd_lower_bound          = 0.6,                     0.0
   inf_sd_max_change           = 1.05,                    1.05,
  /

&quality_control_nml
   input_qc_threshold = 3,
   outlier_threshold  = 3,
   enable_special_outlier_code = .false.
  /

&state_vector_io_nml
   single_precision_output    = .true.,
  /

&mpi_utilities_nml
  /

&smoother_nml
   num_lags              = 0
   start_from_restart    = .true.
   output_restart        = .false.
   restart_in_file_name  = 'smoother_ics'
   restart_out_file_name = 'smoother_restart'
  /

&ensemble_manager_nml
   layout = 1
   tasks_per_node = ${ncores_filter}
  /

&assim_tools_nml
   filter_kind                       = 1
   cutoff                            = 0.00015
   distribute_mean                   = .false.
   convert_all_obs_verticals_first   = .true.
   convert_all_state_verticals_first = .false.
   sort_obs_inc                      = .false.
   spread_restoration                = .false.
   sampling_error_correction         = .false.
   adaptive_localization_threshold   = -1
   output_localization_diagnostics   = .false.
   localization_diagnostics_file     = 'localization_diagnostics'
   print_every_nth_obs               = 0
  /

&location_nml
   horiz_dist_only                 = .false.
   vert_normalization_pressure     = 100000.0
   vert_normalization_height       = 30000.0
   vert_normalization_level        = 20.0
   vert_normalization_scale_height = 2.0
   approximate_distance            = .false.
   nlon                            = 141
   nlat                            = 72
   output_box_info                 = .false.
   print_box_level                 = 0
  /

&xyz_location_nml
  /

&cov_cutoff_nml
   select_localization = 1
  /

&reg_factor_nml
   select_regression    = 1
   input_reg_file       = 'time_mean_reg'
   save_reg_diagnostics = .false.
   reg_diagnostics_file = 'reg_diagnostics'
  /

&obs_sequence_nml
   write_binary_obs_sequence = .false.
  /

&obs_kind_nml
   assimilate_these_obs_types = 'RADIOSONDE_TEMPERATURE',
                                'RADIOSONDE_U_WIND_COMPONENT',
                                'RADIOSONDE_V_WIND_COMPONENT',
                                'RADIOSONDE_SPECIFIC_HUMIDITY',
                                'GPSRO_REFRACTIVITY',
                                'LAND_SFC_ALTIMETER',
                                'MARINE_SFC_DEWPOINT',
                                'AIRCRAFT_U_WIND_COMPONENT',
                                'AIRCRAFT_V_WIND_COMPONENT',
                                'AIRCRAFT_TEMPERATURE',
                                'ACARS_U_WIND_COMPONENT',
                                'ACARS_V_WIND_COMPONENT',
                                'ACARS_TEMPERATURE',
                                'SAT_U_WIND_COMPONENT',
                                'SAT_V_WIND_COMPONENT',
                                'RADAR_REFLECTIVITY',
                                'RADAR_CLEARAIR_REFLECTIVITY',
                                'DOPPLER_RADIAL_VELOCITY'

   evaluate_these_obs_types = ''
  /

&obs_def_gps_nml
   max_gpsro_obs = 100000
  /

&obs_def_radar_mod_nml
   apply_ref_limit_to_obs     =  .true. ,
   reflectivity_limit_obs     =     0.0 ,
   lowest_reflectivity_obs    =     0.0 ,
   apply_ref_limit_to_fwd_op  =  .true. ,
   reflectivity_limit_fwd_op  =     0.0 ,
   lowest_reflectivity_fwd_op =     0.0 ,
   dielectric_factor          =   0.224 ,
   n0_rain                    =   8.0e6 ,
   n0_graupel                 =   4.0e6 ,
   n0_snow                    =   3.0e6 ,
   rho_rain                   =  1000.0 ,
   rho_graupel                =   400.0 ,
   rho_snow                   =   100.0 ,
   allow_wet_graupel          = .false. ,
   microphysics_type          =       5 ,
   allow_dbztowt_conv         = .true.
/
&obs_def_cwp_nml
   pressure_top               = 15000.0,
   physics                    = 8
/

&model_nml
   init_template_filename       = 'init.nc'
   assimilation_period_days     = 0
   assimilation_period_seconds  = ${intvl_sec}
   model_perturbation_amplitude = 0.0001
   vert_localization_coord      = 3
   calendar                     = 'Gregorian'
   highest_obs_pressure_mb      = 1.0
   sfc_elev_max_diff            = 100.
   log_p_vert_interp            = .false.
   debug                        = 0
   use_u_for_wind               = .false.
   use_rbf_option               = 2
   update_u_from_reconstruct    = .true.
   use_increments_for_u_update  = .true.
  /

!                          'theta',                 'QTY_POTENTIAL_TEMPERATURE',
!                          'surface_pressure',      'QTY_SURFACE_PRESSURE',
!                          'uReconstructZonal',     'QTY_U_WIND_COMPONENT',
!                          'uReconstructMeridional','QTY_V_WIND_COMPONENT',
!                          'u',                     'QTY_EDGE_NORMAL_SPEED',
!                          'w',                     'QTY_VERTICAL_VELOCITY',
!                          'qv',                    'QTY_VAPOR_MIXING_RATIO',
!                          'rho',                   'QTY_DENSITY',
!                          'u10',                   'QTY_10M_U_WIND_COMPONENT',
!                          'v10',                   'QTY_10M_V_WIND_COMPONENT',
!                          't2m',                   'QTY_2M_TEMPERATURE',
!                          'q2',                    'QTY_2M_SPECIFIC_HUMIDITY',

&mpas_vars_nml
   mpas_state_variables = 'theta',                 'QTY_POTENTIAL_TEMPERATURE',
                          'rho',                   'QTY_DENSITY',
                          'uReconstructZonal',     'QTY_U_WIND_COMPONENT',
                          'uReconstructMeridional','QTY_V_WIND_COMPONENT',
                          'w',                     'QTY_VERTICAL_VELOCITY',
                          'qv',                    'QTY_VAPOR_MIXING_RATIO',
                          'surface_pressure',      'QTY_SURFACE_PRESSURE',
                          'qc',                    'QTY_CLOUDWATER_MIXING_RATIO',
                          'qr',                    'QTY_RAINWATER_MIXING_RATIO',
                          'qi',                    'QTY_ICE_MIXING_RATIO',
                          'qs',                    'QTY_SNOW_MIXING_RATIO',
                          'qg',                    'QTY_GRAUPEL_MIXING_RATIO',
                          'qh',                    'QTY_HAIL_MIXING_RATIO',
                          'volg',                  'QTY_GRAUPEL_VOLUME',
                          'volh',                  'QTY_HAIL_VOLUME',
                          'nc',                    'QTY_DROPLET_NUMBER_CONCENTR',
                          'nr',                    'QTY_RAIN_NUMBER_CONCENTR',
                          'ni',                    'QTY_ICE_NUMBER_CONCENTRATION',
                          'ns',                    'QTY_SNOW_NUMBER_CONCENTR',
                          'ng',                    'QTY_GRAUPEL_NUMBER_CONCENTR',
                          'nh',                    'QTY_HAIL_NUMBER_CONCENTR',
                          'refl10cm',              'QTY_RADAR_REFLECTIVITY',
   mpas_state_bounds    = 'qv','0.0','NULL','CLAMP',
                          'qc','0.0','NULL','CLAMP',
                          'qr','0.0','NULL','CLAMP',
                          'qi','0.0','NULL','CLAMP',
                          'qs','0.0','NULL','CLAMP',
                          'qg','0.0','NULL','CLAMP',
                          'qh','0.0','NULL','CLAMP',
                          'volg','0.0','NULL','CLAMP',
                          'volh','0.0','NULL','CLAMP',
                          'nc','0.0','NULL','CLAMP',
                          'nr','0.0','NULL','CLAMP',
                          'ni','0.0','NULL','CLAMP',
                          'ns','0.0','NULL','CLAMP',
                          'ng','0.0','NULL','CLAMP',
                          'ng','0.0','NULL','CLAMP',
  /

&update_mpas_states_nml
  update_input_file_list  = 'filter_out.txt'
  update_output_file_list = 'filter_in.txt'
  print_data_ranges       = .true.
  /

&update_bc_nml
  update_analysis_file_list           = 'filter_in.txt'
  update_boundary_file_list           = 'boundary_inout.txt'
  lbc_update_from_reconstructed_winds = .false.
  lbc_update_winds_from_increments    = .false.
  debug = 0
/

&utilities_nml
   TERMLEVEL      = 1
   module_details = .false.
   logfilename    = 'dart_log.out'
   nmlfilename    = 'dart_log.nml'
   write_nml      = 'file'
  /

&preprocess_nml
   overwrite_output        = .true.
   input_obs_def_mod_file  = '../../../observations/forward_operators/DEFAULT_obs_def_mod.F90'
   output_obs_def_mod_file = '../../../observations/forward_operators/obs_def_mod.f90'
   input_obs_qty_mod_file  = '../../../assimilation_code/modules/observations/DEFAULT_obs_kind_mod.F90'
   output_obs_qty_mod_file = '../../../assimilation_code/modules/observations/obs_kind_mod.f90'
   obs_type_files          = '../../../observations/forward_operators/obs_def_reanalysis_bufr_mod.f90',
                             '../../../observations/forward_operators/obs_def_altimeter_mod.f90',
                             '../../../observations/forward_operators/obs_def_gts_mod.f90',
                             '../../../observations/forward_operators/obs_def_metar_mod.f90',
                             '../../../observations/forward_operators/obs_def_gps_mod.f90',
                             '../../../observations/forward_operators/obs_def_vortex_mod.f90',
                             '../../../observations/forward_operators/obs_def_rel_humidity_mod.f90',
                             '../../../observations/forward_operators/obs_def_dew_point_mod.f90',
                             '../../../observations/forward_operators/obs_def_radar_mod.f90',
                             '../../../observations/forward_operators/obs_def_cwp_mod.f90'
   quantity_files          = '../../../assimilation_code/modules/observations/atmosphere_quantities_mod.f90'
  /

&obs_sequence_tool_nml
   num_input_files   = 1
   filename_seq_list = 'obsflist'
   filename_out      = 'obs_seq.${timestr_cur}'
   first_obs_days    = -1
   first_obs_seconds = -1
   last_obs_days     = -1
   last_obs_seconds  = -1
   print_only        = .false.
   min_lat           = -90.0
   max_lat           =  90.0
   min_lon           =   0.0
   max_lon           = 360.0
   gregorian_cal     = .true.
   keep_types        = .true.
   obs_types         = ''
  /

# The times in the namelist for the obs_diag program are vectors
# that follow the following sequence:
# year   month   day   hour   minute   second
# max_num_bins can be used to specify a fixed number of bins,
# in which case last_bin_center should be safely in the future.
#
# keep only the U and V radiosonde winds:
#   obs_types          = 'RADIOSONDE_U_WIND_COMPONENT'
#                        'RADIOSONDE_V_WIND_COMPONENT'
#   keep_types         = .true.
#
# remove the U and V radiosonde winds:
#   obs_types          = 'RADIOSONDE_U_WIND_COMPONENT'
#                        'RADIOSONDE_V_WIND_COMPONENT'
#   keep_types         = .false.
#
# keep only observations with a DART QC of 0:
#   qc_metadata        = 'Dart quality control'
#   min_qc             = 0
#   max_qc             = 0
#
# keep only radiosonde temp obs between 250 and 300 K:
#   copy_metadata      = 'NCEP BUFR observation'
#   copy_type          = 'RADIOSONDE_TEMPERATURE'
#   min_copy           = 250.0
#   max_copy           = 300.0
#


&schedule_nml
   calendar             = 'Gregorian'
   first_bin_start      =  1601,  1,  1,  0,  0,  0
   first_bin_end        =  2999,  1,  1,  0,  0,  0
   last_bin_end         =  2999,  1,  1,  0,  0,  0
   bin_interval_days    = 1000000
   bin_interval_seconds = 0
   max_num_bins         = 1000
   print_table          = .true.
  /


&obs_seq_to_netcdf_nml
   obs_sequence_name = 'obs_seq.final'
   obs_sequence_list = ''
   append_to_netcdf  = .false.
   lonlim1           =    0.0
   lonlim2           =  360.0
   latlim1           =  -90.0
   latlim2           =   90.0
   verbose           = .true.
  /


&obs_diag_nml
   obs_sequence_name  = 'obs_seq.final'
   first_bin_center = 2010,10,23,12,00,00
   last_bin_center  = 2010,10,23,12,00,00
   bin_width        =    0, 0, 1,00,00,00
   time_to_skip     =    0, 0, 0,00,00,00
   trusted_obs      = 'null'
   nregions  = 1
   lonlim1   =   0.0
   lonlim2   = 360.0
   latlim1   = -90.0
   latlim2   =  90.0
   reg_names = 'global'
   create_rank_histogram = .true.
   outliers_in_histogram = .true.
   use_zero_error_obs    = .false.
   verbose               = .true.
  /

&obs_common_subset_nml
   num_to_compare_at_once = 2
   filename_seq           = ''
   filename_seq_list      = ''
   filename_out_suffix    = '.common'
   calendar               = 'Gregorian'
   print_every            = 1000
   dart_qc_threshold      = 3
   print_only             = .false.
  /

# possible vertical coordinate systems are:
# VERTISUNDEF VERTISSURFACE VERTISLEVEL VERTISPRESSURE VERTISHEIGHT VERTISSCALEHEIGHT
   quantity_of_interest = 'QTY_SURFACE_PRESSURE'
   quantity_of_interest = 'QTY_POTENTIAL_TEMPERATURE'
   quantity_of_interest = 'QTY_TEMPERATURE'
   quantity_of_interest = 'QTY_U_WIND_COMPONENT'
   quantity_of_interest = 'QTY_V_WIND_COMPONENT'
   quantity_of_interest = 'QTY_DENSITY'
   quantity_of_interest = 'QTY_VAPOR_MIXING_RATIO'

&model_mod_check_nml
   input_state_files     = 'mpas_init.nc'
   output_state_files    = 'check_me.nc'
   test1thru             = 0
   run_tests             = 1,2,3,4,5,7
   x_ind                 = 300
   loc_of_interest       = 240.0, 0.0, 10000.0
   quantity_of_interest  = 'QTY_U_WIND_COMPONENT'
   interp_test_lonrange  = 0.0, 359.0
   interp_test_dlon      = 1.0
   interp_test_latrange  = -89.0, 89.0
   interp_test_dlat      = 1.0
   interp_test_vertrange = 100.0,  20100.0
   interp_test_dvert     = 2000.0
   interp_test_vertcoord = 'VERTISHEIGHT'
   verbose               = .false.
  /

&exhaustion_nml
   dart_input_file       = 'dart_ics'
   output_file           = 'exhaust'
   advance_time_present  = .FALSE.
   verbose               = .FALSE.
   matlab_out            = .FALSE.
   netcdf_out            = .TRUE.
   kind_of_interest      = 'QTY_U_WIND_COMPONENT'
   interp_test_lonrange  = 0.0, 360.0
   interp_test_dlon      = 1.0
   interp_test_latrange  = -89.0, 89.0
   interp_test_dlat      = 1.0
   interp_test_vertrange = 7000.0, 7000.0
   interp_test_dvert     = 1000.0
   interp_test_vertcoord = 'VERTISHEIGHT'
   hscale                = 100.0
   diff_threshold        = 2.0
   pointcount            = 100000
  /

&obs_seq_coverage_nml
   obs_sequences     = ''
   obs_sequence_list = 'obs_coverage_list.txt'
   obs_of_interest   = 'RADIOSONDE_TEMPERATURE', 'RADIOSONDE_U_WIND_COMPONENT', 'RADIOSONDE_V_WIND_COMPONENT'
   textfile_out      = 'obsdef_mask.txt'
   netcdf_out        = 'obsdef_mask.nc'
   calendar          = 'Gregorian'
   first_analysis    =  2008, 8, 1, 18, 0, 0
   last_analysis     =  2008, 8, 1, 18, 0, 0
   forecast_length_days          = 0
   forecast_length_seconds       = 21600
   verification_interval_seconds = 21600
   temporal_coverage_percent     = 50.0
   lonlim1    =    0.0
   lonlim2    =  360.0
   latlim1    =  -90.0
   latlim2    =   90.0
   verbose    = .true.
   debug      = .false.
  /

# selections_file is a list of obs_defs output
# from the obs_seq_coverage utility.
&obs_selection_nml
   filename_seq          = 'obs_seq.out'
   filename_seq_list     = ''
   filename_out          = 'obs_seq.processed'
   selections_file       = 'obsdef_mask.txt'
   selections_is_obs_seq = .false.
   print_only            = .false.
   calendar              = 'Gregorian'
  /

# one of the other, but not both
   obs_sequences = 'obs_seq.final.2008060100', 'obs_seq.final.2008060112'
   obs_sequence_list = 'obs_forecast_list.txt'
&obs_seq_verify_nml
   obs_sequences     = ''
   obs_sequence_list = 'obs_forecast_list.txt'
   input_template    = 'obsdef_mask.nc'
   netcdf_out        = 'forecast.nc'
   obtype_string     = 'RADIOSONDE_TEMPERATURE'
   print_every       = 20000
   verbose           = .true.
   debug             = .false.
  /

&mpas_dart_obs_preprocess_nml
   file_name_input          = 'obs_seq.old'
   file_name_output         = 'obs_seq.new'
   include_sig_data         = .true.
   superob_aircraft         = .false.
   superob_sat_winds        = .false.
   sfc_elevation_check      = .false.
   overwrite_ncep_sfc_qc    = .false.
   overwrite_ncep_satwnd_qc = .false.
   aircraft_pres_int        = 2500.0
   sat_wind_pres_int        = 2500.0
   sfc_elevation_tol        = 300.0
   obs_pressure_top         = 1.0
   obs_height_top           = 2.0e10
   max_num_obs              = 1000000
   sonde_extra              = 'obs_seq.rawin'
   metar_extra              = 'obs_seq.metar'
   acars_extra              = 'obs_seq.acars'
   land_sfc_extra           = 'obs_seq.land_sfc'
   marine_sfc_extra         = 'obs_seq.marine'
   sat_wind_extra           = 'obs_seq.satwnd'
   profiler_extra           = 'obs_seq.profiler'
   trop_cyclone_extra       = 'obs_seq.tc'
   gpsro_extra              = 'obs_seq.gpsro'
   tc_sonde_radii           = -1.0
   overwrite_obs_time       = .false.
   windowing_obs_time       = .true.
   windowing_int_hour       = 0.5
/
EOF

    #------------------------------------------------------
    # 4. Prepare Obs sequence for this analysis cycle
    #------------------------------------------------------

    if [[ ! -e OBSDIR/obs_seq.${timestr_cur} ]]; then
        if [[ $verb -eq 1 ]]; then echo "run_obsmerge $wrkdir $iseconds"; fi
        run_obsmerge $wrkdir $iseconds

        if [[ -e OBSDIR/obs_seq.${timestr_cur} ]]; then
            ln -sf OBSDIR/obs_seq.${timestr_cur} obs_seq.in
        else
            echo "ERROR: Observation file \"${wrkdir}/OBSDIR/obs_seq.${timestr_cur}\" not found"
            exit 3
        fi
    fi

    #------------------------------------------------------
    # 5. Run filter
    #------------------------------------------------------
    #cp $rundir/init/wofs_mpas_01.init.nc init.nc

    #
    # Create job script and submit it
    #
    jobscript="run_filter.${mach}"
    sedfile=$(mktemp -t filter_${eventtime}.sed_XXXX)
    cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/$npefilter/
s/JOBNAME/filter_${eventtime}/
s/CPUSPEC/${filter_cpu}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
EOF
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/${nnodes_filter}/;s/NCORES/${ncores_filter}/" >> $sedfile
    fi

    submit_a_jobscript $wrkdir "filter" $sedfile $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function run_update_states {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, update_in_place
    #         input_file_list
    #

    #
    # Build working directory
    #
    cd $wrkdir

    timestr_cur=$(date -d @$iseconds    +%Y%m%d%H%M)
    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/update_states.running || -f $wrkdir/done.update_states || -f $wrkdir/queue.update_states ]]; then
        return
    fi

    #------------------------------------------------------
    # Prepare update_mpas_states by copying/linking the background files
    #------------------------------------------------------
    state_input_file=$(awk '/input_state_file_list/{print $3}' input.nml)
    readarray -t input_file_list < ${state_input_file:1:${#state_input_file}-2}
    #update_input_file_list='filter_out.txt'

    if [[ $update_in_place == true ]]; then
        cpcmd="ln -sf"
    else
        #cpcmd="cp"
        cpcmd="rsync -a"
    fi

    update_output_file_list='update_out.txt'
    rm -rf ${update_output_file_list}
    for fn in ${input_file_list[@]}; do
        fnbase=$(basename $fn)
        if [[ ! -e $fnbase ]]; then
            echo "    ${cpcmd} $fn ."
            ${cpcmd} $fn .
        else
            echo "    $fnbase exists"
        fi
        echo "./$fnbase" >> ${update_output_file_list}
    done
    sed -i "/update_output_file_list/s/filter_in.txt/${update_output_file_list}/" input.nml

    #
    # Waiting for job conditions
    #
    conditions=(done.filter)

    if [[ $dorun == true ]]; then
        for cond in ${conditions[@]}; do
            echo "$$-${FUNCNAME[0]}: Checking: $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # Run obs_seq_to_netcdf
    #------------------------------------------------------

    if [[ $verb -eq 1 ]]; then
        srunout="1"
    else
        srunout="obs_seq_to_netcdf.log"
    fi

    echo "    Running ${exedir}/dart/obs_seq_to_netcdf"
    ${runcmd_str} ${exedir}/dart/obs_seq_to_netcdf >& $srunout
    mv obs_epoch_001.nc obs_seq.${timestr_cur}.nc

    #------------------------------------------------------
    # Run update_mpas_states for all ensemble members
    #------------------------------------------------------

    #
    # Create job script and submit it
    #
    jobscript="run_update_states.${mach}"
    sedfile=$(mktemp -t update_${eventtime}.sed_XXXX)
    cat <<EOF > $sedfile
s/PARTION/${partition}/
s/NOPART/1/
s/JOBNAME/update_${eventtime}/
s/CPUSPEC/${update_cpu}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runexe_str}/
EOF
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
    fi

    submit_a_jobscript $wrkdir "update_states" $sedfile $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function run_mpas {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, intvl_sec, npefcst
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir

    #
    # Waiting for job conditions
    #
    conditions=($rundir/lbc/done.lbc $wrkdir/done.update_states)

    if [[ $dorun == true ]]; then
        for cond in ${conditions[@]}; do
            echo "$$-${FUNCNAME[0]}: Checking: $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/fcst.running || -f $wrkdir/done.fcst || -f $wrkdir/queue.fcst ]]; then
        return
    fi

    #
    # Preparation for all members
    #
    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefcst} ]]; then
        cd $rundir/$domname
        if [[ $verb -eq 1 ]]; then
            echo "Generating ${domname}.graph.info.part.${npefcst} in $rundir/$domname using $exedir/gpmetis"
        fi
        $exedir/gpmetis -minconn -contig -niter=200 ${domname}.graph.info ${npefcst} > $rundir/$domname/gpmetis.out$npefcst
        if [[ $? -ne 0 ]]; then
            echo "$?: $exedir/gpmetis -minconn -contig -niter=200 ${domname}.graph.info ${npefcst}"
            exit $?
        fi
        cd $wrkdir
    fi

    intvl_min=$((intvl_sec/60))

    fcst_sec=$(( iseconds + intvl_sec ))
    currtime_str=$(date -d @$iseconds +%Y-%m-%d_%H:%M:%S)
    currtime_fil=${currtime_str//:/.}
    fcsttime_fil=$(date -d @$fcst_sec +%Y-%m-%d_%H.%M.%S)

    #
    # Preparation for each member
    #
    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        basen=$(( (iens-1)%6 ))
        if [[ $basen -lt 2 ]]; then     # map to 0,1,2
            idx=0
        elif [[ $basen -lt 4 ]]; then
            idx=1
        else
            idx=2
        fi
        pblscheme=${pbl_schemes[$idx]}
        sfcscheme=${sfclayer_schemes[$idx]}

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 1
        cd $memwrkdir

        #
        # init files
        #
        if [[ $icycle -eq 0 ]]; then
            #ln -sf ../${domname}_${memstr}.init.nc .
            initfile=$(sed -n "$iens{p;q}" ../filter_in.txt)
            ln -sf $initfile .
            do_restart="false"
            do_dacyle="false"
        else
            ln -sf ../${domname}_${memstr}.restart.${currtime_fil}.nc .
            do_restart="true"
            do_dacyle="true"
        fi

        #
        # lbc files
        #
        jens=$(( (iens-1)%nenslbc+1 ))
        mlbcstr=$(printf "%02d" $jens)
        isec_nlbc1=$(( iseconds/3600*3600 ))
        isec_nlbc2=${isec_nlbc1}
        isec_elbc=$(( iseconds+intvl_sec ))
        while [[ $isec_elbc -gt $isec_nlbc2 ]]; do
            let isec_nlbc2+=EXTINVL
        done
        # External GRIB file provided file times
        lbctime_str1=$(date -d @$isec_nlbc1 +%Y-%m-%d_%H.%M.%S)
        lbctime_str2=$(date -d @$isec_nlbc2 +%Y-%m-%d_%H.%M.%S)

        # MPAS expected boundary file times
        isec_elbc=$((iseconds+EXTINVL))
        mpastime_str1=$(date -d @$iseconds  +%Y-%m-%d_%H.%M.%S)
        mpastime_str2=$(date -d @$isec_elbc +%Y-%m-%d_%H.%M.%S)
        ln -sf $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc ${domname}_${memstr}.lbc.${mpastime_str1}.nc
        ln -sf $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str2}.nc ${domname}_${memstr}.lbc.${mpastime_str2}.nc

        ln -sf $rundir/$domname/$domname.graph.info.part.${npefcst} .


        streamlists=(stream_list.atmosphere.diagnostics stream_list.atmosphere.output stream_list.atmosphere.surface)
        for fn in ${streamlists[@]}; do
            cp -f ${FIXDIR}/$fn .
        done

        datafiles=(  CAM_ABS_DATA.DBL  CAM_AEROPT_DATA.DBL GENPARM.TBL       LANDUSE.TBL    \
                     OZONE_DAT.TBL     OZONE_LAT.TBL       OZONE_PLEV.TBL    RRTMG_LW_DATA  \
                     RRTMG_LW_DATA.DBL RRTMG_SW_DATA       RRTMG_SW_DATA.DBL SOILPARM.TBL   \
                     VEGPARM.TBL )

        for fn in ${datafiles[@]}; do
            ln -sf ${FIXDIR}/$fn .
        done

        if [[ "${mpscheme}" == "Thompson" ]]; then
            thompson_tables=( MP_THOMPSON_QRacrQG_DATA.DBL   MP_THOMPSON_QRacrQS_DATA.DBL   \
                              MP_THOMPSON_freezeH2O_DATA.DBL MP_THOMPSON_QIautQS_DATA.DBL )

            for fn in ${thompson_tables[@]}; do
                ln -sf ${FIXDIR}/$fn .
            done
        fi

        fcstmin_str=$(printf "%02d" $intvl_min)

        cat << EOF > namelist.atmosphere
&nhyd_model
    config_time_integration_order   = 2
    config_dt                       = 25
    config_start_time               = '${currtime_str}'
    config_run_duration             = '00:${fcstmin_str}:00'
    config_split_dynamics_transport = true
    config_number_of_sub_steps      = 4
    config_dynamics_split_steps     = 3
    config_h_mom_eddy_visc2         = 0.0
    config_h_mom_eddy_visc4         = 0.0
    config_v_mom_eddy_visc2         = 0.0
    config_h_theta_eddy_visc2       = 0.0
    config_h_theta_eddy_visc4       = 0.0
    config_v_theta_eddy_visc2       = 0.0
    config_horiz_mixing             = '2d_smagorinsky'
    config_len_disp                 = 3000.0
    config_visc4_2dsmag             = 0.05
    config_w_adv_order              = 3
    config_theta_adv_order          = 3
    config_scalar_adv_order         = 3
    config_u_vadv_order             = 3
    config_w_vadv_order             = 3
    config_theta_vadv_order         = 3
    config_scalar_vadv_order        = 3
    config_scalar_advection         = true
    config_positive_definite        = false
    config_monotonic                = true
    config_coef_3rd_order           = 0.25
    config_epssm                    = 0.1
    config_smdiv                    = 0.1
/
&damping
    config_mpas_cam_coef            = 2.0
    config_rayleigh_damp_u          = true
    config_zd                       = 16000.0
    config_xnutr                    = 0.2
    config_nlevels_cam_damp         = 8
/
&limited_area
    config_apply_lbcs                = true
/
&io
    config_pio_num_iotasks           = NNNODE
    config_pio_stride                = NNCORE
/
&decomposition
    config_block_decomp_file_prefix  = '${domname}.graph.info.part.'
/
&restart
    config_do_restart                = ${do_restart}
    config_do_DAcycling              = ${do_dacyle}
/
&printout
    config_print_global_minmax_sca   = true
    config_print_global_minmax_vel   = true
    config_print_detailed_minmax_vel = false
/
&IAU
    config_IAU_option                = 'off'
    config_IAU_window_length_s       = 21600.
/
&physics
    config_sst_update                = false
    config_sstdiurn_update           = false
    config_deepsoiltemp_update       = false
    config_radtlw_interval           = '00:30:00'
    config_radtsw_interval           = '00:30:00'
    config_bucket_update             = 'none'
    config_lsm_scheme                = '${MPASLSM}'
    num_soil_layers                  = ${MPASNFLS}
    config_physics_suite             = 'convection_permitting'
    config_frac_seaice               = false
    config_pbl_scheme                = '${pblscheme}'
    config_sfclayer_scheme           = '${sfcscheme}'
EOF
    #config_microp_re                 = true

        if [[ ${mpscheme} == "mp_nssl2m" ]]; then

            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
/
&nssl_mp_params
    ehw0                             = 0.9
    ehlw0                            = 0.9
    icefallfac                       = 1.5
    snowfallfac                      = 1.25
    iusewetsnow                      = 0
EOF

        fi

        cat << EOF >> namelist.atmosphere
/
&soundings
    config_sounding_interval         = 'none'
/
EOF

        cat << EOF > streams.atmosphere
<streams>
<immutable_stream name="input"
                  type="input"
                  filename_template="${domname}_${memstr}.init.nc"
                  input_interval="initial_only" />

<immutable_stream name="restart"
                  type="input;output"
                  filename_template="${domname}_${memstr}.restart.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  input_interval="initial_only"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" />

<stream name="output"
                  type="output"
                  filename_template="${domname}_${memstr}.history.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.output"/>
</stream>

<stream name="diagnostics"
                  type="output"
                  filename_template="${domname}_${memstr}.diag.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.diagnostics"/>
</stream>

<stream name="surface"
                  type="input"
                  filename_template="${domname}_${memstr}.sfc_update.nc"
                  filename_interval="none"
                  input_interval="none" >

    <file name="stream_list.atmosphere.surface"/>
</stream>

<immutable_stream name="iau"
                  type="input"
                  filename_template="${domname}_${memstr}.AmB.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="none"
                  packages="iau"
                  input_interval="initial_only" />

<immutable_stream name="lbc_in"
                  type="input"
                  filename_template="${domname}_${memstr}.lbc.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="input_interval"
                  packages="limited_area"
                  input_interval="${EXTINVL_STR}" />

</streams>
EOF
        jobarrays+=($iens)
    done

    #
    # Create job script and submit it
    #
    cd $wrkdir

    #mpas_jobscript="run_mpas.${mach}"
    jobarraystr="--array=$(join_by_comma ${jobarrays[@]})"

    sedfile=$(mktemp -t mpas_${eventtime}.sed_XXXX)
    cat <<EOF > $sedfile
s/PARTION/${partition}/
s/NOPART/$npefcst/
s/JOBNAME/mpas_${eventtime}/
s/CPUSPEC/${claim_cpu}/g
s#MODULE#${modulename}#g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
s/SAVETAG/${domname}_??.restart.${fcsttime_fil}.nc/
EOF
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/${nnodes_filter}/;s/NCORES/${ncores_filter}/" >> $sedfile
    fi

    submit_a_jobscript $wrkdir "fcst" $sedfile $TEMPDIR/run_mpas_array.${mach} $mpas_jobscript ${jobarraystr}
}

########################################################################

function da_cycle_driver() {
    #
    #  based on driver_mpas_dart.csh in the DART package
    #
    #  THIS IS A TOP-LEVEL DRIVER SCRIPT FOR CYCLING RUNS.
    #
    #  Required files to run this driver:
    #  1. executables:
    #       filter
    #       update_mpas_states
    #       atmosphere_model
    #
    #  Input files to run this script:
    #  A. input_state_file_list  - a list of input ensemble netcdf files for DART/filter
    #  B. output_state_file_list - a list of output ensemble netcdf files from DART/filter
    #  C. RUN_DIR/member#/${mpas_filename}    - the input file listed in input_state_file_list for each member
    #  D. OBS_DIR/${obs_seq_in}.${YYYYMMDDHH} - obs sequence files for each analysis cycle (YYYYMMDDHH)
    #     for the entire period.
    #
    ##############################################################################################
    # USER SPECIFIED PARAMETERS
    ##############################################################################################
    # $1    $2    $3
    # init start  end
    local init_sec=$1
    local start_sec=$2
    local end_sec=$3

    #
    # Build working directory
    #
    wrkdir=$rundir/dacycles
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg date_end intvl_min n_cycles
    date_beg=$(date -d @$start_sec +%Y%m%d%H%M)
    date_end=$(date -d @$end_sec +%Y%m%d%H%M)
    intvl_min=$((intvl_sec/60))
    n_cycles=$(( (end_sec-start_sec)/intvl_sec ))

    echo "Total of ${n_cycles} cycles from $date_beg to $date_end will be run every $intvl_min minutes."
    echo ""

    local icyc=$(( (start_sec-init_sec)/intvl_sec ))
    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -d @$isec +%Y%m%d%H%M)
        eventtime=$(date    -d @$isec +%H%M)

        dawrkdir=${wrkdir}/${eventtime}
        mkwrkdir $dawrkdir 0    # keep original directory
        cd $dawrkdir

        echo "- Cycle $icyc at ${timestr_curr}"

        if [[ $icyc -gt 0 && $dorun == true ]]; then

            timesec_pre=$((isec-intvl_sec))
            event_pre=$(date -d @$timesec_pre  +%H%M)
            wrkdir_pre=${wrkdir}/${event_pre}
            #------------------------------------------------------
            # 0. Check forecast status of the early cycle as needed
            #------------------------------------------------------
            if [[ ! -e ${wrkdir_pre}/done.fcst ]]; then
                #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                check_and_resubmit "fcst" $wrkdir_pre $ENS_SIZE run_mpas.${mach} 0
            fi
        fi

        if [[ " ${jobs[*]} " =~ " filter " ]]; then
            #------------------------------------------------------
            # 1. Run filter
            #------------------------------------------------------
            if [[ $verb -eq 1 ]]; then echo ""; echo "    Run filter at $eventtime"; fi
            run_filter $dawrkdir $icyc $isec
        fi

        if [[ " ${jobs[*]} " =~ " update_states " ]]; then
            #------------------------------------------------------
            # 2. Run update_states for all ensemble members
            #------------------------------------------------------
            if [[ $icyc -eq 0 ]]; then
                touch $dawrkdir/done.update_states
            else
                if [[ $verb -eq 1 ]]; then echo ""; echo "    Run update_mpas_state at $eventtime"; fi
                run_update_states $dawrkdir $isec
            fi
        fi

        if [[ " ${jobs[*]} " =~ " mpas " ]]; then
            #------------------------------------------------------
            # 3. Advance model for each member
            #------------------------------------------------------
            # Run forecast for ensemble members until the next analysis time
            if [[ $verb -eq 1 ]]; then echo ""; echo "    Run advance model at $eventtime"; fi

            mpas_jobscript="run_mpas.${mach}"
            run_mpas $dawrkdir $icyc $isec

            if [[ $dorun == true ]]; then
                if [[ ! -e done.fcst ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "fcst" $dawrkdir $ENS_SIZE $mpas_jobscript 2
                fi
            fi
        fi

        let icyc+=1
    done
}

########################################################################

function run_clean {
    # $1    $2    $3
    # start  end
    local start_sec=$1
    local end_sec=$2

    wrkdir=$rundir/dacycles

    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -d @$isec +%Y%m%d%H%M)
        eventtime=$(date    -d @$isec +%H%M)

        dawrkdir=$wrkdir/$eventtime
        if [[ -d $dawrkdir ]]; then
            cd $dawrkdir

            if [[ $verb -eq 1 ]]; then echo "    Cleaning working directory $dawrkdir"; fi

            for dirname in mpas filter update_states; do

                cd $dawrkdir

                case $dirname in
                mpas )
                    rm -f error.fcst_* log.????.abort
                    #rm -f log.atmosphere.????.out log.atmosphere.????.err fcst_*_*.log
                    #echo "clean mpas in $dawrkdir"
                    clean_mem_runfiles "fcst" $dawrkdir $ENS_SIZE
                    ;;
                filter )
                    if [[ -e done.filter ]]; then
                        rm -f filter_*.log error.filter dart_log.nml dart_log.out
                        find OBSDIR -type f -or -type l -not -name "obs_seq.${timestr_curr}" -print0 | xargs -0  -I {} rm -f {}
                    fi
                    ;;
                update_states )
                    if [[ -e done.update_states ]]; then
                        rm -f update_states_*.log error.update_states
                    fi
                    ;;
                esac
            done
        fi
    done
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
# Default Settings
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#@ MAIN

WORKDIR="${rootdir}/run_dirs"
TEMPDIR="${rootdir}/templates"
FIXDIR="${rootdir}/fix_files"

eventdate="$eventdateDF"
eventtime="1500"
initdatetime=""
enddatetime=""

ENS_SIZE=36
nenslbc=18
intvl_sec=900

domname="wofs_mpas"
mpscheme="mp_nssl2m"
MPASLSM='ruc'
MPASNFLS=9
                    #suite,sf_monin_obukhov,sf_mynn,off (default: suite)
sfclayer_schemes=('sf_monin_obukhov_rev' 'sf_monin_obukhov' 'sf_mynn')
                    # (suite,bl_ysu,bl_mynn,off )    # (default: suite)
pbl_schemes=('bl_ysu' 'bl_myj' 'bl_mynn')    # (default: suite)

EXTINVL=3600
EXTINVL_STR=$(printf "%02d:00:00" $((EXTINVL/3600)) )

OUTINVL=1
OUTINVL_STR="${OUTINVL}:00:00"

RSTINVL_STR=$(printf "00:%02d:00" $((intvl_sec/60)) )

OUTIOTYPE="netcdf4"
ICSIOTYPE="pnetcdf,cdf5"

ADAPTIVE_INF=true
update_in_place=false           # update MPAS states in-place or making a copy of the restart files

verb=0
overwrite=0
jobwait=0
runcmd="sbatch"
dorun=true

machine="Jet"
if [[ "$(hostname)" == ln? ]]; then
    machine="Vecna"
elif [[ "$(hostname)" == cheyenne* ]]; then
    machine="Cheyenne"
fi

jobs=(filter update_states mpas clean)

source $scpdir/Common_Utilfuncs.sh

#-----------------------------------------------------------------------
#
# Handle command line arguments (override default settings)
#
#-----------------------------------------------------------------------
#% ARGS

while [[ $# > 0 ]]; do
    key="$1"

    case $key in
        -h)
            usage 0
            ;;
        -n)
            runcmd="echo"
            dorun=false
            ;;
        -v)
            verb=1
            ;;
        -k)
            if [[ $2 =~ [012] ]]; then
                overwrite=$2
                shift
            else
                echo "ERROR: option for '-k' can only be [0-2], but got \"$2\"."
                usage 1
            fi
            ;;
        -w)
            jobwait=1
            ;;
        -t)
            if [[ -d $2 ]]; then
                TEMPDIR=$2
            else
                echo "ERROR: Template directory \"$2\" does not exist."
                usage 1
            fi
            shift
            ;;
        -m)
            if [[ ${2^^} == "JET" ]]; then
                machine=Jet
            elif [[ ${2^^} == "VECNA" ]]; then
                machine=Vecna
            elif [[ ${2^^} == "CHEYENNE" ]]; then
                machine=Cheyenne
            else
                echo "ERROR: Unsupported machine name, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -a)
            hpcaccount=$2
            shift
            ;;
        -d)
            domname=$2
            shift
            ;;
        -i)
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                initdatetime=$2
            else
                echo "ERROR: Initial time should be YYYYmmddHHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -e )
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                enddatetime=$2
            elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                endhrmin=$2
                endhour=${endhrmin:0:2}
                if [[ 10#$endhour -lt 12 ]]; then
                    enddatetime=$(date -d "$eventdate $endhrmin 1 day" +%Y%m%d%H%M)
                else
                    enddatetime=$(date -d "$eventdate $endhrmin" +%Y%m%d%H%M)
                fi
            else
                echo "ERROR: End time should be in YYYYmmddHHMM or HHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -p)
            if [[ ${2^^} == "NSSL" ]]; then
                mpscheme="mp_nssl2m"
            elif [[ ${2^^} == "THOMPSON" ]]; then
                mpscheme="Thompson"
            else
                echo "ERROR: Unsupported MP scheme name, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -*)
            echo "Unknown option: $key"
            usage 2
            ;;
        filter* | mpas* | update_states* | clean* )
            jobs=(${key//,/ })
            ;;
        *)
            if [[ $key =~ ^[0-9]{12}$ ]]; then
                eventtime=${key:8:4}
                eventhour=${key:8:2}
                if [[ 10#$eventhour -lt 12 ]]; then
                    eventdate=$(date -d "${key:0:8} 1 day ago" +%Y%m%d)
                else
                    eventdate=${key:0:8}
                fi
            elif [[ $key =~ ^[0-9]{4}$ ]]; then
                eventtime=${key}
            elif [[ -d $key ]]; then
                WORKDIR=$key
                lastdir=$(basename $WORKDIR)
                if [[ $lastdir =~ ^[0-9]{8}$ ]]; then
                    WORKDIR=$(dirname ${WORKDIR})
                    eventdate=${lastdir}
                elif [[ $lastdir =~ ^[0-9]{12}$ ]]; then
                    WORKDIR=$(upnlevels ${WORKDIR} 3)
                    eventdate=${lastdir:0:8}
                    eventtime=${lastdir:8:4}
                    eventhour=${lastdir:8:2}
                    if [[ $eventhour -lt 12 ]]; then
                        eventdate=$(date -d "$eventdate 1 day ago" +%Y%m%d)
                    fi
                fi
                #echo $WORKDIR,$eventdate,$eventtime
            else
                echo ""
                echo "ERROR: unknown argument, get [$key]."
                usage 3
            fi
            ;;
    esac
    shift # past argument or value
done

#-----------------------------------------------------------------------
#
# Handle machine specific configuraitons
#
#-----------------------------------------------------------------------
#% PLATFORM

mach="slurm"

if [[ $machine == "Jet" ]]; then
    ncores_fcst=6;  ncores_filter=6
    partition="ujet,tjet,xjet,vjet,kjet";        claim_cpu="--cpus-per-task=2"
    partition_filter="ujet,tjet,xjet,vjet,kjet"; filter_cpu="--cpus-per-task=2"
                                                 update_cpu="--cpus-per-task=4 --mem-per-cpu=8G"

    npefcst=48       #; nnodes_fcst=$(( npefcst/ncores_fcst ))
    npefilter=1536   #; nnodes_filter=$(( npefilter/ncores_filter ))

    mach="slurm"
    job_exclusive_str="#SBATCH --exclusive"
    job_account_str="#SBATCH -A ${hpcaccount-wof}"
    job_runmpexe_str="srun"
    job_runexe_str="srun"
    runcmd_str="srun -A ${hpcaccount-wof} -p ${partition} -n 1"

    OBS_DIR="/lfs4/NAGAPE/hpc-wof1/ywang/MPAS/OBSGEN"

    modulename="build_jet_intel18_1.11_smiol"

    source /etc/profile.d/modules.sh
    module purge
    module use ${rootdir}/modules
    module load $modulename

elif [[ $machine == "Cheyenne" ]]; then

    if [[ $dorun == true ]]; then
        runcmd="qsub"
    fi
    ncores_filter=32; ncores_fcst=32
    partition="regular"        ; claim_cpu="ncpus=${ncores_fcst}"
    partition_filter="regular" ; filter_cpu="ncpus=${ncores_post}"

    npefilter=48   ; nnodes_filter=$((  npefilter/ncores_filter   ))
    npefcst=48     ; nnodes_fcst=$(( npefcst/ncores_fcst ))

    mach="pbs"
    job_exclusive_str=""
    job_account_str="#PBS -A ${hpcaccount-NMMM0013}"
    job_runmpexe_str="mpiexec_mpt"
    job_runexe_str="mpiexec_mpt"

    OBS_DIR="/scratch/ywang/MPAS/mpas_scripts/run_dirs/OBSGEN"

    modulename="defaults"
else    # Vecna at NSSL

    account="${hpcaccount-batch}"
    ncores_filter=96; ncores_fcst=96

    npefilter=768    #; nnodes_filter=$(( npefilter/ncores_filter  ))
    npefcst=96       #; nnodes_fcst=$(( npefcst/ncores_fcst ))

    partition="batch"           ; claim_cpu="--ntasks-per-node=96  --mem-per-cpu=4G";
    partition_filter="batch"    ; filter_cpu="--ntasks-per-node=96 --mem-per-cpu=4G"
                                  update_cpu="--ntasks-per-node=24 --mem-per-cpu=8G"

    mach="slurm"
    job_exclusive_str="#SBATCH --exclude=cn11"
    job_account_str=""
    job_runmpexe_str="srun --mpi=pmi2"
    job_runexe_str="srun"
    runcmd_str="srun"

    OBS_DIR="/scratch/ywang/MPAS/mpas_scripts/run_dirs/OBSGEN"

    modulename="env.mpas_smiol"
    source /usr/share/Modules/init/bash
    source ${rootdir}/modules/${modulename}
fi

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Perform DA cycles
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#% ENTRY

echo "---- Jobs ($$) started $(date +%m-%d_%H:%M:%S) on host $(hostname) ----"
echo "     Event date : $eventdate ${eventtime}:00"
echo "     Root    dir: $rootdir"
echo "     Working dir: $WORKDIR"
echo "     Domain name: $domname;  MP scheme: ${mpscheme}"
echo " "

eventhour=${eventtime:0:2}
if [[ $eventhour -lt 12 ]]; then
    startday="1 day"
else
    startday=""
fi

if [[ "$initdatetime" == "" ]]; then
    initdatetime="${eventdate}1500"
fi

if [[ "$enddatetime" == "" ]]; then
    enddatetime=$(date -d "$eventdate 03:00 1 day" +%Y%m%d%H%M)
fi

inittime_sec=$(date -d "${initdatetime:0:8} ${initdatetime:8:4}" +%s)
starttime_sec=$(date -d "$eventdate ${eventtime} $startday"      +%s)
stoptime_sec=$(date -d "${enddatetime:0:8}  ${enddatetime:8:4}"  +%s)

rundir="$WORKDIR/${eventdate}"
if [[ ! -d $rundir ]]; then
    mkdir -p $rundir
fi

exedir="$rootdir/exec"

# $1    $2    $3
# init start  end
if [[ " ${jobs[*]} " =~ " filter " || " ${jobs[*]} " =~ " mpas " || " ${jobs[*]} " =~ " update_states " ]]; then
    da_cycle_driver $inittime_sec $starttime_sec $stoptime_sec
elif [[ " ${jobs[*]} " =~ " clean " ]]; then
    run_clean $starttime_sec $stoptime_sec
fi

echo " "
echo "==== Jobs done $(date +%m-%d_%H:%M:%S) ===="
echo " "

exit 0
