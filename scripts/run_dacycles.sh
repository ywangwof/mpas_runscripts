#!/bin/bash
# shellcheck disable=SC2317,SC1090,SC1091,SC2086

#rootdir="/scratch/ywang/MPAS/mpas_runscripts"
scpdir="$( cd "$( dirname "$0" )" && pwd )"              # dir of script
rootdir=$(realpath "$(dirname "${scpdir}")")

eventdateDF=$(date -u +%Y%m%d)

#-----------------------------------------------------------------------
#
# This is the 4th step of th WOFS-MPAS workflow. It run program filter,
# update_mpas_states, and atmosphere_model to perform the DA cycles and the forward forecasting.
#
# Required files from ROOTDIR
#
# 0. module files in modules
#     build_jet_Rocky8_intel_smiol
#
# 1. exec                                   # The executables
#     atmosphere_model
#     filter
#     update_mpas_states
#
# 2. templates                              # templates used in this scripts
#    README
#
#    2.1 SLURM scripts on Jet
#        run_filter.slurm                    or run_filter.pbs
#        run_mpas_array.slurm                or run_mpas_array.pbs
#        run_update_states.slurm             or run_update_states.pbs
#
# 3. fix_files                              # runtime fix files for MPAS model and accompany programs
#
#    3.1 tables for Thompson cloud microphysics scheme
#        *MP_THOMPSON_QIautQS_DATA.DBL
#        *MP_THOMPSON_QRacrQG_DATA.DBL
#        *MP_THOMPSON_QRacrQS_DATA.DBL
#        *MP_THOMPSON_freezeH2O_DATA.DBL
#
#        Can be generated by submitting job script templates/build_tables.slurm
#
#    3.2 MPASS run-time static files
#        stream_list.atmosphere.diagnostics
#        stream_list.atmosphere.output
#        stream_list.atmosphere.surface
#
#        *CAM_ABS_DATA.DBL
#        *CAM_AEROPT_DATA.DBL
#        *GENPARM.TBL
#        *LANDUSE.TBL
#        *OZONE_DAT.TBL
#        *OZONE_LAT.TBL
#        *OZONE_PLEV.TBL
#        *RRTMG_LW_DATA
#        *RRTMG_LW_DATA.DBL
#        *RRTMG_SW_DATA
#        *RRTMG_SW_DATA.DBL SOILPARM.TBL
#        *VEGPARM.TBL
#
#    NOTE:
#         * not in the git repository
#
# INSTRUCTIONS:
#
#  Use existing domain (wofs_mpas)
#     1. Copy these directories to rootdir (or clone using git)
#        modules
#        exec
#        scripts
#        templates
#        fix_files (link needed files use script lnwrkfiles.sh, see README in that directory)
#
#     2. make a run directory under rootdir
#        run_dirs
#
#     3. Copy existing domain directories $rootdir/run_dirs/wofs_maps & geo_mpas to
#        your run_dirs
#
#     4. run_dacycles.sh [YYYYmmddHH] [run_dirs] [jobnames]
#
#-----------------------------------------------------------------------

function usage {
    echo " "
    echo "    USAGE: $0 [options] DATETIME [WORKDIR] [JOBS]"
    echo " "
    echo "    PURPOSE: Run MPAS-WOFS DA cycles."
    echo " "
    echo "    DATETIME - Case date and time in YYYYmmdd/YYYYmmddHHMM, Default eventdate is ${eventdateDF}."
    echo "               YYYYmmdd:     run all cycles from $eventtime to 0300. Or use options \"-s\" & \"-e\" to specify cycles."
    echo "               YYYYmmddHHMM: run this DA cycle only."
    echo "    WORKDIR  - Run Directory"
    echo "    JOBS     - One or more jobs from [filter,update_states,update_bc,mpas,clean,obs_diag,obs_final2nc]"
    echo "               Default all jobs in [filter,update_states,update_bc,mpas] for a DA cyle"
    echo " "
    echo "    OPTIONS:"
    echo "              -h                  Display this message"
    echo "              -n                  Show command to be run and generate job scripts only"
    echo "              -v                  Verbose mode"
    echo "              -k  [0,1,2]         Keep working directory if exist, 0- keep as is; 1- overwrite; 2- make a backup as xxxx.bak?"
    echo "                                  Default is 0 for ungrib, mpassit, upp and 1 for others"
    echo "              -t  DIR             Template directory for runtime files"
    echo "              -m  Machine         Machine name to run on, [Jet, Cheyenne, Vecna]."
    echo "              -d  wofs_mpas       Domain name to be used"
    echo "              -i  YYYYmmddHHMM    Initial time, default: same as start time from the command line argument"
    echo "              -s  YYYYmmddHHMM    Start date & time of the DA cycles"
    echo "                  HHMM            Start time of the DA cycles"
    echo "              -e  YYYYmmddHHMM    End date & time of the DA cycles"
    echo "                  HHMM            End time of the DA cycles"
    echo "              -p  nssl            MP scheme, [nssl, thompson], default: nssl"
    echo "              -r                  Realtime run, will wait for observations, default: retrospective run"
    echo " "
    echo "   DEFAULTS:"
    echo "              eventdt = $eventdateDF"
    echo "              rootdir = $rootdir"
    echo "              WORKDIR = $rootdir/run_dirs"
    echo "              TEMPDIR = $rootdir/templates"
    echo "              FIXDIR  = $rootdir/fix_files"
    echo " "
    echo "                                     -- By Y. Wang (2023.05.31)"
    echo " "
    exit $1
}

########################################################################

function run_obsmerge {
    # $1        $2          $3
    # wrkdir    iseconds    seqfilename
    local wrkdir=$1               # DA directory for this cycle
    local iseconds=$2

    if [[ ! -d $wrkdir ]]; then
        echo "run_obsmerge: Working directory $wrkdir not exist"
        exit 1
    fi

    anlys_date=$(date -u -d @$iseconds  +%Y%m%d)
    anlys_time=$(date -u -d @$iseconds  +%H%M)

    srunout="output.srun"

    read -r -a g_dates < <(convertS2days "${iseconds}")
    g_date=${g_dates[0]}
    g_sec=${g_dates[1]}
    #echo $g_date, $g_sec

    mkwrkdir $wrkdir/OBSDIR 1     # 0: Keep existing directory as is
                                  # 1: Remove existing same name directory
    cd $wrkdir/OBSDIR || exit $?

    #-------------------------------------------------------------------
    #
    # Run MPAS_DART_OBS_PREPROCESS for each observation type
    # and get an array "obsflists"
    #
    #-------------------------------------------------------------------

    rm -fr obsflist.bufr obsflist.meso obsflist.sat obsflist.mrms obsflist.radvr obsflist obs_seq.*

    obspreprocess=${exedir}/dart/mpas_dart_obs_preprocess

    #ln -sf ${wrkdir}/input.nml ./input.nml
    cp ${wrkdir}/input.nml input.nml
    #ln -sf ${rundir}/dacycles/${inittime_str}/${domname}_01.restart.${frsttime_str}.nc init.nc

    echo "$$-${FUNCNAME[0]}: OBS Preprocessing for analysis time: ${anlys_time}, days: ${g_date}, seconds: ${g_sec}"

    obsflists=()
    k=1

    #=================================================
    # PREPROCESS NCEP PrepBufr DATA
    #=================================================
    #1. PrepBufr

    bufr_file="${OBS_DIR}/Bufr/obs_seq_bufr.${anlys_date}${anlys_time:0:2}"
    if [[ $rt_run == true && ${use_BUFR} == true && "${anlys_time:2:2}" == "00" ]]; then
        if [[ ! -e ${bufr_file} ]]; then
            echo "    Waiting for ${bufr_file} ...."
        fi
        while [[ ! -e ${bufr_file} ]]; do
            sleep 10
        done
    fi

    if [[ -e ${bufr_file} ]]; then
        echo "    $((k++)): Using PrepBufr observations in ${bufr_file}"
        #echo "${bufr_file}" > obsflist.bufr
        #obsflists+=(obsflist.bufr)

        cp ${bufr_file} ./obs_seq.old

        if [[ $verb -eq 1 ]]; then
            echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi

        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                                          >& ${srunout}_BUFR

        # shellcheck disable=SC2154
        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_BUFR 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.bufr

            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.bufr > obsflist.bufr

            obsflists+=(obsflist.bufr)
        else
            echo "Error with command ${obspreprocess} for PREPBUFR data"
        fi
    else
        if [[ "${anlys_time:2:2}" == "00" ]]; then
            echo "    PrepBufr data not found: ${bufr_file}"
        fi
    fi

    #=================================================
    # PREPROCESS OK MESONET DATA
    #=================================================
    #2. MESONET

    meso_file="${OBS_DIR}/Mesonet/obs_seq_okmeso.${anlys_date}${anlys_time}"
    if [[ $rt_run == true && ${use_MESO} == true ]]; then
        if [[ ! -e ${meso_file} ]]; then
            echo "    Waiting for ${meso_file} ...."
        fi
        while [[ ! -e ${meso_file} ]]; do
            sleep 10
        done
    fi

    if [[ -e ${meso_file} ]]; then
        echo "    $((k++)): Using Mesonet observations in ${meso_file}"
        #echo "${meso_file}" > obsflist.meso
        #obsflists+=(obsflist.meso)

        cp ${meso_file} ./obs_seq.old

        if [[ $verb -eq 1 ]]; then
            echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi
        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                                          >& ${srunout}_MESO

        # shellcheck disable=SC2154
        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_MESO 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.meso

            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.meso > obsflist.meso

            obsflists+=(obsflist.meso)
        else
            echo "Error with command ${obspreprocess} for MESONET data"
        fi
    else
        if [[ ${use_MESO} == true ]]; then
            echo "    Mesonet not found: ${meso_file}"
        fi
    fi

    #=================================================
    # PREPROCESS GOES SATELLITE CWP DATA
    #=================================================
    #3. CWP

    CWP_DIR=${OBS_DIR}/CWP

    cwp_file="${CWP_DIR}/obs_seq_cwp.G16_V04.${anlys_date}${anlys_time}"

    if [[ $rt_run == true && ${use_CWP} == true ]]; then
        if [[ ! -e ${cwp_file} ]]; then
            echo "    Waiting for ${cwp_file} ...."
        fi
        while [[ ! -e ${cwp_file} ]]; do
            sleep 10
        done
    fi

    if [[ -e ${cwp_file} ]]; then
        echo "    $((k++)): Using CWP data in ${cwp_file}"

        cp ${cwp_file} ./obs_seq.old

        if [[ $verb -eq 1 ]]; then
            echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi
        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                               >& ${srunout}_CWP
        # shellcheck disable=SC2154
        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_CWP 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.cwp

            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.cwp > obsflist.cwp

            obsflists+=(obsflist.cwp)
        else
            echo "Error with command ${obspreprocess} for CWP data"
        fi
    else
        if [[ ${use_CWP} == true && "${anlys_time:3:1}" == "0" ]]; then
            echo "    CWP not found: ${cwp_file}"
        fi
    fi

    #=================================================
    # PREPROCESS GOES SATELLITE Radiance DATA
    #=================================================
    #4. Radiance

    channels=("8.4" "10.3")

    RAD_DIR=${OBS_DIR}/Radiance

    rad_files="obs_seq_abi.G16_C*.${anlys_date}${anlys_time}"

    if [[ $rt_run == true && ${use_RAD} == true ]]; then

        numrad=$(find ${RAD_DIR}/ -name "${rad_files}" | wc -l)
        if [[ $numrad -ne ${#channels[@]} ]]; then
            echo "    Waiting for ${RAD_DIR}/${rad_files} ...."
        fi
        while [[ $numrad -ne ${#channels[@]} ]]; do
            sleep 10
            numrad=$(find ${RAD_DIR}/ -name "${rad_files}" | wc -l)
        done
    fi

    i=0
    for abifile in "${RAD_DIR}"/obs_seq_abi.G16_C*."${anlys_date}${anlys_time}"; do
        if [[ -e ${abifile} ]]; then
            i=$((i+1))

            if [[ ! -e ${srunout}_RAD ]]; then
                { echo "Run command ${obspreprocess} as:";
                  echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
                  echo "";
                }                                            >& ${srunout}_RAD
            fi

            if [[ ! -e rttov_sensor_db.csv ]]; then
                cp ${FIXDIR}/rttov_sensor_db.csv .
            fi

            a=$(basename $abifile)
            chan=${a##obs_seq_abi.G16_C}
            chan=${chan%%."${anlys_date}${anlys_time}"}
            if [[ " ${channels[*]} " == *" $chan "* ]]; then
                echo "    $k-$i: Using Radiance data in ${abifile}"
                cp ${abifile} ./obs_seq.old

                if [[ $verb -eq 1 ]]; then
                    echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
                fi
                ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_RAD 2>&1

                # shellcheck disable=SC2181
                if [[ $? -eq 0 ]]; then
                    mv ./obs_seq.new ./obs_seq.abiC$chan
                    rm ./obs_seq.old
                    echo $wrkdir/OBSDIR/obs_seq.abiC$chan >> obsflist.abi
                else
                    echo "Error with command ${obspreprocess} for Radiance data"
                    exit 1
                fi
            else
                echo " Radiance file ${abifile} is on Channel $chan, ignoring currently."
            fi
        else
            echo "    Radiance not found: ${abifile}"
        fi
    done

    if [[ $i -ge 1 ]]; then k=$((k+1)); fi

    if [[ -e obsflist.abi ]]; then
        obsflists+=(obsflist.abi)
    fi

    #=================================================
    # PREPROCESS RADAR DATA
    #=================================================

    ########################
    ### MRMS             ###
    ########################
    #5. REF

    DBZ_DIR=${OBS_DIR}/REF

    dbz_file="${DBZ_DIR}/${eventdate}/obs_seq_RF_${anlys_date}_${anlys_time}.out"

    if [[ $rt_run == true ]]; then
        if [[ ! -e ${dbz_file} ]]; then
            echo "    Waiting for ${dbz_file} ...."
        fi
        while [[ ! -e ${dbz_file} ]]; do
            sleep 10
        done
        wait_for_file_age ${dbz_file} 30
    fi

    if [[ -e ${dbz_file} ]]; then

        echo "    $((k++)): Using REF data in ${dbz_file}"

        cp ${dbz_file} ./obs_seq.old

        if [[ $verb -eq 1 ]]; then
            echo "    Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi
        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                                      >& ${srunout}_REF

        ${runcmd_str} echo "$g_date $g_sec" | ${obspreprocess} >> ${srunout}_REF 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.mrms

            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.mrms > obsflist.mrms

            obsflists+=(obsflist.mrms)
        else
            echo "Error with command ${obspreprocess} for REF data"
        fi
    else
        echo "    REF data not found: ${dbz_file}"
    fi
    echo "    "

    ########################
    ### Radial Velocity  ###
    ########################
    #6. VEL

    wait_seconds=$((iseconds+600))

    #
    # Source environment for radars
    #

    if [[ -e $rundir/$domname/radars.${eventdate}.sh ]]; then
        source $rundir/$domname/radars.${eventdate}.sh || exit $?
    else
        echo "ERROR: File $rundir/$domname/radars.${eventdate}.sh not exist"
        exit 0
    fi

    VR_DIR=${OBS_DIR}/VEL

    if [[ $rt_run == true ]]; then

        numrad=$(find ${VR_DIR}/${eventdate} -name "obs_seq_????_VR_${anlys_date}_${anlys_time}.out" | wc -l)

        if [[ $numrad -lt ${num_rad} ]]; then
            echo "    Waiting for ${VR_DIR}/${eventdate}/obs_seq_????_VR_${anlys_date}_${anlys_time}.out ...."
        fi

        currsecs=$(date -u +%s)
        while [[ $numrad -lt ${num_rad} && $currsecs -lt ${wait_seconds} ]]; do
            # do not wait more than 10 minute outside the current assimilation cycle
            sleep 10
            numrad=$(find ${VR_DIR}/${eventdate} -name "obs_seq_????_VR_${anlys_date}_${anlys_time}.out" | wc -l)
            currsecs=$(date -u +%s)
        done
    fi

    j=0; n=1
    # shellcheck disable=SC2154
    while [[ ${j} -lt ${num_rad} ]]; do

        vrj_file=${VR_DIR}/${eventdate}/obs_seq_${rad_name[$j]}_VR_${anlys_date}_${anlys_time}.out

        if [[ $verb -eq 1 ]]; then
            echo "         Checking VEL data in ${vrj_file}"
        fi

        if [[ -e ${vrj_file} ]]; then

            wait_for_file_age ${vrj_file} 30

            if [[ ${run_trimvr} == true ]]; then
                trimvr_cmd="${rootdir}/observations/seq_filter.py -o ./obs_seq.old ${vrj_file}"
                echo "    --- ${trimvr_cmd}"

                if ! ${trimvr_cmd}; then
                    #echo "        Failed. Ignore ${vrj_file}"
                    (( j++ ))
                    continue
                fi
            else
                cp ${vrj_file} ./obs_seq.old
            fi

            #echo "    $k-$n: Using VEL data in ${vrj_file}"

            if [[ $verb -eq 1 ]]; then
                echo "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
            fi
            { echo "Run command ${obspreprocess} as:";
              echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
              echo "";
            }                                                      >& ${srunout}_VR_${rad_name[$j]}

            ${runcmd_str} echo "$g_date $g_sec" | ${obspreprocess} >> ${srunout}_VR_${rad_name[$j]} 2>&1

            rm ./obs_seq.old

            if [[ -e ./obs_seq.new ]]; then
                echo "    $k-$n: Using VEL data in ${vrj_file}"
                mv ./obs_seq.new ./obs_seq.vr${j}
                echo $wrkdir/OBSDIR/obs_seq.vr${j} >> obsflist.radvr
                (( n++ ))
            fi

        fi

        (( j++ ))
    done

    if [[ $n -gt 0 ]]; then
        obsflists+=(obsflist.radvr)
    else
        echo "    No valid radial velocity data is processed"
    fi

    #-------------------------------------------------------------------
    #
    # Run OBS_SEQUENCE_TOOL
    #
    #-------------------------------------------------------------------

    if [[ ${#obsflists[@]} -gt 0 ]]; then
        if [[ $verb -eq 1 ]]; then
            echo "cat ${obsflists[*]} to obsflist"
        fi
        cat "${obsflists[@]}" > obsflist
    else
        echo "    No valid observation was found"
        exit 0
    fi

    #===================================================================

    (( gobef_secs=iseconds - 329 ))    # -5m-29s
    (( goaft_secs=iseconds + 150 ))    # +2m+30s

    read -r -a gobef_dates < <(convertS2days "${gobef_secs}")
    read -r -a goaft_dates < <(convertS2days "${goaft_secs}")

    sedfile=$(mktemp -t input.nml_${eventtime}.sed_XXXX)

    cat <<EOF > $sedfile
/first_obs_days/s/-1/${gobef_dates[0]}/
/first_obs_seconds/s/-1/${gobef_dates[1]}/
/last_obs_days/s/-1/${goaft_dates[0]}/
/last_obs_seconds/s/-1/${goaft_dates[1]}/
EOF

    sed -f $sedfile -i input.nml

    rm -f $sedfile

    #===================================================================

    #COMBINE obs-seq FILES HERE
    # namelist file input.nml contains:
    # &obs_sequence_tool_nml
    #    filename_seq_list = 'obsflist'
    #    filename_out      = 'obs_seq.${timestr_cur}'
    # /
    #
    if [[ $verb -eq 1 ]]; then echo "Runing ${exedir}/dart/obs_sequence_tool"; fi
    ${runcmd_str} ${exedir}/dart/obs_sequence_tool >& ${srunout}_sequence_tool

    if [[ $? -eq 0 && -e obs_seq.${anlys_date}${anlys_time} ]]; then
        echo "    Observation file ${wrkdir}/OBSDIR/obs_seq.${anlys_date}${anlys_time} created"
    else
        echo "ERROR: ${runcmd_str} ${exedir}/dart/obs_sequence_tool"
    fi

    #rm -f ./obs_seq.hfmetar ./obs_seq.meso ./obs_seq.cwp ./obs_seq.mrms ./obs_seq.rad ./obs_seq.vr*

    #rm -f dart_log.* obsflist* init.nc
    #rm -f obsflist* wrfinput_d0*

    echo " "
    cd $wrkdir || return
}

########################################################################

function run_filter {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, ADAPTIVE_INF, OBS_DIR
    #         intvl_sec, ncores_filter
    # RETURN: input_file_list, output_file_list
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.filter || -f $wrkdir/done.filter || -f $wrkdir/queue.filter ]]; then
        return
    fi

    # shellcheck disable=SC2154
    timesec_pre=$((iseconds-intvl_sec))
    event_pre=$(date -u -d @${timesec_pre}   +%H%M)
    timestr_cur=$(date -u -d @${iseconds}    +%Y%m%d%H%M)

    datestr4obsdiag=$(date -u -d @${iseconds} +%Y,%m,%d,%H,%M,%S)
    intvl_min=$((intvl_sec/60))
    dateintvl4obsdiag="0, 0, 0,00,${intvl_min},00"

    (( gobef_secs=iseconds - 329 ))    # -5m-29s
    (( goaft_secs=iseconds + 150 ))    # +2m+30s
    (( gobtw_secs=goaft_secs-gobef_secs ))
    datestr4obsdiag_start=$(date -u -d @${gobef_secs} +%Y,%m,%d,%H,%M,%S)
    datestr4obsdiag_end=$(date -u -d @${goaft_secs} +%Y,%m,%d,%H,%M,%S)


    parentdir=$(dirname ${wrkdir})

    #------------------------------------------------------
    # Waiting for job conditions before submit the job
    #------------------------------------------------------

    if [[ $icycle -eq 0 ]]; then
        conditions=("${rundir}/init/done.init")
    else
        conditions=("${parentdir}/${event_pre}/done.fcst")
    fi

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # 1. Update input files to get filter started
    #------------------------------------------------------

    currtime_str=$(date -u -d @$iseconds +%Y-%m-%d_%H.%M.%S)

    rm -f filter_in.txt filter_out.txt
    input_file_list=()
    output_file_list=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        if [[ $icycle -eq 0 ]]; then
            input_file="$rundir/init/wofs_mpas_${memstr}.init.nc"
        else
            input_file="$parentdir/${event_pre}/wofs_mpas_${memstr}.restart.$currtime_str.nc"
        fi

        if [[ $dorun == true && ! -f $input_file ]]; then
            echo "File $input_file not exist."
            exit 1
        fi
        echo $input_file >> filter_in.txt
        input_file_list+=("$input_file")

        #output_file="${domname}_${memstr}.analysis.$currtime_str.nc"
        output_file="${domname}_${memstr}.analysis"
        echo $output_file >> filter_out.txt
        output_file_list+=("$output_file")
    done

    if [[ $icycle -eq 0 ]]; then
        # Skip filter at cycle 0 temporarily
        touch done.filter
        return
    fi

    #firstfile=$(head -1 filter_in.txt)
    #ln -sf $firstfile init.nc             # The name of the MPAS analysis file to be read and/or written by the DART programs for the state data.
    #ln -sf ${rundir}/dacycles/${inittime_str}/${domname}_01.restart.${frsttime_str}.nc init.nc
    filename_mesh="${rundir}/init/${domname}_01.init.nc"

    #------------------------------------------------------
    # 2. Adaptive inflation
    #------------------------------------------------------

    inf_initial=(".false." ".false.")
    if [[ $ADAPTIVE_INF == true && $icycle -gt 1 ]]; then
        if [[ $dorun == true && ! -e ${parentdir}/${event_pre}/output_priorinf_mean.nc ]]; then
          echo "File ${parentdir}/${event_pre}/output_priorinf_mean.nc does not exist. Stop."
          exit 2
        fi
        ln -sf ${parentdir}/${event_pre}/output_priorinf_mean.nc input_priorinf_mean.nc
        ln -sf ${parentdir}/${event_pre}/output_priorinf_sd.nc   input_priorinf_sd.nc

        inf_initial=(".true." ".true.")
    fi

    #------------------------------------------------------
    # 3. Prepare namelist file
    #------------------------------------------------------
    # shellcheck disable=SC2154
    cat << EOF > input.nml
&perfect_model_obs_nml
   read_input_state_from_file = .true.
   single_file_in             = .false.
   input_state_files          = 'mpas_init.nc'
   init_time_days             = -1
   init_time_seconds          = -1

   write_output_state_to_file = .false.
   single_file_out            = .false.
   output_state_files         = 'perfect_restart.nc'
   output_interval            = 1

   async                      = 0
   adv_ens_command            = './advance_model.csh'

   obs_seq_in_file_name       = 'obs_seq.in'
   obs_seq_out_file_name      = 'obs_seq.out'
   first_obs_days             = -1
   first_obs_seconds          = -1
   last_obs_days              = -1
   last_obs_seconds           = -1

   trace_execution            = .true.
   output_timestamps          = .false.
   print_every_nth_obs        = 0
   output_forward_op_errors   = .false.
   silence                    = .false.
  /

&filter_nml
   async                    = 0
   adv_ens_command          = 'no_model_advance'
   ens_size                 = ${ENS_SIZE}
   output_members           = .true.
   obs_sequence_in_name     = 'obs_seq.in'
   obs_sequence_out_name    = 'obs_seq.final'
   input_state_file_list    = 'filter_in.txt'
   output_state_file_list   = 'filter_out.txt'
   init_time_days           = -1
   init_time_seconds        = -1
   first_obs_days           = -1
   first_obs_seconds        = -1
   last_obs_days            = -1
   last_obs_seconds         = -1
   num_output_state_members = 36
   num_output_obs_members   = 36
   output_interval          = 1
   num_groups               = 1
   distributed_state        = .true.
   compute_posterior        = .true.
   output_forward_op_errors = .false.
   output_timestamps        = .true.
   trace_execution          = .true.
   silence                  = .false.

   stages_to_write          = 'preassim', 'output'
   output_mean              = .true.
   output_sd                = .true.
   write_all_stages_at_end  = .false.

   inf_flavor                  = 2,                       0,
   inf_initial_from_restart    = $(join_by ',' "${inf_initial[@]}"),
   inf_sd_initial_from_restart = $(join_by ',' "${inf_initial[@]}"),
   inf_deterministic           = .true.,                  .true.,
   inf_initial                 = 1.0,                     1.0
   inf_sd_initial              = 0.6,                     0.0
   inf_damping                 = 0.9,                     1.0
   inf_lower_bound             = 1.0,                     1.0
   inf_upper_bound             = 1000.0,               1000000.0
   inf_sd_lower_bound          = 0.6,                     0.0
   inf_sd_max_change           = 1.05,                    1.05,
  /

&quality_control_nml
   input_qc_threshold = 5,
   outlier_threshold  = 3.5,
   enable_special_outlier_code = .false.
  /

&state_vector_io_nml
   single_precision_output    = .false.,
  /

&mpi_utilities_nml
  /

&smoother_nml
   num_lags              = 0
   start_from_restart    = .true.
   output_restart        = .false.
   restart_in_file_name  = 'smoother_ics'
   restart_out_file_name = 'smoother_restart'
  /

&ensemble_manager_nml
   layout = 2
   tasks_per_node = ${ncores_filter}
  /

&assim_tools_nml
   filter_kind                       = 1
   cutoff                            = 0.036,
   distribute_mean                   = .true.
   convert_all_obs_verticals_first   = .true.
   convert_all_state_verticals_first = .true.
   sort_obs_inc                      = .false.
   spread_restoration                = .false.
   sampling_error_correction         = .false.
   adaptive_localization_threshold   = -1
   output_localization_diagnostics   = .false.
   localization_diagnostics_file     = 'localization_diagnostics'
   print_every_nth_obs               = 0
   special_localization_obs_types  = 'METAR_ALTIMETER',
                                     'METAR_U_10_METER_WIND',
                                     'METAR_V_10_METER_WIND',
                                     'METAR_TEMPERATURE_2_METER',
                                     'METAR_DEWPOINT_2_METER',
                                     'MARINE_SFC_U_WIND_COMPONENT',
                                     'MARINE_SFC_V_WIND_COMPONENT',
                                     'MARINE_SFC_TEMPERATURE',
                                     'MARINE_SFC_ALTIMETER',
                                     'MARINE_SFC_DEWPOINT',
                                     'LAND_SFC_U_WIND_COMPONENT',
                                     'LAND_SFC_V_WIND_COMPONENT',
                                     'LAND_SFC_TEMPERATURE',
                                     'LAND_SFC_DEWPOINT',
                                     'LAND_SFC_ALTIMETER',
                                     'LAND_SFC_PRESSURE',
                                     'RADAR_REFLECTIVITY',
                                     'RADAR_CLEARAIR_REFLECTIVITY',
                                     'DOPPLER_RADIAL_VELOCITY',
                                     'GOES_CWP_PATH',
                                     'GOES_LWP_PATH',
                                     'GOES_IWP_PATH',
                                     'GOES_CWP_ZERO',
   special_localization_cutoffs    = 0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0047123,
                                     0.0047123,
                                     0.0047123,
                                     0.0047123,
                                     0.0094247,
                                     0.0047123,
                                     0.0014137,
                                     0.0014137,
                                     0.0014137,
                                     0.00315,
                                     0.00315,
                                     0.00315,
                                     0.0035,
  /

&location_nml
   horiz_dist_only                 = .false.
   vert_normalization_pressure     = 700000.0,
   vert_normalization_height       = 111111.1,
   vert_normalization_level        = 2666.7,
   vert_normalization_scale_height = 2.0
   approximate_distance            = .false.
   nlon                            = 283,
   nlat                            = 144,
   output_box_info                 = .false.
   print_box_level                 = 0
   special_vert_normalization_obs_types =  'METAR_ALTIMETER',
                                           'METAR_U_10_METER_WIND',
                                           'METAR_V_10_METER_WIND',
                                           'METAR_TEMPERATURE_2_METER',
                                           'METAR_DEWPOINT_2_METER',
                                           'MARINE_SFC_U_WIND_COMPONENT',
                                           'MARINE_SFC_V_WIND_COMPONENT',
                                           'MARINE_SFC_TEMPERATURE',
                                           'MARINE_SFC_ALTIMETER',
                                           'MARINE_SFC_DEWPOINT',
                                           'LAND_SFC_U_WIND_COMPONENT',
                                           'LAND_SFC_V_WIND_COMPONENT',
                                           'LAND_SFC_TEMPERATURE',
                                           'LAND_SFC_DEWPOINT',
                                           'LAND_SFC_ALTIMETER',
                                           'LAND_SFC_PRESSURE',
                                           'RADAR_REFLECTIVITY',
                                           'RADAR_CLEARAIR_REFLECTIVITY',
                                           'DOPPLER_RADIAL_VELOCITY',
                                           'GOES_CWP_PATH',
                                           'GOES_LWP_PATH',
                                           'GOES_IWP_PATH',
                                           'GOES_CWP_ZERO',
   special_vert_normalization_pressures =  100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                         15873016.0,
                                         12698413.0,
                                         15873016.0,
                                           100000.0,
   special_vert_normalization_heights  =   424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           2122090.9,
                                           2083333.2,
                                           2122090.9,
                                           1587301.0,
                                           1587301.0,
                                           1587301.3,
                                           1000000.0,
   special_vert_normalization_levels    =  20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
   special_vert_normalization_scale_heights = 5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
  /

&xyz_location_nml
  /

&cov_cutoff_nml
   select_localization = 1
  /

&reg_factor_nml
   select_regression    = 1
   input_reg_file       = 'time_mean_reg'
   save_reg_diagnostics = .false.
   reg_diagnostics_file = 'reg_diagnostics'
  /

&obs_sequence_nml
   write_binary_obs_sequence = .false.
  /

!   assimilate_these_obs_types = 'RADIOSONDE_TEMPERATURE',
!                                'RADIOSONDE_U_WIND_COMPONENT',
!                                'RADIOSONDE_V_WIND_COMPONENT',
!                                'RADIOSONDE_SPECIFIC_HUMIDITY',
!                                'GPSRO_REFRACTIVITY',
!                                'LAND_SFC_ALTIMETER',
!                                'MARINE_SFC_DEWPOINT',
!                                'AIRCRAFT_U_WIND_COMPONENT',
!                                'AIRCRAFT_V_WIND_COMPONENT',
!                                'AIRCRAFT_TEMPERATURE',
!                                'ACARS_U_WIND_COMPONENT',
!                                'ACARS_V_WIND_COMPONENT',
!                                'ACARS_TEMPERATURE',
!                                'SAT_U_WIND_COMPONENT',
!                                'SAT_V_WIND_COMPONENT',
!                                'RADAR_REFLECTIVITY',
!                                'RADAR_CLEARAIR_REFLECTIVITY',
!                                'DOPPLER_RADIAL_VELOCITY'

! Upper level
!                                'AIRCRAFT_U_WIND_COMPONENT',
!                                'AIRCRAFT_V_WIND_COMPONENT',
!                                'AIRCRAFT_TEMPERATURE',
!                                'ACARS_U_WIND_COMPONENT',
!                                'ACARS_V_WIND_COMPONENT',
!                                'ACARS_TEMPERATURE',

!                                'RADIOSONDE_TEMPERATURE',
!                                'RADIOSONDE_U_WIND_COMPONENT',
!                                'RADIOSONDE_V_WIND_COMPONENT',
!                                'RADIOSONDE_SPECIFIC_HUMIDITY',
!                                'GPSRO_REFRACTIVITY',

! Surface
!                                'METAR_ALTIMETER',
!                                'METAR_DEWPOINT_2_METER',
!                                'METAR_U_10_METER_WIND',
!                                'METAR_V_10_METER_WIND',
!                                'METAR_TEMPERATURE_2_METER',
!                                'METAR_SPECIFIC_HUMIDITY_2_METER',
!                                'MARINE_SFC_SPECIFIC_HUMIDITY',
!                                'MARINE_SFC_U_WIND_COMPONENT',
!                                'MARINE_SFC_V_WIND_COMPONENT',
!                                'MARINE_SFC_TEMPERATURE',
!                                'MARINE_SFC_PRESSURE',
!                                'MARINE_SFC_DEWPOINT',
!                                'LAND_SFC_PRESSURE',
!                                'LAND_SFC_ALTIMETER',
!                                'LAND_SFC_DEWPOINT',
!                                'LAND_SFC_TEMPERATURE',
!                                'LAND_SFC_SPECIFIC_HUMIDITY',
!                                'LAND_SFC_U_WIND_COMPONENT',
!                                'LAND_SFC_V_WIND_COMPONENT',
!
&obs_kind_nml
   assimilate_these_obs_types = 'AIRCRAFT_U_WIND_COMPONENT',
                                'AIRCRAFT_V_WIND_COMPONENT',
                                'AIRCRAFT_TEMPERATURE',
                                'ACARS_U_WIND_COMPONENT',
                                'ACARS_V_WIND_COMPONENT',
                                'ACARS_TEMPERATURE',
                                'METAR_ALTIMETER',
                                'METAR_DEWPOINT_2_METER',
                                'METAR_U_10_METER_WIND',
                                'METAR_V_10_METER_WIND',
                                'METAR_TEMPERATURE_2_METER',
                                'MARINE_SFC_U_WIND_COMPONENT',
                                'MARINE_SFC_V_WIND_COMPONENT',
                                'MARINE_SFC_TEMPERATURE',
                                'MARINE_SFC_ALTIMETER',
                                'MARINE_SFC_DEWPOINT',
                                'LAND_SFC_PRESSURE',
                                'LAND_SFC_ALTIMETER',
                                'LAND_SFC_TEMPERATURE',
                                'LAND_SFC_DEWPOINT',
                                'LAND_SFC_U_WIND_COMPONENT',
                                'LAND_SFC_V_WIND_COMPONENT',
                                'RADAR_REFLECTIVITY',
                                'RADAR_CLEARAIR_REFLECTIVITY',
                                'DOPPLER_RADIAL_VELOCITY',
                                'GOES_IWP_PATH',
                                'GOES_CWP_ZERO',
                                'GOES_CWP_PATH',
                                'GOES_LWP_PATH',
                                'GOES_16_ABI_TB',
   evaluate_these_obs_types = ''
  /

&obs_def_gps_nml
   max_gpsro_obs = 100000
  /

&obs_def_radar_mod_nml
   apply_ref_limit_to_obs     =  .true. ,
   reflectivity_limit_obs     =     0.0 ,
   lowest_reflectivity_obs    =     0.0 ,
   apply_ref_limit_to_fwd_op  =  .true. ,
   reflectivity_limit_fwd_op  =     0.0 ,
   lowest_reflectivity_fwd_op =     0.0 ,
   dielectric_factor          =   0.224 ,
   n0_rain                    =   8.0e6 ,
   n0_graupel                 =   4.0e6 ,
   n0_snow                    =   3.0e6 ,
   rho_rain                   =  1000.0 ,
   rho_graupel                =   400.0 ,
   rho_snow                   =   100.0 ,
   allow_wet_graupel          = .false. ,
   microphysics_type          =       5 ,
   allow_dbztowt_conv         = .true.
/
&obs_def_cwp_nml
   pressure_top               = 15000.0,
   physics                    = 8
/

&model_nml
   init_template_filename       = '${filename_mesh}'
   assimilation_period_days     = 0
   assimilation_period_seconds  = ${intvl_sec}
   model_perturbation_amplitude = 0.0001
   vert_localization_coord      = 3
   calendar                     = 'Gregorian'
   highest_obs_pressure_mb      = 20.0
   sfc_elev_max_diff            = 100.
   log_p_vert_interp            = .true.
   debug                        = 0
   use_u_for_wind               = .false.
   use_rbf_option               = 2
   update_u_from_reconstruct    = .true.
   use_increments_for_u_update  = .true.
  /

!                          'theta',                 'QTY_POTENTIAL_TEMPERATURE',
!                          'surface_pressure',      'QTY_SURFACE_PRESSURE',
!                          'uReconstructZonal',     'QTY_U_WIND_COMPONENT',
!                          'uReconstructMeridional','QTY_V_WIND_COMPONENT',
!                          'u',                     'QTY_EDGE_NORMAL_SPEED',
!                          'w',                     'QTY_VERTICAL_VELOCITY',
!                          'qv',                    'QTY_VAPOR_MIXING_RATIO',
!                          'rho',                   'QTY_DENSITY',
!                          'u10',                   'QTY_10M_U_WIND_COMPONENT',
!                          'v10',                   'QTY_10M_V_WIND_COMPONENT',
!                          't2m',                   'QTY_2M_TEMPERATURE',
!                          'q2',                    'QTY_2M_SPECIFIC_HUMIDITY',

&mpas_vars_nml
   mpas_state_variables = 'theta',                 'QTY_POTENTIAL_TEMPERATURE',
                          'rho',                   'QTY_DENSITY',
                          'uReconstructZonal',     'QTY_U_WIND_COMPONENT',
                          'uReconstructMeridional','QTY_V_WIND_COMPONENT',
                          'u',                     'QTY_EDGE_NORMAL_SPEED',
                          'w',                     'QTY_VERTICAL_VELOCITY',
                          'u10',                   'QTY_10M_U_WIND_COMPONENT',
                          'v10',                   'QTY_10M_V_WIND_COMPONENT',
                          't2m',                   'QTY_2M_TEMPERATURE',
                          'q2',                    'QTY_2M_SPECIFIC_HUMIDITY',
                          'surface_pressure',      'QTY_SURFACE_PRESSURE',
                          'qv',                    'QTY_VAPOR_MIXING_RATIO',
                          'qc',                    'QTY_CLOUDWATER_MIXING_RATIO',
                          'qr',                    'QTY_RAINWATER_MIXING_RATIO',
                          'qi',                    'QTY_ICE_MIXING_RATIO',
                          'qs',                    'QTY_SNOW_MIXING_RATIO',
                          'qg',                    'QTY_GRAUPEL_MIXING_RATIO',
                          'qh',                    'QTY_HAIL_MIXING_RATIO',
                          'volg',                  'QTY_GRAUPEL_VOLUME',
                          'volh',                  'QTY_HAIL_VOLUME',
                          'nc',                    'QTY_DROPLET_NUMBER_CONCENTR',
                          'nr',                    'QTY_RAIN_NUMBER_CONCENTR',
                          'ni',                    'QTY_ICE_NUMBER_CONCENTRATION',
                          'ns',                    'QTY_SNOW_NUMBER_CONCENTR',
                          'ng',                    'QTY_GRAUPEL_NUMBER_CONCENTR',
                          'nh',                    'QTY_HAIL_NUMBER_CONCENTR',
                          'refl10cm',              'QTY_RADAR_REFLECTIVITY',
   mpas_state_bounds    = 'qv','0.0','NULL','CLAMP',
                          'qc','0.0','NULL','CLAMP',
                          'qr','0.0','NULL','CLAMP',
                          'qi','0.0','NULL','CLAMP',
                          'qs','0.0','NULL','CLAMP',
                          'qg','0.0','NULL','CLAMP',
                          'qh','0.0','NULL','CLAMP',
                          'volg','0.0','NULL','CLAMP',
                          'volh','0.0','NULL','CLAMP',
                          'nc','0.0','NULL','CLAMP',
                          'nr','0.0','NULL','CLAMP',
                          'ni','0.0','NULL','CLAMP',
                          'ns','0.0','NULL','CLAMP',
                          'ng','0.0','NULL','CLAMP',
                          'nh','0.0','NULL','CLAMP',
  /

&update_mpas_states_nml
  update_input_file_list  = 'filter_out.txt'
  update_output_file_list = 'filter_in.txt'
  print_data_ranges       = .true.
  /

&update_bc_nml
  update_analysis_file_list           = 'filter_out.txt'
  update_boundary_file_list           = 'boundary_inout.txt'
  lbc_update_from_reconstructed_winds = .false.
  lbc_update_winds_from_increments    = .false.
  debug = 0
/

&utilities_nml
   TERMLEVEL      = 1
   module_details = .false.
   logfilename    = 'dart_log.out'
   nmlfilename    = 'dart_log.nml'
   write_nml      = 'file'
  /

&preprocess_nml
   overwrite_output        = .true.
   input_obs_def_mod_file  = '../../../observations/forward_operators/DEFAULT_obs_def_mod.F90'
   output_obs_def_mod_file = '../../../observations/forward_operators/obs_def_mod.f90'
   input_obs_qty_mod_file  = '../../../assimilation_code/modules/observations/DEFAULT_obs_kind_mod.F90'
   output_obs_qty_mod_file = '../../../assimilation_code/modules/observations/obs_kind_mod.f90'
   obs_type_files          = '../../../observations/forward_operators/obs_def_reanalysis_bufr_mod.f90',
                             '../../../observations/forward_operators/obs_def_altimeter_mod.f90',
                             '../../../observations/forward_operators/obs_def_gts_mod.f90',
                             '../../../observations/forward_operators/obs_def_metar_mod.f90',
                             '../../../observations/forward_operators/obs_def_gps_mod.f90',
                             '../../../observations/forward_operators/obs_def_vortex_mod.f90',
                             '../../../observations/forward_operators/obs_def_rel_humidity_mod.f90',
                             '../../../observations/forward_operators/obs_def_dew_point_mod.f90',
                             '../../../observations/forward_operators/obs_def_radar_mod.f90',
                             '../../../observations/forward_operators/obs_def_cwp_mod.f90'
   quantity_files          = '../../../assimilation_code/modules/observations/default_quantities_mod.f90',
                             '../../../assimilation_code/modules/observations/atmosphere_quantities_mod.f90',
  /

&obs_sequence_tool_nml
   filename_seq_list = 'obsflist'
   filename_out      = 'obs_seq.${timestr_cur}'
   first_obs_days    = -1
   first_obs_seconds = -1
   last_obs_days     = -1
   last_obs_seconds  = -1
   print_only        = .false.
   min_lat           = -90.0
   max_lat           =  90.0
   min_lon           =   0.0
   max_lon           = 360.0
   gregorian_cal     = .true.
   keep_types        = .true.
   obs_types         = ''
  /

# The times in the namelist for the obs_diag program are vectors
# that follow the following sequence:
# year   month   day   hour   minute   second
# max_num_bins can be used to specify a fixed number of bins,
# in which case last_bin_center should be safely in the future.
#
# keep only the U and V radiosonde winds:
#   obs_types          = 'RADIOSONDE_U_WIND_COMPONENT'
#                        'RADIOSONDE_V_WIND_COMPONENT'
#   keep_types         = .true.
#
# remove the U and V radiosonde winds:
#   obs_types          = 'RADIOSONDE_U_WIND_COMPONENT'
#                        'RADIOSONDE_V_WIND_COMPONENT'
#   keep_types         = .false.
#
# keep only observations with a DART QC of 0:
#   qc_metadata        = 'Dart quality control'
#   min_qc             = 0
#   max_qc             = 0
#
# keep only radiosonde temp obs between 250 and 300 K:
#   copy_metadata      = 'NCEP BUFR observation'
#   copy_type          = 'RADIOSONDE_TEMPERATURE'
#   min_copy           = 250.0
#   max_copy           = 300.0
#


&schedule_nml
   calendar             = 'Gregorian'
   first_bin_start      =  ${datestr4obsdiag_start}
   first_bin_end        =  ${datestr4obsdiag_end}
   last_bin_end         =  ${datestr4obsdiag_end}
   bin_interval_days    = 0
   bin_interval_seconds = ${gobtw_secs}
   max_num_bins         = 1000
   print_table          = .true.
  /


&obs_seq_to_netcdf_nml
   obs_sequence_name = 'obs_seq.final'
   obs_sequence_list = ''
   append_to_netcdf  = .false.
   lonlim1           =    0.0
   lonlim2           =  360.0
   latlim1           =  -90.0
   latlim2           =   90.0
   verbose           = .true.
  /

&obs_diag_nml
   obs_sequence_name  = 'obs_seq.final'
   obs_sequence_list  = ''
   first_bin_center   = ${datestr4obsdiag}
   last_bin_center    = ${datestr4obsdiag}
   bin_width          = ${dateintvl4obsdiag}
   bin_separation     = ${dateintvl4obsdiag}
   time_to_skip       =    0, 0, 0,00,00,00
   trusted_obs        = 'null'
   nregions  = 1
   lonlim1   =   0.0
   lonlim2   = 360.0
   latlim1   = -90.0
   latlim2   =  90.0
   reg_names = 'WOFS'
   create_rank_histogram = .true.
   outliers_in_histogram = .true.
   use_zero_error_obs    = .false.
   verbose               = .true.
  /

&obs_common_subset_nml
   num_to_compare_at_once = 2
   filename_seq           = ''
   filename_seq_list      = ''
   filename_out_suffix    = '.common'
   calendar               = 'Gregorian'
   print_every            = 1000
   dart_qc_threshold      = 3
   print_only             = .false.
  /

# possible vertical coordinate systems are:
# VERTISUNDEF VERTISSURFACE VERTISLEVEL VERTISPRESSURE VERTISHEIGHT VERTISSCALEHEIGHT
   quantity_of_interest = 'QTY_SURFACE_PRESSURE'
   quantity_of_interest = 'QTY_POTENTIAL_TEMPERATURE'
   quantity_of_interest = 'QTY_TEMPERATURE'
   quantity_of_interest = 'QTY_U_WIND_COMPONENT'
   quantity_of_interest = 'QTY_V_WIND_COMPONENT'
   quantity_of_interest = 'QTY_DENSITY'
   quantity_of_interest = 'QTY_VAPOR_MIXING_RATIO'

&model_mod_check_nml
   input_state_files     = 'mpas_init.nc'
   output_state_files    = 'check_me.nc'
   test1thru             = 0
   run_tests             = 1,2,3,4,5,7
   x_ind                 = 300
   loc_of_interest       = 240.0, 0.0, 10000.0
   quantity_of_interest  = 'QTY_U_WIND_COMPONENT'
   interp_test_lonrange  = 0.0, 359.0
   interp_test_dlon      = 1.0
   interp_test_latrange  = -89.0, 89.0
   interp_test_dlat      = 1.0
   interp_test_vertrange = 100.0,  20100.0
   interp_test_dvert     = 2000.0
   interp_test_vertcoord = 'VERTISHEIGHT'
   verbose               = .false.
  /

&exhaustion_nml
   dart_input_file       = 'dart_ics'
   output_file           = 'exhaust'
   advance_time_present  = .FALSE.
   verbose               = .FALSE.
   matlab_out            = .FALSE.
   netcdf_out            = .TRUE.
   kind_of_interest      = 'QTY_U_WIND_COMPONENT'
   interp_test_lonrange  = 0.0, 360.0
   interp_test_dlon      = 1.0
   interp_test_latrange  = -89.0, 89.0
   interp_test_dlat      = 1.0
   interp_test_vertrange = 7000.0, 7000.0
   interp_test_dvert     = 1000.0
   interp_test_vertcoord = 'VERTISHEIGHT'
   hscale                = 100.0
   diff_threshold        = 2.0
   pointcount            = 100000
  /

&obs_def_rttov_nml
   rttov_sensor_db_file   = 'rttov_sensor_db.csv'
   first_lvl_is_sfc       = .true.
   mw_clear_sky_only      = .false.
   interp_mode            = 1
   do_checkinput          = .true.
   apply_reg_limits       = .true.
   verbose                = .true.
   fix_hgpl               = .false.
   do_lambertian          = .false.
   lambertian_fixed_angle = .true.
   rad_down_lin_tau       = .true.
   use_q2m                = .true.
   use_uv10m              = .true.
   use_wfetch             = .false.
   use_water_type         = .false.
   addrefrac              = .false.
   plane_parallel         = .false.
   use_salinity           = .false.
   cfrac_data             = .true.
   clw_data               = .true.
   rain_data              = .true.
   ciw_data               = .true.
   snow_data              = .true.
   graupel_data           = .true.
   hail_data              = .false.
   w_data                 = .true.
   clw_scheme             = 1
   clw_cloud_top          = 322.
   fastem_version         = 6
   supply_foam_fraction   = .false.
   use_totalice           = .true.
   use_zeeman             = .false.
   cc_threshold           = 0.05
   ozone_data             = .false.
   co2_data               = .false.
   n2o_data               = .false.
   co_data                = .false.
   ch4_data               = .false.
   so2_data               = .false.
   addsolar               = .false.
   rayleigh_single_scatt  = .true.
   do_nlte_correction     = .false.
   solar_sea_brdf_model   = 2
   ir_sea_emis_model      = 2
   use_sfc_snow_frac      = .false.
   add_aerosl             = .false.
   aerosl_type            = 1
   add_clouds             = .true.
   ice_scheme             = 1
   use_icede              = .false.
   idg_scheme             = 2
   user_aer_opt_param     = .false.
   user_cld_opt_param     = .false.
   grid_box_avg_cloud     = .true.
   cldcol_threshold       = -1.0
   cloud_overlap          = 1
   cc_low_cloud_top       = 750.0
   ir_scatt_model         = 2
   vis_scatt_model        = 1
   dom_nstreams           = 8
   dom_accuracy           = 0.0
   dom_opdep_threshold    = 0.0
   addpc                  = .false.
   npcscores              = -1
   addradrec              = .false.
   ipcreg                 = 1
   use_htfrtc             = .false.
   htfrtc_n_pc            = -1
   htfrtc_simple_cloud    = .false.
   htfrtc_overcast        = .false.
 /
&obs_seq_coverage_nml
   obs_sequences     = ''
   obs_sequence_list = 'obs_coverage_list.txt'
   obs_of_interest   = 'RADIOSONDE_TEMPERATURE', 'RADIOSONDE_U_WIND_COMPONENT', 'RADIOSONDE_V_WIND_COMPONENT'
   textfile_out      = 'obsdef_mask.txt'
   netcdf_out        = 'obsdef_mask.nc'
   calendar          = 'Gregorian'
   first_analysis    =  2008, 8, 1, 18, 0, 0
   last_analysis     =  2008, 8, 1, 18, 0, 0
   forecast_length_days          = 0
   forecast_length_seconds       = 21600
   verification_interval_seconds = 21600
   temporal_coverage_percent     = 50.0
   lonlim1    =    0.0
   lonlim2    =  360.0
   latlim1    =  -90.0
   latlim2    =   90.0
   verbose    = .true.
   debug      = .false.
  /

# selections_file is a list of obs_defs output
# from the obs_seq_coverage utility.
&obs_selection_nml
   filename_seq          = 'obs_seq.out'
   filename_seq_list     = ''
   filename_out          = 'obs_seq.processed'
   selections_file       = 'obsdef_mask.txt'
   selections_is_obs_seq = .false.
   print_only            = .false.
   calendar              = 'Gregorian'
  /

# one of the other, but not both
   obs_sequences = 'obs_seq.final.2008060100', 'obs_seq.final.2008060112'
   obs_sequence_list = 'obs_forecast_list.txt'
&obs_seq_verify_nml
   obs_sequences     = ''
   obs_sequence_list = 'obs_forecast_list.txt'
   input_template    = 'obsdef_mask.nc'
   netcdf_out        = 'forecast.nc'
   obtype_string     = 'RADIOSONDE_TEMPERATURE'
   print_every       = 20000
   verbose           = .true.
   debug             = .false.
  /

&mpas_dart_obs_preprocess_nml
   file_name_input          = 'obs_seq.old'
   file_name_output         = 'obs_seq.new'
   include_sig_data         = .false.
   superob_aircraft         = .false.
   superob_sat_winds        = .false.
   sfc_elevation_check      = .false.
   overwrite_ncep_sfc_qc    = .false.
   overwrite_ncep_satwnd_qc = .false.
   aircraft_pres_int        = 2500.0
   sat_wind_pres_int        = 2500.0
   sfc_elevation_tol        = 300.0
   obs_pressure_top         = 1.0
   obs_height_top           = 2.0e10
   max_num_obs              = 1000000
   sonde_extra              = 'obs_seq.rawin'
   metar_extra              = 'obs_seq.metar'
   acars_extra              = 'obs_seq.acars'
   land_sfc_extra           = 'obs_seq.land_sfc'
   marine_sfc_extra         = 'obs_seq.marine'
   sat_wind_extra           = 'obs_seq.satwnd'
   profiler_extra           = 'obs_seq.profiler'
   trop_cyclone_extra       = 'obs_seq.tc'
   gpsro_extra              = 'obs_seq.gpsro'
   tc_sonde_radii           = -1.0
   overwrite_obs_time       = .false.
   windowing_obs_time       = .true.
   windowing_int_hour       = 0.5
   increase_bdy_error       = .true.
   maxobsfac                = 10.
   obsdistbdy               = 90000.0     ! meters
   obs_boundary             = 21000.0     ! meters
/
EOF

    #------------------------------------------------------
    # 4. Prepare Obs sequence for this analysis cycle
    #------------------------------------------------------

    if [[ -e OBSDIR/obs_seq.${timestr_cur} ]]; then
        echo "    Using observation file: OBSDIR/obs_seq.${timestr_cur} as obs_seq.in"
        ln -sf OBSDIR/obs_seq.${timestr_cur} obs_seq.in
    else
        if [[ $verb -eq 1 ]]; then echo "run_obsmerge $wrkdir $iseconds"; fi
        run_obsmerge $wrkdir $iseconds |& tee ${wrkdir}/observations.log

        if [[ -e OBSDIR/obs_seq.${timestr_cur} ]]; then
            ln -sf OBSDIR/obs_seq.${timestr_cur} obs_seq.in
        else
            echo "ERROR: Observation file \"${wrkdir}/OBSDIR/obs_seq.${timestr_cur}\" not found"
            exit 3
        fi
    fi

    #------------------------------------------------------
    # 5. Run filter
    #------------------------------------------------------
    #cp $rundir/init/wofs_mpas_01.init.nc init.nc

    #
    # Create job script and submit it
    #
    # shellcheck disable=SC2154
    jobscript="run_filter.${mach}"
    sedfile=$(mktemp -t filter_${eventtime}.sed_XXXX)
    # shellcheck disable=SC2154
    cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/$npefilter/
s/JOBNAME/filter_${eventtime}/
s/CPUSPEC/${claim_cpu_filter}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
s/ISECONDS/${iseconds}/
s/RUNOBS2NC/${run_obs2nc}/
s/RUNOBSDIAG/${run_obsdiag}/
s/RUNADDNOISE/${run_addnoise}/
s/RUNCMD/${job_runexe_str}/
EOF
    # shellcheck disable=SC2154
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/${nnodes_filter}/;s/NCORES/${ncores_filter}/" >> $sedfile
    fi

    submit_a_jobscript $wrkdir "filter" $sedfile $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function run_update_states {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, update_in_place
    #         input_file_list
    #

    #
    # Build working directory
    #
    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.update_states || -f $wrkdir/done.update_states || -f $wrkdir/queue.update_states ]]; then
        return
    fi

    #------------------------------------------------------
    # Prepare update_mpas_states by copying/linking the background files
    #------------------------------------------------------
    # shellcheck disable=SC2154
    if [[ $update_in_place == true ]]; then
        cpcmd="ln -sf"
    else
        cpcmd="cp"
        #cpcmd="rsync -a"
    fi

    # Anaysis background file list, for retrieving update_states output file name
    state_input_file=$(awk '/input_state_file_list/{print $3}' input.nml)
    readarray -t input_file_array < ${state_input_file:1:${#state_input_file}-2}

    # update_states input file list, used as update_states input file names
    update_input_file=$(awk '/update_input_file_list/{print $3}' input.nml)
    readarray -t update_file_array < ${update_input_file:1:${#update_input_file}-2}

    jobarrays=(); statefiles=()
    for iens in $(seq 1 $ENS_SIZE); do
        (( jindex=iens-1 ))

        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        #rm -rf input.nml
        if [[ ! -e input.nml ]]; then
            cp ../input.nml .
        fi

        update_input_file_list='update_states_in.txt'
        rm -rf ${update_input_file_list}
        echo "../${update_file_array[$jindex]}" > ${update_input_file_list}

        update_output_file_list='update_states_out.txt'
        rm -rf ${update_output_file_list}

        fn="${input_file_array[$jindex]}"
        fnbase=$(basename $fn)
        echo "./$fnbase" > ${update_output_file_list}
        sed -i "/update_input_file_list/s/=.*/= '${update_input_file_list}'/" input.nml
        sed -i "/update_output_file_list/s/=.*/= '${update_output_file_list}'/" input.nml
        filename_mesh="${rundir}/init/${domname}_${memstr}.init.nc"
        sed -i "/init_template_filename/s#=.*#= '${filename_mesh}'#" input.nml

        if [[ ! -e done.update_states_${memstr} ]]; then
            jobarrays+=("$iens")
            statefiles+=("$fn")
        fi
    done

    cd $wrkdir || return

    #
    # Waiting for job conditions
    #
    conditions=(done.filter)

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # Run update_mpas_states for all ensemble members
    #------------------------------------------------------

    #
    # Create job script and submit it
    #
    jobscript="run_update_states.${mach}"
    sedfile=$(mktemp -t update_${eventtime}.sed_XXXX)
    # shellcheck disable=SC2154
    cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/1/
s/JOBNAME/updatestates_${eventtime}/
s/CPUSPEC/${claim_cpu_update}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runexe_str}/
s#CPCMD#${cpcmd}#g
s#STATEFILESSTR#${statefiles[*]}#
EOF
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
    fi

    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    submit_a_jobscript "$wrkdir" "update_states" "$sedfile" "$TEMPDIR/$jobscript" "$jobscript" "${jobarraystr}"
}

########################################################################

function run_update_bc {
    # $1
    # wrkdir
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.update_bc || -f $wrkdir/done.update_bc || -f $wrkdir/queue.update_bc ]]; then
        return
    fi

    #
    # Waiting for job conditions
    #
    conditions=("${rundir}"/lbc/done.lbc)

    if [[ $run_addnoise == true ]]; then
        conditions+=("${wrkdir}/done.add_noise")
    else
        conditions+=("${wrkdir}/done.update_states")
    fi

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    # shellcheck disable=SC2154
    if [[ $icycle -gt 0 && ${run_updatebc} == true ]]; then
        cpcmd="cp"
        #cpcmd="rsync -a"
    else
        cpcmd="ln -sf"
    fi

    #------------------------------------------------------
    # Prepare update_bc by copying/linking the background files
    #------------------------------------------------------

    if [[ $icycle -gt 0 && $run_updatebc ]]; then
        # Filter input file list, will be used for update_bc as input
        # because update_states should have updated them
        state_input_file=$(awk '/input_state_file_list/{print $3}' input.nml)
        readarray -t input_file_array < ${state_input_file:1:${#state_input_file}-2}
        infile_array=()
        for fn in "${input_file_array[@]}"; do
            basefn=$(basename $fn)
            infile_array+=("$basefn")
        done
    fi

    jobarrays=(); lbcfiles_org=(); lbcfiles_mem=()
    for iens in $(seq 1 $ENS_SIZE); do
        (( jindex=iens-1 ))

        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        update_output_file_list='update_bc_inout.txt'
        update_input_file_list='update_bc_in.txt'
        rm -rf ${update_output_file_list}
        rm -rf ${update_input_file_list}

        if [[ ! -e input.nml && $icycle -gt 0 && $run_updatebc ]]; then
            cp ../input.nml .
        fi

        #
        # lbc files
        #
        # shellcheck disable=SC2154
        jens=$(( (iens-1)%nenslbc+1 ))
        mlbcstr=$(printf "%02d" $jens)           # get LBC member string

        isec_nlbc1=$(( iseconds/3600*3600 ))
        isec_nlbc2=${isec_nlbc1}
        isec_elbc=$(( iseconds+intvl_sec ))
        while [[ $isec_elbc -gt $isec_nlbc2 ]]; do
            (( isec_nlbc2+=EXTINVL ))
        done
        # External GRIB file provided file times
        lbctime_str1=$(date -u -d @${isec_nlbc1} +%Y-%m-%d_%H.%M.%S)
        lbctime_str2=$(date -u -d @${isec_nlbc2} +%Y-%m-%d_%H.%M.%S)

        # MPAS expected boundary file times
        mpastime_str1=$(date -u -d @${iseconds}  +%Y-%m-%d_%H.%M.%S)
        if [[ ${run_updatebc} == true ]]; then
            mpastime_str2=${lbctime_str2}
            icycle_lbcgap=$(( isec_nlbc2-iseconds ))
        else
            isec_elbc=$((iseconds+EXTINVL))
            mpastime_str2=$(date -u -d @${isec_elbc} +%Y-%m-%d_%H.%M.%S)
            icycle_lbcgap=${EXTINVL}
        fi
        if [[ $verb -eq 1 ]]; then
            echo "Member: $iens use lbc files from $rundir/lbc:"
            echo "       ${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc";
            echo "       ${domname}_${mlbcstr}.lbc.${lbctime_str2}.nc";
        fi
        #ln -sf $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc ${domname}_${memstr}.lbc.${mpastime_str1}.nc
        lbc_file0="$rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc"
        lbc_filem="${domname}_${memstr}.lbc.${mpastime_str1}.nc"

        if [[ $icycle -gt 0 && ${run_updatebc} == true ]]; then
            echo "$lbc_filem" >> ${update_output_file_list}
            sed -i "/update_boundary_file_list/s/=.*/= '${update_output_file_list}'/" input.nml
            echo "${infile_array[$jindex]}" >> ${update_input_file_list}
            sed -i "/update_analysis_file_list/s/=.*/= '${update_input_file_list}'/" input.nml

            lbcfiles_org+=("${lbc_file0}")
            lbcfiles_mem+=("${lbc_filem}")
        else             # do not need to run update_bc, just link the files
            ${cpcmd} ${lbc_file0} ${lbc_filem}
            touch "$memwrkdir/done.update_bc_${memstr}"
        fi

        #echo "$$-${FUNCNAME[0]}: Using lbc file: $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str2}.nc ..."
        ln -sf $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str2}.nc ${domname}_${memstr}.lbc.${mpastime_str2}.nc

        jobarrays+=("$iens")
    done

    cd $wrkdir || return

    #------------------------------------------------------
    # Run update_bc for all ensemble members as a job array
    #------------------------------------------------------

    if [[ $icycle -gt 0 && ${run_updatebc} == true ]]; then
        #
        # Create job script and submit it
        #
        jobscript="run_update_bc.${mach}"
        sedfile=$(mktemp -t update_${eventtime}.sed_XXXX)
        cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/1/
s/JOBNAME/updatebc_${eventtime}/
s/CPUSPEC/${claim_cpu_update}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runexe_str}/
s#CPCMD#${cpcmd}#g
s#LBCFILEORGSTR#${lbcfiles_org[*]}#
s#LBCFILEMEMSTR#${lbcfiles_mem[*]}#
EOF
        if [[ "${mach}" == "pbs" ]]; then
            echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
        fi

        jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

        submit_a_jobscript $wrkdir "update_bc" $sedfile $TEMPDIR/$jobscript $jobscript "${jobarraystr}"
    fi
}

########################################################################

function run_add_noise {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, update_in_place
    #         input_file_list
    #

    #
    # Build working directory
    #
    cd $wrkdir || return

    timestr_cur=$(date  -u -d @$iseconds    +%Y%m%d%H%M)
    mpas_timestr=$(date -u -d @$iseconds    +%Y-%m-%d_%H.%M.%S)
    read -r -a days_secs < <(convertS2days "${iseconds}")

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/done.add_noise ]]; then
        #echo "$$-${FUNCNAME[0]}: add_noise is already done"
        return
    fi

    if [[ -f $wrkdir/running.noise_pert || -f $wrkdir/queue.noise_pert ]]; then
        #echo "$$-${FUNCNAME[0]}: add_noise is running/queued."
        return
    fi

    seqfile="obs_seq.final.${timestr_cur}.nc"

    #------------------------------------------------------
    # Run grid_refl_obs.py for noise mask files
    #------------------------------------------------------

    #
    # Waiting for done.update_states
    #
    conditions=("${wrkdir}/done.update_states" "${seqfile}")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    if [[ ! -e done.noise_mask && ! -e running.noise_mask && ! -e queue.noise_mask ]]; then
        if [[ $verb -eq 1 ]]; then echo ""; echo "    Running grid_refl_obs.py at $timestr_cur"; fi

        invfile="$rundir/init/${domname}.invariant.nc"
        #
        # Create job script and submit it
        #
        mymachine="${machine}"
        runexe_str="${job_runexe_str} -n 1"
        if [[ -n "${python_machine}" ]]; then
            mymachine=${python_machine}
            runexe_str=""
        fi

        jobscript="run_noise_mask.${mach}"
        sedfile=$(mktemp -t mask_${eventtime}.sed_XXXX)
        cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/1/
s/JOBNAME/noise_mask_${eventtime}/
s/CPUSPEC/${claim_cpu_update}/g
s#WRKDIR#$wrkdir#g
s/MACHINE/${mymachine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/SEQFILE/${seqfile}/g
s#INVFILE#${invfile}#g
s#WAN_PATH#${WOFSAN_PATH}#g
s/EVENTDAYS/${days_secs[0]}/g
s/EVENTSECS/${days_secs[1]}/g
s/RUNCMD/${runexe_str}/
EOF
        if [[ "${mach}" == "pbs" ]]; then
            echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
        fi

        if [[ -n "${python_machine}" ]]; then    # run the job on the submitted machine
            sed -f "$sedfile" "$TEMPDIR/$jobscript" > "$jobscript"
            echo "Running ${jobscript} on ${python_machine} at $(date +%H:%M:%S)..."
            # shellcheck disable=SC2029
            ssh ${python_machine} "cd ${wrkdir};bash ${jobscript} &> noise_mask.log" &>/dev/null
        else
            submit_a_jobscript $wrkdir "noise_mask" "$sedfile" "$TEMPDIR/$jobscript" "$jobscript" ""
        fi
    fi

    #------------------------------------------------------
    # Run add_pert_where_high_refl.py for all members
    #------------------------------------------------------

    #
    # Waiting for done.noise_mask
    #
    conditions=("${wrkdir}/done.noise_mask")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    if [[ $verb -eq 1 ]]; then echo ""; echo "    Running add_pert_where_high_refl.py at $timestr_cur"; fi

    invfile="$rundir/init/${domname}.invariant.nc"

    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        if [[ ! -e done.add_noise_${memstr} && ! -e running.add_noise_${memstr} ]]; then
            days_str=$(printf "%5.5i_%6.6i" ${days_secs[0]} ${days_secs[1]})
            ln -sf ../refl_obs_${days_str}.pkl ../wofs_mpas_grid_kdtree.pkl ../mpas_XYZ.pkl .
            jobarrays+=("$iens")
        fi
    done

    cd "${wrkdir}" || return

    #
    # Create job script and submit it
    #
    if [[ ${#jobarrays[@]} -gt 0 ]]; then
        jobscript="run_noise_pert.${mach}"
        sedfile=$(mktemp -t pert_${eventtime}.sed_XXXX)

        mymachine="${machine}"
        runexe_str="${job_runexe_str} -n 1"
        if [[ -n "${python_machine}" ]]; then
            mymachine=${python_machine}
            runexe_str=""
        fi

        cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/1/
s/JOBNAME/noist_pert_${eventtime}/
s/CPUSPEC/${claim_cpu_update}/g
s#WRKDIR#$wrkdir#g
s#INVFILE#${invfile}#g
s/MACHINE/${mymachine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/SEQFILE/${seqfile}/g
s#WAN_PATH#${WOFSAN_PATH}#g
s/EVENTDAYS/${days_secs[0]}/g
s/EVENTSECS/${days_secs[1]}/g
s/MPASTIME/${mpas_timestr}/g
s/RUNCMD/${runexe_str}/
EOF
        if [[ "${mach}" == "pbs" ]]; then
            echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
        fi

        if [[ -n "${python_machine}" ]]; then
            sed -f "$sedfile" "$TEMPDIR/$jobscript" > "$jobscript"
            sed -i "s/MEMARRAY/${jobarrays[*]}/" "$jobscript"
            echo "Running ${jobscript} on ${python_machine} at $(date +%H:%M:%S)..."
            # shellcheck disable=SC2029
            ssh ${python_machine} "cd ${wrkdir};bash ${jobscript} &> noise_pert.log" &>/dev/null
        else
            jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")
            submit_a_jobscript $wrkdir "add_noise" "$sedfile" "$TEMPDIR/$jobscript" "$jobscript" "${jobarraystr}"
        fi
    fi
}

########################################################################

function run_mpas {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, intvl_sec, npefcst
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir || exit $?

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.fcst || -f $wrkdir/done.fcst || -f $wrkdir/queue.fcst ]]; then
        return
    fi

    #
    # Waiting for job conditions
    #
    conditions=("${wrkdir}/done.update_bc")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            echo "$$-${FUNCNAME[0]}: Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    echo "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #
    # Preparation for all members
    #
    # shellcheck disable=SC2154
    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefcst} ]]; then
        cd "${rundir}/${domname}" || exit $?
        if [[ $verb -eq 1 ]]; then
            echo "Generating ${domname}.graph.info.part.${npefcst} in $rundir/$domname using $exedir/gpmetis"
        fi
        $exedir/gpmetis -minconn -contig -niter=200 ${domname}.graph.info ${npefcst} > $rundir/$domname/gpmetis.out$npefcst
        estatus=$?
        if [[ ${estatus} -ne 0 ]]; then
            echo "${estatus}: $exedir/gpmetis -minconn -contig -niter=200 ${domname}.graph.info ${npefcst}"
            exit ${estatus}
        fi
        cd "${wrkdir}" || exit $?
    fi

    intvl_min=$((intvl_sec/60))

    fcst_sec=$(( iseconds + intvl_sec ))
    currtime_str=$(date -u -d @${iseconds} +%Y-%m-%d_%H:%M:%S)
    currtime_fil=${currtime_str//:/.}
    fcsttime_fil=$(date -u -d @${fcst_sec} +%Y-%m-%d_%H.%M.%S)

    #
    # Preparation for each member
    #
    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        basen=$(( (iens-1)%6 ))
        if [[ $basen -lt 2 ]]; then     # map to 0,1,2
            idx=0
        elif [[ $basen -lt 4 ]]; then
            idx=1
        else
            idx=2
        fi
        # shellcheck disable=SC2154
        pblscheme=${pbl_schemes[$idx]}
        # shellcheck disable=SC2154
        sfcscheme=${sfclayer_schemes[$idx]}

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        #
        # init files
        #
        if [[ $icycle -eq 0 ]]; then
            #ln -sf ../${domname}_${memstr}.init.nc .
            initfile=$(sed -n "$iens{p;q}" ../filter_in.txt)            # print $iens line only
            if [[ $verb -eq 1 ]]; then echo "Member: $iens use init file: $initfile"; fi
            ln -sf $initfile .
            do_restart="false"
            do_dacyle="false"
        else
            restartfile="./${domname}_${memstr}.restart.${currtime_fil}.nc"
            if [[ $verb -eq 1 ]]; then echo "Member: $iens use restart file: ${restartfile}"; fi
            #ln -sf  $restartfile .
            if [[ ! -e ${restartfile} && ${dorun} == true ]]; then
                echo "ERROR: restart file: ${restartfile} not exists"
                exit 1              # something wrong should never happen
            fi
            do_restart="true"
            do_dacyle="true"
        fi

        ln -sf $rundir/$domname/$domname.graph.info.part.${npefcst} .
        ln -sf $rundir/init/${domname}.invariant.nc .

        streamlists=(stream_list.atmosphere.diagnostics stream_list.atmosphere.output stream_list.atmosphere.surface)
        for fn in "${streamlists[@]}"; do
            cp -f ${FIXDIR}/$fn .
        done

        datafiles=(  CAM_ABS_DATA.DBL  CAM_AEROPT_DATA.DBL GENPARM.TBL       LANDUSE.TBL    \
                     OZONE_DAT.TBL     OZONE_LAT.TBL       OZONE_PLEV.TBL    RRTMG_LW_DATA  \
                     RRTMG_LW_DATA.DBL RRTMG_SW_DATA       RRTMG_SW_DATA.DBL SOILPARM.TBL   \
                     VEGPARM.TBL )

        for fn in "${datafiles[@]}"; do
            ln -sf ${FIXDIR}/$fn .
        done

        if [[ "${mpscheme}" == "Thompson" ]]; then
            thompson_tables=( MP_THOMPSON_QRacrQG_DATA.DBL   MP_THOMPSON_QRacrQS_DATA.DBL   \
                              MP_THOMPSON_freezeH2O_DATA.DBL MP_THOMPSON_QIautQS_DATA.DBL )

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        fi

        fcstmin_str=$(printf "%02d" "${intvl_min}")

        # the ratio of radt to dt is 15
        # shellcheck disable=SC2154
        cat << EOF > namelist.atmosphere
&nhyd_model
    config_time_integration_order   = 2
    config_dt                       = ${time_step}
    config_start_time               = '${currtime_str}'
    config_run_duration             = '00:${fcstmin_str}:00'
    config_split_dynamics_transport = true
    config_number_of_sub_steps      = 2
    config_dynamics_split_steps     = 3
    config_h_mom_eddy_visc2         = 0.0
    config_h_mom_eddy_visc4         = 0.0
    config_v_mom_eddy_visc2         = 0.0
    config_h_theta_eddy_visc2       = 0.0
    config_h_theta_eddy_visc4       = 0.0
    config_v_theta_eddy_visc2       = 0.0
    config_horiz_mixing             = '2d_smagorinsky'
    config_len_disp                 = 3000.0
    config_visc4_2dsmag             = 0.05
    config_w_adv_order              = 3
    config_theta_adv_order          = 3
    config_scalar_adv_order         = 3
    config_u_vadv_order             = 3
    config_w_vadv_order             = 3
    config_theta_vadv_order         = 3
    config_scalar_vadv_order        = 3
    config_scalar_advection         = true
    config_positive_definite        = false
    config_monotonic                = true
    config_coef_3rd_order           = 0.25
    config_epssm                    = 0.1
    config_smdiv                    = 0.1
/
&damping
    config_mpas_cam_coef            = 2.0
    config_rayleigh_damp_u          = true
    config_zd                       = 16000.0
    config_xnutr                    = 0.2
    config_number_cam_damping_levels = 8
/
&limited_area
    config_apply_lbcs                = true
/
&io
    config_pio_num_iotasks           = NNNODE
    config_pio_stride                = NNCORE
/
&decomposition
    config_block_decomp_file_prefix  = '${domname}.graph.info.part.'
/
&restart
    config_do_restart                = ${do_restart}
    config_do_DAcycling              = ${do_dacyle}
/
&printout
    config_print_global_minmax_sca   = true
    config_print_global_minmax_vel   = true
    config_print_detailed_minmax_vel = false
/
&IAU
    config_IAU_option                = 'off'
    config_IAU_window_length_s       = 21600.
/
&physics
    config_sst_update                = false
    config_sstdiurn_update           = false
    config_deepsoiltemp_update       = false
    config_radtlw_interval           = '00:04:00'
    config_radtsw_interval           = '00:04:00'
    config_bucket_update             = 'none'
    config_lsm_scheme                = '${MPASLSM}'
    num_soil_layers                  = ${MPASNFLS}
    config_microp_re                 = true
    config_physics_suite             = 'convection_permitting'
    config_convection_scheme         = 'off'
    config_frac_seaice               = false
    config_pbl_scheme                = '${pblscheme}'
    config_sfclayer_scheme           = '${sfcscheme}'
EOF

        if [[ ${mpscheme} == "mp_nssl2m" ]]; then

            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
/
&nssl_mp_params
    ehw0                             = 0.9
    ehlw0                            = 0.9
    icefallfac                       = 1.5
    snowfallfac                      = 1.25
    iusewetsnow                      = 0
EOF

        fi

        cat << EOF >> namelist.atmosphere
/
&soundings
    config_sounding_interval         = 'none'
/
&assimilation
    config_jedi_da                   = false
/
&development
    config_halo_exch_method          = 'mpas_halo'
/
EOF

        (( icycle_extinvl_hr=icycle_lbcgap/3600 ))
        (( icycle_extinvl_min=(icycle_lbcgap-3600*icycle_extinvl_hr)/60 ))
        icycle_extinvl_str=$(printf "%02d:%02d:00" ${icycle_extinvl_hr} ${icycle_extinvl_min})
        #echo "icycle_extinvl_str=${icycle_extinvl_str},$icycle_extinvl_hr,$icycle_extinvl_min"

        cat << EOF > streams.atmosphere
<streams>
<immutable_stream name="input"
                  type="input"
                  filename_template="${domname}_${memstr}.init.nc"
                  input_interval="initial_only" />

<immutable_stream name="invariant"
                  type="input"
                  filename_template="${domname}.invariant.nc"
                  input_interval="initial_only" />

<immutable_stream name="restart"
                  type="input;output"
                  filename_template="${domname}_${memstr}.restart.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  input_interval="initial_only"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" />

<stream name="output"
                  type="output"
                  filename_template="${domname}_${memstr}.history.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.output"/>
</stream>

<stream name="diagnostics"
                  type="output"
                  filename_template="${domname}_${memstr}.diag.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

    <file name="stream_list.atmosphere.diagnostics"/>
</stream>

<stream name="surface"
                  type="input"
                  filename_template="${domname}_${memstr}.sfc_update.nc"
                  filename_interval="none"
                  input_interval="none" >

    <file name="stream_list.atmosphere.surface"/>
</stream>

<immutable_stream name="iau"
                  type="input"
                  filename_template="${domname}_${memstr}.AmB.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="none"
                  packages="iau"
                  input_interval="initial_only" />

<immutable_stream name="lbc_in"
                  type="input"
                  filename_template="${domname}_${memstr}.lbc.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="input_interval"
                  packages="limited_area"
                  input_interval="${icycle_extinvl_str}" />

</streams>
EOF
        jobarrays+=("$iens")
    done

    cd $wrkdir || return

    #
    # Create job script for MPAS forecast and submit it
    #
    sedfile=$(mktemp -t mpas_${eventtime}.sed_XXXX)
    # shellcheck disable=SC2154
    cat <<EOF > $sedfile
s/PARTION/${partition_fcst}/
s/NOPART/$npefcst/
s/JOBNAME/mpas_${eventtime}/
s/CPUSPEC/${claim_cpu_fcst}/g
s/CLAIMTIME/${claim_time_fcst}/
s#MODULE#${modulename}#g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNMPCMD/${job_runmpexe_str}/
s/SAVETAG/${domname}_??.restart.${fcsttime_fil}.nc/
EOF
    #mpas_jobscript="run_mpas.${mach}"
    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    # shellcheck disable=SC2154
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/${nnodes_fcst}/;s/NCORES/${ncores_fcst}/" >> $sedfile
    fi

    submit_a_jobscript "$wrkdir" "fcst" "$sedfile" "$TEMPDIR/run_mpas_array.${mach}" "$mpas_jobscript" "${jobarraystr}"
}

########################################################################

function da_cycle_driver() {
    #
    #  based on driver_mpas_dart.csh in the DART package
    #
    #  THIS IS A TOP-LEVEL DRIVER SCRIPT FOR CYCLING RUNS.
    #
    #  Required files to run this driver:
    #  1. executables:
    #       filter
    #       update_mpas_states
    #       atmosphere_model
    #
    #  Input files to run this script:
    #  A. input_state_file_list  - a list of input ensemble netcdf files for DART/filter
    #  B. output_state_file_list - a list of output ensemble netcdf files from DART/filter
    #  C. RUN_DIR/member#/${mpas_filename}    - the input file listed in input_state_file_list for each member
    #  D. OBS_DIR/${obs_seq_in}.${YYYYMMDDHH} - obs sequence files for each analysis cycle (YYYYMMDDHH)
    #     for the entire period.
    #
    ##############################################################################################
    # USER SPECIFIED PARAMETERS
    ##############################################################################################
    # $1    $2    $3
    # init start  end
    local init_sec=$1
    local start_sec=$2
    local end_sec=$3

    #
    # Build working directory
    #
    wrkdir=$rundir/dacycles
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg date_end intvl_min n_cycles
    date_beg=$(date -u -d @$start_sec +%Y%m%d%H%M)
    date_end=$(date -u -d @$end_sec +%Y%m%d%H%M)
    intvl_min=$((intvl_sec/60))
    n_cycles=$(( (end_sec-start_sec)/intvl_sec+1 ))

    echo "Total ${n_cycles} cycles from $date_beg to $date_end will be run every $intvl_min minutes."

    local icyc=$(( (start_sec-init_sec)/intvl_sec ))
    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date -u -d @$isec +%H%M)

        if [[ ${run_updatebc} == true ]]; then
            min_passhr=$(date -u -d @$isec +%M)
            icycle_lbcgap=$(( EXTINVL-(min_passhr*60) ))             # Seconds to next available boundary time
        else
            icycle_lbcgap=${EXTINVL}
        fi

        dawrkdir=${wrkdir}/${eventtime}
        mkwrkdir $dawrkdir 0    # keep original directory
        cd $dawrkdir || return

        echo ""
        echo "- Cycle $icyc at ${timestr_curr}"
        time1=$(date +%s)

        #------------------------------------------------------
        # 0. Check forecast status of the early cycle or inital boundary status
        #------------------------------------------------------
        if [[ $dorun == true ]]; then
            if [[ $icyc -eq 0 ]]; then
                if [[ ! -e $rundir/lbc/done.lbc ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "lbc" $rundir/lbc $nenslbc run_lbc.${mach} 0
                fi
            else   #if [[ $icyc -gt 0 ]]; then
                timesec_pre=$((isec-intvl_sec))
                event_pre=$(date -u -d @$timesec_pre  +%H%M)
                wrkdir_pre=${wrkdir}/${event_pre}
                if [[ ! -e ${wrkdir_pre}/done.fcst ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "fcst" $wrkdir_pre $ENS_SIZE run_mpas.${mach} 0
                fi
            fi
        fi

        #------------------------------------------------------
        # 1. Run filter
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " filter " ]]; then
            if [[ $verb -eq 1 ]]; then echo ""; echo "    Run filter at $eventtime"; fi
            run_filter $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 2. Run update_states for all ensemble members
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " update_states " ]]; then
            if [[ $icyc -eq 0 ]]; then
                touch $dawrkdir/done.update_states
            else
                if [[ $verb -eq 1 ]]; then echo ""; echo "    Run update_mpas_state at $eventtime"; fi
                run_update_states $dawrkdir $isec
            fi
        fi

        #------------------------------------------------------
        # 3. Add noise
        #------------------------------------------------------
        if [[ $run_addnoise == true ]]; then

            if [[ $icyc -eq 0 ]]; then
                touch $dawrkdir/done.add_noise
            else
                # check and set update_states status
                if [[ $dorun == true ]]; then
                    if [[ ! -e done.update_states ]]; then
                        #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                        check_and_resubmit "update_states fcst_" $dawrkdir $ENS_SIZE run_update_states.${mach} 1
                    fi
                fi

                if [[ $verb -eq 1 ]]; then echo ""; echo "    Run add_noise at $eventtime"; fi
                run_add_noise $dawrkdir $isec
            fi
        fi

        #------------------------------------------------------
        # 4. Run update_bc for all ensemble members
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " update_bc " ]]; then
            if [[ $dorun == true ]]; then
                if [[ ${run_addnoise} == true ]]; then   # check and set add_noise status
                    if [[ ! -e done.add_noise ]]; then
                        #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                        check_and_resubmit "add_noise fcst_" $dawrkdir $ENS_SIZE run_noise_pert.${mach} 0
                    fi
                else                                     # check and set update_states status
                    if [[ ! -e done.update_states ]]; then
                        #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                        check_and_resubmit "update_states fcst_" $dawrkdir $ENS_SIZE run_update_states.${mach} 0
                    fi
                fi
            fi

            if [[ $verb -eq 1 ]]; then echo ""; echo "    Run update_bc at $eventtime"; fi
            run_update_bc $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 5. Advance model for each member
        #------------------------------------------------------
        # Run forecast for ensemble members until the next analysis time
        if [[ " ${jobs[*]} " =~ " mpas " ]]; then
            # check and set update_bc status
            if [[ $dorun == true ]]; then
                if [[ ! -e done.update_bc ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "update_bc fcst_" $dawrkdir $ENS_SIZE run_update_bc.${mach} 0
                fi
            fi

            if [[ $verb -eq 1 ]]; then echo ""; echo "    Run advance model at $eventtime"; fi

            mpas_jobscript="run_mpas.${mach}"
            run_mpas $dawrkdir $icyc $isec

            if [[ $dorun == true ]]; then
                if [[ ! -e done.fcst ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-3}
                    check_and_resubmit "fcst" $dawrkdir $ENS_SIZE $mpas_jobscript 2
                fi
            fi
        fi

        #------------------------------------------------------
        # This DA cycle is done
        #------------------------------------------------------
        time2=$(date +%s)
        if [[ $time2 -gt $time1 ]]; then
            (( secoffset = time2-time1 )); (( minoffset = secoffset/60 )); (( secoffset = secoffset%60 ))
            echo "= Cycle ${eventtime} took ${minoffset}:${secoffset} minutes:seconds."
        fi

        (( icyc+=1 ))
    done
}

########################################################################

function run_obs_diag {
    # $1     $2
    # start  end
    local start_sec=$1
    local end_sec=$2

    #
    # Build working directory
    #
    dawrkdir=$rundir/dacycles
    if [[ ! -d $dawrkdir ]]; then
        echo "ERROR: $dawrkdir not exsit."
        exit 1
    fi
    wrkdir=$dawrkdir/obs_diag
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg_str_4obsdiag date_end_str_4obsdiag intvl_min n_cycles
    date_beg_str_4obsdiag=$(date -u -d @$start_sec +%Y,%m,%d,%H,%M,%S)
    date_end_str_4obsdiag=$(date -u -d @$end_sec +%Y,%m,%d,%H,%M,%S)
    intvl_min=$((intvl_sec/60))
    date_intvl_str_4obsdiag="0, 0, 0,00,${intvl_min},00"

    n_cycles=$(( (end_sec-start_sec)/intvl_sec+1 ))

    timestr_end=$(date -u -d @$end_sec    +%H%M)
    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.obs_diag || -f $wrkdir/done.obs_diag || -f $wrkdir/queue.obs_diag ]]; then
        return
    fi

    #------------------------------------------------------
    # Prepare obs_diag
    #------------------------------------------------------
    #obs_final_files1=$(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    #obs_final_files2=$(find $dawrkdir/0???    -name obs_seq.final | sort)
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/0???    -name obs_seq.final | sort)
    obs_final_files=("${obs_final_files1[@]}" "${obs_final_files2[@]}")

    printf "%s\n" "${obs_final_files[@]}" > obs_seq.final.list

    #
    # Waiting for job conditions
    #

    if [[ ${#obs_final_files[@]} -ne ${n_cycles} ]]; then
        echo "ERROR: found  ${#obs_final_files[@]} \"obs_seq.final\" files, expected ${n_cycles}."
        exit 1
    fi

    cp $dawrkdir/${timestr_end}/input.nml .

    sedfile=$(mktemp -t obsdiag_nml.sed_XXXX)

    cat <<EOF > $sedfile
/obs_sequence_list/c   obs_sequence_list  = 'obs_seq.final.list'
/obs_sequence_name/c   obs_sequence_name  = ''
/first_bin_center/c    first_bin_center   = ${date_beg_str_4obsdiag}
/last_bin_center/c     last_bin_center    = ${date_end_str_4obsdiag}
/bin_width/c           bin_width          = ${date_intvl_str_4obsdiag}
/bin_separation/c      bin_separation     = ${date_intvl_str_4obsdiag}
EOF
    sed -f $sedfile -i input.nml

    #------------------------------------------------------
    # Run obs_diag for all analysis
    #------------------------------------------------------

    #
    # Create job script and submit it
    #
    jobscript="run_obs_diag.${mach}"
    sedfile=$(mktemp -t obsdiag_${timestr_end}.sed_XXXX)
    cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/1/
s/JOBNAME/obsdiag_${eventdate:4:4}/
s/CPUSPEC/${claim_cpu_update}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNCMD/${job_runexe_str}/
s/EXENAME/obs_diag/
s/PRONAME/obs_diag/g

EOF
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
    fi

    submit_a_jobscript "$wrkdir" "obs_diag" "$sedfile" "$TEMPDIR/$jobscript" "$jobscript" ""
}

########################################################################

function run_obs_final2nc {
    # $1     $2
    # start  end
    local start_sec=$1
    local end_sec=$2

    #
    # Build working directory
    #
    dawrkdir=$rundir/dacycles
    if [[ ! -d $dawrkdir ]]; then
        echo "ERROR: $dawrkdir not exsit."
        exit 1
    fi
    wrkdir=$dawrkdir/obs_diag
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------

    n_cycles=$(( (end_sec-start_sec)/intvl_sec ))

    timestr_end=$(date -u -d @$end_sec    +%H%M)
    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.obs_final2nc || -f $wrkdir/done.obs_final2nc || -f $wrkdir/queue.obs_final2nc ]]; then
        return
    fi

    #------------------------------------------------------
    # Prepare obs_diag
    #------------------------------------------------------
    #obs_final_files1=$(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    #obs_final_files2=$(find $dawrkdir/0??? -name obs_seq.final | sort)
    #obs_final_files=("${obs_final_files1[@]}" "${obs_final_files2[@]}")
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/0???    -name obs_seq.final | sort)
    obs_final_files=("${obs_final_files1[@]}" "${obs_final_files2[@]}")

    #
    # Waiting for job conditions
    #

    if [[ ${#obs_final_files[@]} -lt ${n_cycles} ]]; then
        echo "ERROR: found  ${#obs_final_files[@]} \"obs_seq.final\" files, expected ${n_cycles}."
        exit 1
    fi

    cp $dawrkdir/${timestr_end}/input.nml .

    #------------------------------------------------------
    # Run obs_diag for all analysis
    #------------------------------------------------------
    #    echo "    Running ${exedir}/dart/obs_seq_to_netcdf"
    #    ${runcmd_str} ${exedir}/dart/obs_seq_to_netcdf >& $srunout
    #    mv obs_epoch_001.nc obs_seq.final.${timestr_cur}.nc
    #
    # Create job script and submit it
    #
    jobscript="run_obs_final2nc.${mach}"
    sedfile=$(mktemp -t obs_final2nc.sed_XXXX)
    cat <<EOF > $sedfile
s/PARTION/${partition_filter}/
s/NOPART/1/
s/JOBNAME/obsdiag_${eventdate:4:4}/
s/CPUSPEC/${claim_cpu_update}/g
s/MODULE/${modulename}/g
s#ROOTDIR#$rootdir#g
s#WRKDIR#$wrkdir#g
s#EXEDIR#${exedir}/dart#
s/MACHINE/${machine}/g
s/ACCTSTR/${job_account_str}/
s/EXCLSTR/${job_exclusive_str}/
s/RUNCMD/${job_runexe_str}/
s/START_S/${start_sec}/g
s/END_S/${end_sec}/g
s/INTVL_S/${intvl_sec}/g
s#DACYCLEDIR#${dawrkdir}#
EOF
    if [[ "${mach}" == "pbs" ]]; then
        echo "s/NNODES/1/;s/NCORES/1/" >> $sedfile
    fi

    submit_a_jobscript $wrkdir "obs_final2nc" $sedfile $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function run_clean {
    # $1    $2    $3
    # start  end
    local start_sec=$1
    local end_sec=$2

    local isec

    wrkdir=$rundir/dacycles

    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date -u -d @$isec +%H%M)

        dawrkdir=$wrkdir/$eventtime
        if [[ -d $dawrkdir ]]; then
            cd $dawrkdir || return

            if [[ $verb -eq 1 ]]; then echo "    Cleaning working directory $dawrkdir"; fi

            for dirname in mpas filter update_states update_bc; do

                cd $dawrkdir || return

                case $dirname in
                mpas )
                    rm -f error.fcst_* log.????.abort
                    rm -f log.atmosphere.????.out log.atmosphere.????.err #fcst_*_*.log
                    #if [[ $verb -eq 1 ]]; then echo "    clean mpas in $dawrkdir"; fi
                    #clean_mem_runfiles "fcst" $dawrkdir $ENS_SIZE
                    ;;
                filter )
                    if [[ -e done.filter ]]; then
                        rm -f error.filter dart_log.nml dart_log.out obs_seq_to_netcdf.log #filter_*.log
                        find OBSDIR -type f -not -name "obs_seq.${timestr_curr}" -exec rm -f {} \;
                    fi
                    ;;
                update_states )
                    if [[ -e done.update_states ]]; then
                        rm -f error.update_states #update_states_*.log
                    fi
                    ;;
                update_bc )
                    if [[ -e done.update_bc ]]; then
                        rm -f error.update_bc #update_bc_*.log
                    fi
                    ;;
                esac
            done
        fi
    done
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
# Default Settings
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#@ MAIN

WORKDIR="${rootdir}/run_dirs"
TEMPDIR="${rootdir}/templates"
FIXDIR="${rootdir}/fix_files"

eventdate="$eventdateDF"
eventtime="1500"
initdatetime=""
enddatetime=""

domname="wofs_mpas"
mpscheme="mp_nssl2m"

verb=0
overwrite=0
runcmd="sbatch"
dorun=true
rt_run=false            # realtime run?

machine="Jet"

myhostname=$(hostname)
if [[ "${myhostname}" == ln? ]]; then
    machine="Vecna"
elif [[ "${myhostname}" == hercules* ]]; then
    machine="Hercules"
elif [[ "${myhostname}" == cheyenne* || "${myhostname}" == derecho* ]]; then
    machine="Cheyenne"
else
    machine="Jet"
fi

jobs=(filter update_states update_bc mpas clean)

source $scpdir/Common_Utilfuncs.sh || exit $?

#-----------------------------------------------------------------------
#
# Handle command line arguments (override default settings)
#
#-----------------------------------------------------------------------
#% ARGS

while [[ $# -gt 0 ]]; do
    key="$1"

    case $key in
        -h)
            usage 0
            ;;
        -n)
            dorun=false
            ;;
        -v)
            verb=1
            ;;
        -r)
            rt_run=true
            ;;
        -k)
            if [[ $2 =~ [012] ]]; then
                overwrite=$2
                shift
            else
                echo "ERROR: option for '-k' can only be [0-2], but got \"$2\"."
                usage 1
            fi
            ;;
        -t)
            if [[ -d $2 ]]; then
                TEMPDIR=$2
            else
                echo "ERROR: Template directory \"$2\" does not exist."
                usage 1
            fi
            shift
            ;;
        -m)
            if [[ ${2^^} == "JET" ]]; then
                machine=Jet
            elif [[ ${2^^} == "VECNA" ]]; then
                machine=Vecna
            elif [[ ${2^^} == "HERCULES" ]]; then
                machine=Hercules
            elif [[ ${2^^} == "CHEYENNE" || ${2^^} == "DERECHO" ]]; then
                machine=Cheyenne
            else
                echo "ERROR: Unsupported machine name, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -d)
            domname=$2
            shift
            ;;
        -i)
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                initdatetime=$2
            else
                echo "ERROR: Initial time should be YYYYmmddHHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -s )
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                eventtime=${2:8:4}
                eventhour=${2:8:2}
                if [[ $((10#$eventhour)) -lt 12 ]]; then
                    eventdate=$(date -u -d "${2:0:8} 1 day ago" +%Y%m%d)
                else
                    eventdate=${2:0:8}
                fi
            elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                eventtime="${2}"
            else
                echo "ERROR: Start time should be in YYYYmmddHHMM or HHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -e )
            if [[ $2 =~ ^[0-9]{12}$ ]]; then
                enddatetime=$2
            elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                endhrmin=$2
                endhour=${endhrmin:0:2}
                if [[ $((10#$endhour)) -lt 12 ]]; then
                    enddatetime=$(date -u -d "$eventdate $endhrmin 1 day" +%Y%m%d%H%M)
                else
                    enddatetime=$(date -u -d "$eventdate $endhrmin" +%Y%m%d%H%M)
                fi
            else
                echo "ERROR: End time should be in YYYYmmddHHMM or HHMM, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -p)
            if [[ ${2^^} == "NSSL" ]]; then
                mpscheme="mp_nssl2m"
            elif [[ ${2^^} == "THOMPSON" ]]; then
                mpscheme="Thompson"
            else
                echo "ERROR: Unsupported MP scheme name, got \"$2\"."
                usage 1
            fi
            shift
            ;;
        -*)
            echo "Unknown option: $key"
            usage 2
            ;;
        filter* | mpas* | update_states* | update_bc* | clean* | obs_diag* | obs_final2nc )
            #jobs=(${key//,/ })
            IFS="," read -r -a jobs <<< "$key"
            ;;
        *)
            if [[ $key =~ ^[0-9]{12}$ ]]; then
                enddatetime=${key}
                eventtime=${key:8:4}
                eventhour=${key:8:2}
                if [[ $((10#$eventhour)) -lt 12 ]]; then
                    eventdate=$(date -u -d "${key:0:8} 1 day ago" +%Y%m%d)
                else
                    eventdate=${key:0:8}
                fi
            elif [[ $key =~ ^[0-9]{8}$ ]]; then
                eventdate=${key}
            elif [[ $key =~ ^[0-9]{4}$ ]]; then
                eventtime=${key}
            elif [[ -d $key ]]; then
                WORKDIR=$key
                lastdir=$(basename $WORKDIR)
                if [[ $lastdir =~ ^[0-9]{8}$ ]]; then
                    WORKDIR=$(dirname ${WORKDIR})
                    eventdate=${lastdir}
                elif [[ $lastdir =~ ^[0-9]{12}$ ]]; then
                    WORKDIR=$(upnlevels ${WORKDIR} 3)
                    eventdate=${lastdir:0:8}
                    eventtime=${lastdir:8:4}
                    eventhour=${lastdir:8:2}
                    if [[ $eventhour -lt 12 ]]; then
                        eventdate=$(date -u -d "$eventdate 1 day ago" +%Y%m%d)
                    fi
                fi
                #echo $WORKDIR,$eventdate,$eventtime
            else
                echo ""
                echo "ERROR: unknown argument, get [$key]."
                usage 3
            fi
            ;;
    esac
    shift # past argument or value
done

eventhour=${eventtime:0:2}
if [[ $eventhour -lt 12 ]]; then
    startday="1 day"
else
    startday=""
fi

if [[ "$initdatetime" == "" ]]; then
    initdatetime="${eventdate}1500"
fi

if [[ "$enddatetime" == "" ]]; then
    enddatetime=$(date -u -d "$eventdate 03:00 1 day" +%Y%m%d%H%M)
fi

inittime_sec=$(date -u -d "${initdatetime:0:8} ${initdatetime:8:4}" +%s)
starttime_sec=$(date -u -d "$eventdate ${eventtime} $startday"      +%s)
stoptime_sec=$(date -u -d "${enddatetime:0:8}  ${enddatetime:8:4}"  +%s)

#
# read configurations that is not set from command line
#
if [[ ! -r $WORKDIR/config.${eventdate} ]]; then
    echo "ERROR: Configuration file $WORKDIR/config.${eventdate} is not found. Please run \"setup_mpas-wofs_grid.sh\" first."
    exit 2
fi
readconf $WORKDIR/config.${eventdate} COMMON dacycles || exit $?
# get ENS_SIZE, time_step, EXTINVL, ADAPTIVE_INF, update_in_place

#first_cycle_sec=$((inittime_sec+intvl_sec))
#frsttime_str=$(date -u -d @${first_cycle_sec} +%Y-%m-%d_%H.%M.%S)
#inittime_str=$(date -u -d @${inittime_sec} +%H%M)

#-----------------------------------------------------------------------
#
# Handle machine specific configuraitons
#
#-----------------------------------------------------------------------
#% PLATFORM

if [[ $machine == "Jet" ]]; then
    modulename="build_jet_Rocky8_intel_smiol"

    source /etc/profile.d/modules.sh
    module purge
    module use ${rootdir}/modules
    module load ${modulename}
elif [[ $machine == "Hercules" ]]; then
    modulename="build_hercules_intel"

    module purge
    module use ${rootdir}/modules
    module load ${modulename}
elif [[ $machine == "Cheyenne" ]]; then
    runcmd="qsub"

    modulename="defaults"
else    # Vecna at NSSL
    modulename="env.mpas_smiol"
    source /usr/share/Modules/init/bash
    source ${rootdir}/modules/${modulename}

    # Load Python Enviroment if necessary
    if [[ ${run_trimvr} == true || ${run_addnoise} == true ]]; then
        echo "Enabling Python micromamba environment - wofs_an ...."
        source /home/yunheng.wang/.pythonrc  || exit $?
    fi
fi

if [[ $dorun == false ]]; then
    runcmd="echo $runcmd"
fi

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Perform DA cycles
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#% ENTRY

rundir="$WORKDIR/${eventdate}"
if [[ ! -d $rundir ]]; then
    mkdir -p $rundir
fi

exedir="$rootdir/exec"

echo ""
echo "---- Jobs ($$) started $(date +%m-%d_%H:%M:%S) on host $(hostname) ----"
echo "     Event date : $eventdate ${eventtime}"
echo "     Root    dir: $rootdir"
echo "     Working dir: $WORKDIR"
echo "     Domain name: $domname;  MP scheme: ${mpscheme}"
echo " "

RSTINVL_STR=$(printf "00:%02d:00" $((intvl_sec/60)) )
OUTINVL_STR="1:00:00"                    # turn off history/diag outputs

#
# Start the data assimilation cycles
#

# $1    $2    $3
# init start  end
if [[ " ${jobs[*]} " =~ " "(filter|mpas|update_states|update_bc)" " ]]; then
    da_cycle_driver $inittime_sec $starttime_sec $stoptime_sec
elif [[ " ${jobs[*]} " =~ " "(obs_diag|obs_final2nc)" " ]]; then
    if [[ ${starttime_sec} -le ${inittime_sec} ]]; then
        begin_sec=$((starttime_sec+intvl_sec))
    else
        begin_sec=${starttime_sec}
    fi

    for job in "${jobs[@]}"; do
        run_${job} ${begin_sec} ${stoptime_sec}
    done
elif [[ " ${jobs[*]} " =~ " clean " ]]; then
    run_clean $starttime_sec $stoptime_sec
fi

echo " "
echo "==== Jobs done $(date +%m-%d_%H:%M:%S) ===="
echo " "

exit 0
