#!/bin/bash
# shellcheck disable=SC2317,SC1090,SC1091,SC2086,SC2154

scpdir="$( cd "$( dirname "$0" )" && pwd )"              # dir of script
rootdir=$(realpath "$(dirname "${scpdir}")")

mpasdir="/scratch/yunheng.wang/MPAS/MPAS_PROJECT"

eventdateDF=$(date -u +%Y%m%d)
eventtimeDF="1500"

#-----------------------------------------------------------------------
#
# This is the 4th step of th WOFS-MPAS workflow. It run program filter,
# update_mpas_states, and atmosphere_model to perform the DA cycles and the forward forecasting.
#
# Required files from ROOTDIR
#
# 0. module files in modules
#     build_jet_Rocky8_intel_smiol
#     env.mpas_smiol
#
# 1. exec                                   # The executables
#     atmosphere_model
#     filter
#     update_mpas_states
#     update_bc
#
# 2. templates                              # templates used in this scripts
#    README
#
#    2.1 SLURM scripts on Jet
#        run_filter.slurm                    or run_filter.pbs
#        run_mpas_array.slurm                or run_mpas_array.pbs
#        run_update_states.slurm             or run_update_states.pbs
#        run_update_sbc.slurm                or run_update_bc.pbs
#
# 3. fix_files                              # runtime fix files for MPAS model and accompany programs
#
#    3.1 tables for Thompson cloud microphysics scheme
#        *MP_THOMPSON_QIautQS_DATA.DBL
#        *MP_THOMPSON_QRacrQG_DATA.DBL
#        *MP_THOMPSON_QRacrQS_DATA.DBL
#        *MP_THOMPSON_freezeH2O_DATA.DBL
#        CCN_ACTIVATE.BIN
#
#        Can be generated by submitting job script templates/build_tables.slurm
#
#    3.2 MPASS run-time static files
#        stream_list.atmosphere.diagnostics_da
#        stream_list.atmosphere.output
#        stream_list.atmosphere.surface
#
#        *CAM_ABS_DATA.DBL
#        *CAM_AEROPT_DATA.DBL
#        *GENPARM.TBL
#        *LANDUSE.TBL
#        *OZONE_DAT.TBL
#        *OZONE_LAT.TBL
#        *OZONE_PLEV.TBL
#        *RRTMG_LW_DATA
#        *RRTMG_LW_DATA.DBL
#        *RRTMG_SW_DATA
#        *RRTMG_SW_DATA.DBL SOILPARM.TBL
#        *VEGPARM.TBL
#
#    3.3 DART filter static files
#        *sampling_error_correction_table.nc
#
#    NOTE:
#         * not in the git repository
#
# INSTRUCTIONS:
#
#  Use an existing domain (wofs_mpas)
#
#     0. It should be run after "setup_mpas-wofs.sh", "make_ics.sh" & "make_lbc.sh"
#
#     1. Copy these directories to rootdir (or clone using git)
#        modules
#        exec
#        scripts
#        templates
#        fix_files (link needed files use script lnwrkfiles.sh, see README in that directory)
#
#     2. run_dacycles.sh [YYYYmmddHH] [run_dirs] [jobnames]
#        Option "-h" gives a brief instruction about all the available options
#
# HOW THE CLEAN COMMAND WORKS:
#
#     1. By default "clean" will only delete working files, log files and
#        intermediated files for each task (both filter and mpas), but leave
#        the output file from these tasks as is.
#     2. "-c" option will delete the output files from this task, but
#        leave the runtime file and job script. So that user can run this
#        task again manually. By default it works for both tasks (filter and mpas),
#        if a task name is given, it will clean that task only.
#     3. "-a" option will clean the whole work directory for the corresponding task.

#-----------------------------------------------------------------------

function usage {
    echo " "
    echo "    USAGE: $0 [options] DATETIME [WORKDIR] [JOBS]"
    echo " "
    echo "    PURPOSE: Run MPAS-WOFS DA cycles."
    echo " "
    echo "    DATETIME - Case date and time in YYYYmmdd/YYYYmmddHHMM, Default eventdate is ${eventdateDF}."
    echo "               YYYYmmdd:     run all cycles from $eventtimeDF to 0300 UTC. Or use options \"-s\" & \"-e\" to specify cycles."
    echo "               YYYYmmddHHMM: run this DA cycle only."
    echo "    WORKDIR  - Run Directory"
    echo "    JOBS     - One or more jobs from [filter,update_states,update_bc,mpas,obs_diag,obs_final2nc,clean]"
    echo "               Default all jobs in [filter,update_states,update_bc,mpas] for a DA cyle"
    echo " "
    echo "    OPTIONS:"
    echo "              -h                  Display this message"
    echo "              -n                  Show command to be run and generate job scripts only"
    echo "              -v                  Verbose mode"
    echo "              -k  [0,1,2]         Keep working directory if exist, 0- keep as is; 1- overwrite; 2- make a backup as xxxx.bak?"
    echo "                                  Default is 0 for ungrib, mpassit, upp and 1 for others"
    echo "              -m  Machine         Machine name to run on, [Jet, Cheyenne, Vecna]."
    echo "              -a/-c/-d            Works with the Clean command only, accept one argument {filter,mpas} or nothing."
    echo "                                  Default (Nothing): Deletes output files (log/standard output, etc.) only."
    echo "                                  -a: Deep clean of the whole working directory"
    echo "                                  -c: Delete output (netCDF) files from the specific task but keep done files."
    echo "                                  -d: Delete all done files"
    echo "              -i  YYYYmmddHHMM    Initial time, default: ${eventdateDF}$eventtimeDF UTC."
    echo "              -s  YYYYmmddHHMM    Start date & time of the DA cycles."
    echo "                  HHMM            Start time of the DA cycles."
    echo "              -e  YYYYmmddHHMM    End date & time of the DA cycles."
    echo "                  HHMM            End time of the DA cycles."
    echo "              -r                  Realtime run, will wait for observations, default: research mode (no waiting)."
    echo "              -f conf_file        Configuration file for this case. Default: \${WORKDIR}/config.\${eventdate}"
    echo " "
    echo "   DEFAULTS:"
    echo "              eventdt = $eventdateDF"
    echo "              rootdir = $rootdir"
    echo "              WORKDIR = $mpasdir/run_dirs"
    echo " "
    echo "                                     -- By Y. Wang (2023.05.31)"
    echo " "
    exit "$1"
}

########################################################################
#
# Handle command line arguments
#
########################################################################

function parse_args {

    declare -Ag args

    #-------------------------------------------------------------------
    # Parse command line arguments
    #-------------------------------------------------------------------

    while [[ $# -gt 0 ]]; do
        key="$1"

        case $key in
            -h)
                usage 0
                ;;
            -n)
                args["dorun"]=false
                ;;
            -v)
                args["verb"]=1
                ;;
            -r)
                args["rt_run"]=true
                ;;
            -k)
                if [[ $2 =~ [012] ]]; then
                    args["overwrite"]=$2
                    shift
                else
                    echo -e "${RED}ERROR${NC}: option for ${BLUE}-k${NC} can only be [${YELLOW}0-2${NC}], but got ${PURPLE}$2${NC}."
                    usage 1
                fi
                ;;
            -c | -a | -d )
                args["cleanoption"]="$key"
                if [[ "$2" == "filter" || "$2" == "mpas" ]]; then
                    args["cleanjobs"]+=" $2"
                    shift
                fi
                ;;
            -m)
                if [[ ${2^^} == "JET" ]]; then
                    args["machine"]=Jet
                elif [[ ${2^^} == "VECNA" ]]; then
                    args["machine"]=Vecna
                elif [[ ${2^^} == "HERCULES" ]]; then
                    args["machine"]=Hercules
                elif [[ ${2^^} == "CHEYENNE" || ${2^^} == "DERECHO" ]]; then
                    args["machine"]=Cheyenne
                else
                    echo -e "${RED}ERROR${NC}: Unsupported machine name, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -f)
                args["config_file"]="$2"
                shift
                ;;
            -i)
                if [[ $2 =~ ^[0-9]{12}$ ]]; then
                    args["initdatetime"]=$2
                else
                    echo -e "${RED}ERROR${NC}: Initial time should be ${GREEN}YYYYmmddHHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -s )
                if [[ $2 =~ ^[0-9]{12}$ ]]; then
                    args["eventtime"]=${2:8:4}
                    eventhour=${2:8:2}
                    if ((10#$eventhour < 12)); then
                        args["eventdate"]=$(date -u -d "${2:0:8} 1 day ago" +%Y%m%d)
                    else
                        args["eventdate"]=${2:0:8}
                    fi
                elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                    args["eventtime"]="${2}"
                else
                    echo -e "${RED}ERROR${NC}: Start time should be in ${GREEN}YYYYmmddHHMM${NC} or ${GREEN}HHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -e )
                if [[ $2 =~ ^[0-9]{12}$ ]]; then
                    args["enddatetime"]=$2
                elif [[ $2 =~ ^[0-9]{4}$ ]]; then
                    args["endhrmin"]=$2
                else
                    echo -e "${RED}ERROR${NC}: End time should be in ${GREEN}YYYYmmddHHMM${NC} or ${GREEN}HHMM${NC}, got ${PURPLE}$2${NC}."
                    usage 1
                fi
                shift
                ;;
            -*)
                echo -e "${RED}ERROR${NC}: Unknown option: ${PURPLE}$key${NC}"
                usage 2
                ;;
            filter* | mpas* | update_states* | update_bc* | clean* | obs_diag* | obs_final2nc )
                args["jobs"]="${key//,/ }"
                ;;
            *)
                if [[ $key =~ ^[0-9]{12}$ ]]; then
                    args["enddatetime"]=${key}
                    args["eventtime"]=${key:8:4}
                    eventhour=${key:8:2}
                    if ((10#$eventhour < 12)); then
                        args["eventdate"]=$(date -u -d "${key:0:8} 1 day ago" +%Y%m%d)
                    else
                        args["eventdate"]=${key:0:8}
                    fi
                    args["endhrmin"]=${key:8:4}
                elif [[ $key =~ ^[0-9]{8}$ ]]; then
                    args["eventdate"]=${key}
                elif [[ $key =~ ^[0-9]{4}$ ]]; then
                    args["eventtime"]=${key}
                elif [[ -d $key ]]; then
                    WORKDIR=$key
                    lastdir=$(basename $WORKDIR)
                    if [[ $lastdir =~ ^[0-9]{8}$ ]]; then
                        args["WORKDIR"]=$(dirname ${WORKDIR})
                        args["eventdate"]=${lastdir}
                    elif [[ $lastdir =~ ^[0-9]{12}$ ]]; then
                        args["WORKDIR"]=$(upnlevels ${WORKDIR} 3)
                        args["eventdate"]=${lastdir:0:8}
                        args["eventtime"]=${lastdir:8:4}
                        eventhour=${lastdir:8:2}
                        if ((10#$eventhour < 12)); then
                            args["eventdate"]=$(date -u -d "args['eventdate'] 1 day ago" +%Y%m%d)
                        fi
                    else
                        args["WORKDIR"]=$WORKDIR
                    fi
                    #echo $WORKDIR,$eventdate,$eventtime
                else
                    echo  -e "${RED}ERROR${NC}: unknown argument, get ${PURPLE}$key${NC}."
                    usage 3
                fi
                ;;
        esac
        shift # past argument or value
    done
}

########################################################################

function run_obsmerge {
    # $1        $2          $3
    # wrkdir    iseconds    seqfilename
    local wrkdir=$1               # DA directory for this cycle
    local iseconds=$2

    if [[ ! -d $wrkdir ]]; then
        mecho0 "run_obsmerge: Working directory $wrkdir not exist"
        exit 1
    fi

    anlys_date=$(date -u -d @$iseconds  +%Y%m%d)
    anlys_time=$(date -u -d @$iseconds  +%H%M)

    srunout="output.srun"

    read -r -a g_dates < <(convertS2days "${iseconds}")
    g_date=${g_dates[0]}
    g_sec=${g_dates[1]}
    #echo $g_date, $g_sec

    mkwrkdir $wrkdir/OBSDIR 1     # 0: Keep existing directory as is
                                  # 1: Remove existing same name directory
    cd $wrkdir/OBSDIR || exit $?

    #-------------------------------------------------------------------
    #
    # Run MPAS_DART_OBS_PREPROCESS for each observation type
    # and get an array "obsflists"
    #
    #-------------------------------------------------------------------

    rm -fr obsflist.bufr obsflist.meso obsflist.sat obsflist.mrms obsflist.radvr obsflist obs_seq.*

    obspreprocess=${EXEDIR}/dart/mpas_dart_obs_preprocess

    input_base="${wrkdir}/input.nml"

    mecho0 "OBS Preprocessing for analysis time: ${anlys_time}, days: ${g_date}, seconds: ${g_sec}"
    mecho0 "OBS_DIR=${BLUE}${OBS_DIR}${NC}"

    obsflists=()
    k=1

    #=================================================
    # PREPROCESS NCEP PrepBufr DATA
    #=================================================
    #1. PrepBufr

    if [[ "${anlys_time:2:2}" == "00" ]]; then

    bufr_file="${OBS_DIR}/Bufr/obs_seq_bufr.${anlys_date}${anlys_time:0:2}"
        if [[ $rt_run == true && ${use_BUFR} == true ]]; then
        if [[ ! -e ${bufr_file} ]]; then
            echo "    Waiting for ${bufr_file##"${OBS_DIR}"/} ...."
        fi
        while [[ ! -e ${bufr_file} ]]; do
            if [[ -e "${bufr_file}.missed" ]]; then
                echo "    Not found. Skip ${bufr_file##"${OBS_DIR}"/} ...."
                break
            fi
            sleep 10
        done
    fi

    if [[ -e ${bufr_file} ]]; then
        echo -e "    ${PURPLE}$((k++))${NC}: Using PrepBufr observations in ${LIGHT_BLUE}${bufr_file##"${OBS_DIR}"/}${NC}"
        #echo "${bufr_file}" > obsflist.bufr
        #obsflists+=(obsflist.bufr)

        cp ${bufr_file} ./obs_seq.old

        sed "/obsdistbdy/s/=.*/= 90000/;/obs_boundary/s/=.*/= 21000/" ${input_base} > input.nml

        if [[ $verb -eq 1 ]]; then
            mecho0 "Run command ${obspreprocess} with parameters: \"${g_date} ${g_sec}\""
        fi

        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                                          >& ${srunout}_BUFR

        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_BUFR 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.bufr

            rm ./obs_seq.old
            mv input.nml input.nml.BUFR

            echo $wrkdir/OBSDIR/obs_seq.bufr > obsflist.bufr

            obsflists+=(obsflist.bufr)
        else
            mecho0 "${RED}ERROR${NC}: command ${BROWN}${obspreprocess}${NC} for PREPBUFR data"
        fi
    else
            echo "    PrepBufr data not found: ${bufr_file##"${OBS_DIR}"/}"
        fi
    fi

    #=================================================
    # PREPROCESS OK MESONET DATA
    #=================================================
    #2. MESONET

    meso_file="${OBS_DIR}/Mesonet/obs_seq_okmeso.${anlys_date}${anlys_time}"
    if [[ $rt_run == true && ${use_MESO} == true ]]; then
        if [[ ! -e ${meso_file} ]]; then
            echo "    Waiting for ${meso_file##"${OBS_DIR}"/} ...."
        fi
        while [[ ! -e ${meso_file} ]]; do
            if [[ -e "${meso_file}.missed" ]]; then
                echo "    Not found. Skip ${meso_file##"${OBS_DIR}"/} ...."
                break
            fi
            sleep 10
        done
    fi

    if [[ -e ${meso_file} ]]; then
        echo -e "    ${PURPLE}$((k++))${NC}: Using Mesonet observations in ${LIGHT_BLUE}${meso_file##"${OBS_DIR}"/}${NC}"
        #echo "${meso_file}" > obsflist.meso
        #obsflists+=(obsflist.meso)

        cp ${meso_file} ./obs_seq.old

        sed "/obsdistbdy/s/=.*/= 15000/;/obs_boundary/s/=.*/= 5000/" ${input_base} > input.nml

        if [[ $verb -eq 1 ]]; then
            mecho0 "Run command ${BROWN}${obspreprocess}${NC} with parameters: ${BLUE}${g_date} ${g_sec}${NC}"
        fi
        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                                          >& ${srunout}_MESO

        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_MESO 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.meso
            mv input.nml input.nml.MESO
            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.meso > obsflist.meso

            obsflists+=(obsflist.meso)
        else
            mecho0 "${RED}ERROR${NC}: command ${BROWN}${obspreprocess}${NC} for MESONET data"
        fi
    else
        if [[ ${use_MESO} == true ]]; then
            echo "    Mesonet not found: ${meso_file##"${OBS_DIR}"/}"
        fi
    fi

    #=================================================
    # PREPROCESS GOES SATELLITE CWP DATA
    #=================================================
    #3. CWP

    CWP_DIR=${OBS_DIR}/CWP

    cwp_file="${CWP_DIR}/obs_seq_cwp.G16_V04.${anlys_date}${anlys_time}"

    if [[ $rt_run == true && ${use_CWP} == true ]]; then
        if [[ ! -e ${cwp_file} ]]; then
            echo "    Waiting for ${cwp_file##"${OBS_DIR}"/} ...."
        fi
        while [[ ! -e ${cwp_file} ]]; do
            if [[ -e "${cwp_file}.missed" ]]; then
                echo "    Not found. Skip ${cwp_file##"${OBS_DIR}"/} ...."
                break
            fi
            sleep 10
        done
    fi

    if [[ -e ${cwp_file} ]]; then
        echo -e "    ${PURPLE}$((k++))${NC}: Using CWP data in ${LIGHT_BLUE}${cwp_file##"${OBS_DIR}"/}${NC}"

        cp ${cwp_file} ./obs_seq.old

        sed "/obsdistbdy/s/=.*/= 15000/;/obs_boundary/s/=.*/= 5000/" ${input_base} > input.nml

        if [[ $verb -eq 1 ]]; then
            mecho0 "Run command ${BROWN}${obspreprocess}${NC} with parameters: ${BLUE}${g_date} ${g_sec}${NC}"
        fi
        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                               >& ${srunout}_CWP
        ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_CWP 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.cwp
            mv input.nml input.nml.CWP
            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.cwp > obsflist.cwp

            obsflists+=(obsflist.cwp)
        else
            mecho0 "${RED}ERROR${NC}: command ${BROWN}${obspreprocess}${NC} for CWP data"
        fi
    else
        if [[ ${use_CWP} == true && "${anlys_time:3:1}" == "0" ]]; then
            echo "    CWP not found: ${cwp_file##"${OBS_DIR}"/}"
        fi
    fi

    #=================================================
    # PREPROCESS GOES SATELLITE Radiance DATA
    #=================================================
    #4. Radiance

    channels=("08" "10")

    RAD_DIR=${OBS_DIR}/Radiance

    rad_files="obs_seq_abi.G16_C??.${anlys_date}${anlys_time}"

    if [[ $rt_run == true && ${use_RAD} == true ]]; then

        numrad=$(find ${RAD_DIR}/ -name "${rad_files}" | wc -l)
        if [[ $numrad -ne ${#channels[@]} ]]; then
            echo "    Waiting for Radiance/${rad_files} ...."
        fi
        while [[ $numrad -ne ${#channels[@]} ]]; do
            nummis=$(find ${RAD_DIR}/ -name "${rad_files}.missed" | wc -l)
            if [[ $nummis -gt 0 ]]; then
                echo "    Found ${nummis} missed files. Skip Radiance/${rad_files} ...."
                break
            fi
            sleep 10
            numrad=$(find ${RAD_DIR}/ -name "${rad_files}" | wc -l)
        done
    fi

    i=0
    for abifile in "${RAD_DIR}"/obs_seq_abi.G16_C??."${anlys_date}${anlys_time}"; do
        if [[ -e ${abifile} ]]; then
            i=$((i+1))

            if [[ ! -e ${srunout}_RAD ]]; then
                { echo "Run command ${obspreprocess} as:";
                  echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
                  echo "";
                }                                            >& ${srunout}_RAD
            fi

            if [[ ! -e rttov_sensor_db.csv ]]; then
                cp ${FIXDIR}/rtcoef_rttov13/rttov_sensor_db.csv .
            fi

            a=$(basename $abifile)
            chan=${a##obs_seq_abi.G16_C}
            chan=${chan%%."${anlys_date}${anlys_time}"}
            if [[ " ${channels[*]} " == *" $chan "* ]]; then
                echo -e "    ${PURPLE}$k-$i${NC}: Using Radiance data in ${LIGHT_BLUE}${abifile##"${OBS_DIR}"/}${NC}"
                cp ${abifile} ./obs_seq.old

                sed "/obsdistbdy/s/=.*/= 15000/;/obs_boundary/s/=.*/= 5000/" ${input_base} > input.nml

                if [[ $verb -eq 1 ]]; then
                    mecho0 "Run command ${BROWN}${obspreprocess}${NC} with parameters: ${BLUE}${g_date} ${g_sec}${NC}"
                fi
                ${runcmd_str} echo "${g_date} ${g_sec}" | ${obspreprocess} >> ${srunout}_ABI 2>&1

                # shellcheck disable=SC2181
                if [[ $? -eq 0 ]]; then
                    mv ./obs_seq.new ./obs_seq.abiC$chan
                    mv input.nml input.nml.ABI$chan
                    rm ./obs_seq.old
                    echo $wrkdir/OBSDIR/obs_seq.abiC$chan >> obsflist.abi
                else
                    mecho0 "${RED}ERROR${NC}: command ${BROWN}${obspreprocess}${NC} for Radiance data"
                    exit 1
                fi
            else
                echo "    Radiance file ${abifile##"${OBS_DIR}"/} is on Channel $chan, ignoring currently."
            fi
        else
            echo "    Radiance not found: ${abifile##"${OBS_DIR}"/}"
        fi
    done

    if [[ $i -ge 1 ]]; then k=$((k+1)); fi

    if [[ -e obsflist.abi ]]; then
        obsflists+=(obsflist.abi)
    fi

    #=================================================
    # PREPROCESS RADAR DATA
    #=================================================

    ########################
    ### MRMS             ###
    ########################
    #5. REF

    DBZ_DIR=${OBS_DIR}/REF

    dbz_file="${DBZ_DIR}/${eventdate}/obs_seq_RF_${anlys_date}_${anlys_time}.out"

    if [[ $rt_run == true ]]; then
        if [[ ! -e ${dbz_file} ]]; then
            echo "    Waiting for ${dbz_file##"${OBS_DIR}"/} ...."
        fi
        while [[ ! -e ${dbz_file} ]]; do
            if [[ -e "${dbz_file}.missed" ]]; then
                echo "    Not found. Skip ${dbz_file##"${OBS_DIR}"/} ...."
                break
            fi
            sleep 10
        done
    fi

    if [[ -e ${dbz_file} ]]; then
        wait_for_file_age ${dbz_file} 30

        echo -e "    ${PURPLE}$((k++))${NC}: Using REF data in ${LIGHT_BLUE}${dbz_file##"${OBS_DIR}"/}${NC}"

        cp ${dbz_file} ./obs_seq.old

        sed "/obsdistbdy/s/=.*/= 15000/;/obs_boundary/s/=.*/= 5000/" ${input_base} > input.nml

        if [[ $verb -eq 1 ]]; then
            mecho0 "    Run command ${BROWN}${obspreprocess}${NC} with parameters: ${BLUE}${g_date} ${g_sec}${NC}"
        fi
        { echo "Run command ${obspreprocess} as:";
          echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
          echo "";
        }                                                      >& ${srunout}_REF

        ${runcmd_str} echo "$g_date $g_sec" | ${obspreprocess} >> ${srunout}_REF 2>&1

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mv ./obs_seq.new ./obs_seq.mrms
            mv input.nml input.nml.REF
            rm ./obs_seq.old

            echo $wrkdir/OBSDIR/obs_seq.mrms > obsflist.mrms

            obsflists+=(obsflist.mrms)
        else
            mecho0 "${RED}ERROR${NC}: command ${BROWN}${obspreprocess}${NC} for REF data"
        fi
    else
        echo "    REF data not found: ${dbz_file##"${OBS_DIR}"/}"
    fi

    ########################
    ### Radial Velocity  ###
    ########################
    #6. VEL

    wait_seconds=$((iseconds+600))

    #
    # Source environment for radars
    #

    if [[ -e $rundir/$domname/${domname}.${eventdate}.radars.sh ]]; then
        source $rundir/$domname/${domname}.${eventdate}.radars.sh || exit $?
    else
        mecho0 "${RED}ERROR${NC}: File ${CYAN}$rundir/$domname/${domname}.${eventdate}.radars.sh${NC} not exist"
        exit 0
    fi

    VR_DIR=${OBS_DIR}/VEL

    if [[ $rt_run == true ]]; then

        numrad=$(find ${VR_DIR}/${eventdate} -name "obs_seq_????_VR_${anlys_date}_${anlys_time}.out" | wc -l)

        if [[ $numrad -lt ${num_rad} ]]; then
            if [[ $currsecs -lt ${wait_seconds} ]]; then
                echo "    Waiting for ${VR_DIR##"${OBS_DIR}"/}/${eventdate}/obs_seq_????_VR_${anlys_date}_${anlys_time}.out ...."
            else
                echo "    Not found. Skip ${VR_DIR##"${OBS_DIR}"/}/${eventdate}/obs_seq_????_VR_${anlys_date}_${anlys_time}.out ...."
            fi
        fi

        currsecs=$(date -u +%s)
        while [[ $numrad -lt ${num_rad} && $currsecs -lt ${wait_seconds} ]]; do
            # do not wait more than 10 minute outside the current assimilation cycle
            sleep 10
            numrad=$(find ${VR_DIR}/${eventdate} -name "obs_seq_????_VR_${anlys_date}_${anlys_time}.out" | wc -l)
            currsecs=$(date -u +%s)
        done
    fi

    j=0; n=0
    while [[ ${j} -lt ${num_rad} ]]; do

        vrj_file=${VR_DIR}/${eventdate}/obs_seq_${rad_name[$j]}_VR_${anlys_date}_${anlys_time}.out

        if [[ $verb -eq 1 ]]; then
            mecho0 "    Checking VEL data in ${vrj_file##"${OBS_DIR}"/}"
        fi

        if [[ -e ${vrj_file} ]]; then

            wait_for_file_age ${vrj_file} 30

            if [[ ${run_trimvr} == true ]]; then
                trimvr_cmd="${scpdir}/seq_filter.py -k -o ./obs_seq.old ${vrj_file}"
                echo -e "    --- ${BROWN}${trimvr_cmd}${NC}" | sed "s#${scpdir}/##;s#${OBS_DIR}#\${OBS_DIR}#g"      # just to get a short message line

                if ! ${trimvr_cmd}; then
                    #echo "        Failed. Ignore ${vrj_file}"
                    (( j++ ))
                    continue
                fi
            else
                cp ${vrj_file} ./obs_seq.old
            fi

            sed "/obsdistbdy/s/=.*/= 15000/;/obs_boundary/s/=.*/= 5000/" ${input_base} > input.nml

            #echo "    $k-$n: Using VEL data in ${vrj_file}"

            if [[ $verb -eq 1 ]]; then
                mecho0 "Run command ${BROWN}${obspreprocess}${NC} with parameters: ${BLUE}${g_date} ${g_sec}${NC}"
            fi
            { echo "Run command ${obspreprocess} as:";
              echo "echo  \"${g_date} ${g_sec}\" | ${obspreprocess}";
              echo "";
            }                                                      >& ${srunout}_VR_${rad_name[$j]}

            ${runcmd_str} echo "$g_date $g_sec" | ${obspreprocess} >> ${srunout}_VR_${rad_name[$j]} 2>&1

            rm ./obs_seq.old

            if [[ -e ./obs_seq.new ]]; then
                (( n++ ))
                echo -e "    ${PURPLE}$k-$n${NC}: Using VEL data in ${LIGHT_BLUE}${vrj_file##"${OBS_DIR}"/}${NC}\n"
                mv ./obs_seq.new ./obs_seq.vr${j}
                mv input.nml input.nml.VR_${rad_name[$j]}
                echo $wrkdir/OBSDIR/obs_seq.vr${j} >> obsflist.radvr
            fi

        fi

        (( j++ ))
    done

    if [[ $n -gt 0 ]]; then
        obsflists+=(obsflist.radvr)
    else
        echo "    No valid radial velocity data is processed"
    fi

    #-------------------------------------------------------------------
    #
    # Run OBS_SEQUENCE_TOOL
    #
    #-------------------------------------------------------------------

    if [[ ${#obsflists[@]} -gt 0 ]]; then
        if [[ $verb -eq 1 ]]; then
            echo "cat ${obsflists[*]} to obsflist"
        fi
        cat "${obsflists[@]}" > obsflist
        #obs_found=true
    else
        mecho0 "${YELLOW}No valid observation was found${NC}."
        #obs_found=false
        return
    fi

    #===================================================================

    (( gobef_secs=iseconds - 900 ))    # -15m
    (( goaft_secs=iseconds + 180 ))    # +3m

    read -r -a gobef_dates < <(convertS2days "${gobef_secs}")
    read -r -a goaft_dates < <(convertS2days "${goaft_secs}")

    sedfile=$(mktemp -t input.nml_${eventtime}.sed_XXXX)

    cat <<EOF > $sedfile
/first_obs_days/s/-1/${gobef_dates[0]}/
/first_obs_seconds/s/-1/${gobef_dates[1]}/
/last_obs_days/s/-1/${goaft_dates[0]}/
/last_obs_seconds/s/-1/${goaft_dates[1]}/
EOF

    sed -f $sedfile ${input_base} > input.nml

    rm -f $sedfile

    #===================================================================

    #COMBINE obs-seq FILES HERE
    # namelist file input.nml contains:
    # &obs_sequence_tool_nml
    #    filename_seq_list = 'obsflist'
    #    filename_out      = 'obs_seq.${timestr_cur}'
    # /
    #
    if [[ $verb -eq 1 ]]; then echo "Runing ${EXEDIR}/dart/obs_sequence_tool"; fi
    ${runcmd_str} ${EXEDIR}/dart/obs_sequence_tool >& ${srunout}_sequence_tool

    if [[ $? -eq 0 && -e obs_seq.${anlys_date}${anlys_time} ]]; then
        mecho0 "Observation file ${CYAN}${wrkdir##"$WORKDIR"/}/OBSDIR/obs_seq.${anlys_date}${anlys_time}${NC} created"
        mv input.nml input.nml.sequence_tool
    else
        mecho0 "${RED}ERROR${NC}: ${runcmd_str} ${EXEDIR}/dart/obs_sequence_tool"
    fi

    #rm -f ./obs_seq.hfmetar ./obs_seq.meso ./obs_seq.cwp ./obs_seq.mrms ./obs_seq.rad ./obs_seq.vr*

    #rm -f dart_log.* obsflist* init.nc
    #rm -f obsflist* wrfinput_d0*

    cd $wrkdir || return
}

########################################################################

function run_filter {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, ADAPTIVE_INF, OBS_DIR
    #         intvl_sec, ncores_filter
    # RETURN: input_file_list, output_file_list
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.filter || -f $wrkdir/done.filter || -f $wrkdir/queue.filter ]]; then
        return
    fi

    timesec_pre=$((iseconds-intvl_sec))
    event_pre=$(date -u -d @${timesec_pre}   +%H%M)
    timestr_cur=$(date -u -d @${iseconds}    +%Y%m%d%H%M)

    datestr4obsdiag=$(date -u -d @${iseconds} +%Y,%m,%d,%H,%M,%S)
    intvl_min=$((intvl_sec/60))
    dateintvl4obsdiag="0, 0, 0,00,${intvl_min},00"

    (( gobef_secs=iseconds - 900 ))    # -15m
    (( goaft_secs=iseconds + 180 ))    # +3m
    (( gobtw_secs=goaft_secs-gobef_secs ))
    datestr4obsdiag_start=$(date -u -d @${gobef_secs} +%Y,%m,%d,%H,%M,%S)
    datestr4obsdiag_end=$(date -u -d @${goaft_secs} +%Y,%m,%d,%H,%M,%S)

    read -r -a gobef_dates < <(convertS2days "${gobef_secs}")
    read -r -a goaft_dates < <(convertS2days "${goaft_secs}")

    if $relative_path; then
        parentdir='..'  #$(realpath -m --relative-to=${wrkdir} ${parentdir_a})
        casedir=$(realpath -m --relative-to=${wrkdir} ${rundir})
    else
        parentdir=$(dirname ${wrkdir})
        casedir="${rundir}"
    fi

    #------------------------------------------------------
    # Waiting for job conditions before submit the job
    #------------------------------------------------------

    if [[ $icycle -eq 0 ]]; then
        conditions=("${rundir}/init/done.${domname}")
    else
        conditions=("${parentdir}/${event_pre}/done.fcst")
    fi

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # 1. Update input files to get filter started
    #------------------------------------------------------

    currtime_str=$(date -u -d @$iseconds +%Y-%m-%d_%H.%M.%S)

    rm -f filter_in.txt filter_out.txt
    input_file_list=()
    output_file_list=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        if [[ $icycle -eq 0 ]]; then
            input_file_="${casedir}/init/${domname}_${memstr}.init.nc"
        else
            input_file_="${parentdir}/${event_pre}/fcst_${memstr}/${domname}_${memstr}.restart.$currtime_str.nc"
        fi
        input_file="${domname}_${memstr}.prior.$currtime_str.nc"
        ln -sf ${input_file_} ${input_file}

        if [[ $dorun == true && ! -f $input_file ]]; then
            mecho0 "${RED}ERROR${NC}: File ${CYAN}$input_file${NC} not exist."
            exit 1
        fi
        echo $input_file >> filter_in.txt
        input_file_list+=("$input_file")

        #output_file="${domname}_${memstr}.analysis.$currtime_str.nc"
        output_file="${domname}_${memstr}.analysis"
        echo $output_file >> filter_out.txt
        output_file_list+=("$output_file")
    done

    filename_mesh="${rundir}/init/${domname}_01.init.nc"

    #------------------------------------------------------
    # 2. Adaptive inflation & Sampling error correction
    #------------------------------------------------------

    inf_initial_restart=(".false." ".false.")

    if [[ $ADAPTIVE_INF == true ]]; then
        if [[ -e ${parentdir}/${event_pre}/output_priorinf_mean.nc ]]; then
            ln -sf ${parentdir}/${event_pre}/output_priorinf_mean.nc input_priorinf_mean.nc
            ln -sf ${parentdir}/${event_pre}/output_priorinf_sd.nc   input_priorinf_sd.nc

            inf_initial_restart=(".true." ".false.")
            mecho0 "${WHITE}INFO${NC}: Use ${PURPLE}adaptive inflation${NC} for this cycle."
        else
            mecho0 "File ${CYAN}${parentdir}/${event_pre}/output_priorinf_mean.nc${NC} does not exist."
            mecho0 "${YELLOW}WARNING${NC}: Not using adaptive inflation for this cycle."
            #exit 2
        fi
    fi

    if [[ ${sampling_error_correction,,} == ".t." || ${sampling_error_correction,,} == ".true." ]]; then
        mecho0 "${WHITE}INFO${NC}: Turning on ${PURPLE}sampling_error_correction${NC}."
        ln -sf ${FIXDIR}/sampling_error_correction_table.nc .
        sampling_error_correction=".true."
    else
        mecho0 "${YELLOW}WARNING${NC}: Not using sampling error correction: ${PURPLE}sampling_error_correction${NC}."
        sampling_error_correction=".false."
    fi

    #------------------------------------------------------
    # 3. Link RTTOV static files
    #------------------------------------------------------

    coef_files=(rttov9pred54L/rtcoef_goes_16_abi.dat                          \
                rttov13pred54L/rtcoef_goes_16_abi_7gas.dat                    \
                rttov13pred54L/rtcoef_goes_16_abi_7gas_ironly.dat             \
                rttov13pred54L/rtcoef_goes_16_abi_o3.dat                      \
                rttov13pred54L/rtcoef_goes_16_abi_o3co2.dat                   \
                rttov13pred54L/rtcoef_goes_16_abi_o3co2_ironly.dat            \
                rttov13pred54L/rtcoef_goes_16_abi_o3_ironly.dat               \
                mfasis_lut/rttov_mfasis_cld_goes_16_abi_deff.H5               \
                mfasis_lut/rttov_mfasis_cld_goes_16_abi_deff_sub1micron.H5    \
                mfasis_lut/rttov_mfasis_cld_goes_16_abi_opac.H5               \
                mfasis_lut/rttov_mfasis_cld_goes_16_abi_opac_sub1micron.H5    \
                cldaer_visir/scaercoef_goes_16_abi_cams.dat                   \
                cldaer_ir/scaercoef_goes_16_abi_cams_ironly.dat               \
                cldaer_visir/scaercoef_goes_16_abi_opac.dat                   \
                cldaer_ir/scaercoef_goes_16_abi_opac_ironly.dat               \
                cldaer_visir/sccldcoef_goes_16_abi.dat                        \
                cldaer_ir/sccldcoef_goes_16_abi_ironly.dat                    )

    for fn in "${coef_files[@]}"; do
        ln -sf  "${FIXDIR}/rtcoef_rttov13/$fn" .
    done

    if [[ ! -e rttov_sensor_db.csv ]]; then
        cp ${FIXDIR}/rtcoef_rttov13/rttov_sensor_db.csv .
    fi

    #------------------------------------------------------
    # 4. Prepare namelist file
    #------------------------------------------------------

    # Debug configuration:
    #
    #   stages_to_write          = 'preassim', 'output'

    declare -A mp_state_variables

    mp_state_variables['qc']='QTY_CLOUDWATER_MIXING_RATIO'
    mp_state_variables['qr']='QTY_RAINWATER_MIXING_RATIO'
    mp_state_variables['qi']='QTY_ICE_MIXING_RATIO'
    mp_state_variables['qs']='QTY_SNOW_MIXING_RATIO'
    mp_state_variables['qg']='QTY_GRAUPEL_MIXING_RATIO'
    #mp_state_variables['nr']='QTY_RAIN_NUMBER_CONCENTR'
    #mp_state_variables['ni']='QTY_ICE_NUMBER_CONCENTRATION'
    mp_variables_keys=('qc' 'qr' 'qi' 'qs' 'qg' )
    mp_state_bounds="'0.0','NULL','CLAMP'"

    lbc_mp_nssl_variables=".false."
    if [[ ${mpscheme} == "mp_nssl2m" ]]; then
        mp_state_variables['qh']='QTY_HAIL_MIXING_RATIO'
        #mp_state_variables['volg']='QTY_GRAUPEL_VOLUME'
        #mp_state_variables['volh']='QTY_HAIL_VOLUME'
        #mp_state_variables['nc']='QTY_DROPLET_NUMBER_CONCENTR'
        #mp_state_variables['ns']='QTY_SNOW_NUMBER_CONCENTR'
        #mp_state_variables['ng']='QTY_GRAUPEL_NUMBER_CONCENTR'
        #mp_state_variables['nh']='QTY_HAIL_NUMBER_CONCENTR'
        #mp_variables_keys+=('qh' 'nc' 'ns' 'ng' 'nh' 'volg' 'volh')
        mp_variables_keys+=('qh')
        lbc_mp_nssl_variables=".true."
    fi

    cat << EOF > input.nml
&perfect_model_obs_nml
   read_input_state_from_file = .true.
   single_file_in             = .false.
   input_state_files          = 'mpas_init.nc'
   init_time_days             = -1
   init_time_seconds          = -1

   write_output_state_to_file = .false.
   single_file_out            = .false.
   output_state_files         = 'perfect_restart.nc'
   output_interval            = 1

   async                      = 0
   adv_ens_command            = './advance_model.csh'

   obs_seq_in_file_name       = 'obs_seq.in'
   obs_seq_out_file_name      = 'obs_seq.out'
   first_obs_days             = -1
   first_obs_seconds          = -1
   last_obs_days              = -1
   last_obs_seconds           = -1

   trace_execution            = .true.
   output_timestamps          = .false.
   print_every_nth_obs        = 0
   output_forward_op_errors   = .false.
   silence                    = .false.
  /

&filter_nml
   async                    = 0
   adv_ens_command          = 'no_model_advance'
   ens_size                 = ${ENS_SIZE}
   output_members           = .true.
   obs_sequence_in_name     = 'obs_seq.in'
   obs_sequence_out_name    = 'obs_seq.final'
   input_state_file_list    = 'filter_in.txt'
   output_state_file_list   = 'filter_out.txt'
   init_time_days           = -1
   init_time_seconds        = -1
   first_obs_days           = -1
   first_obs_seconds        = -1
   last_obs_days            = -1
   last_obs_seconds         = -1
   num_output_state_members = 36
   num_output_obs_members   = 36
   output_interval          = 1
   num_groups               = 1
   distributed_state        = .true.
   compute_posterior        = .true.
   output_forward_op_errors = .false.
   output_timestamps        = .true.
   trace_execution          = .true.
   silence                  = .false.

   stages_to_write          = 'output'
   output_mean              = .true.
   output_sd                = .true.
   write_all_stages_at_end  = .false.

   inf_flavor                  = 2, 0,
   inf_initial_from_restart    = $(join_by ',' "${inf_initial_restart[@]}"),
   inf_sd_initial_from_restart = $(join_by ',' "${inf_initial_restart[@]}"),
   inf_deterministic           = .true.,                  .true.,
   inf_initial                 = 1.0,                     1.0
   inf_sd_initial              = 0.6,                     0.0
   inf_damping                 = 0.9,                     1.0
   inf_lower_bound             = 1.0,                     1.0
   inf_upper_bound             = 1000.0,               1000000.0
   inf_sd_lower_bound          = 0.6,                     0.0
   inf_sd_max_change           = 1.05,                    1.05,
  /

&quality_control_nml
   input_qc_threshold = 5,
   outlier_threshold  = 3.5,
   inlier_threshold   = 0.0,
   enable_special_outlier_code = .false.,
  /

&state_vector_io_nml
   single_precision_output    = .false.,
  /

&mpi_utilities_nml
  /

&smoother_nml
   num_lags              = 0
   start_from_restart    = .true.
   output_restart        = .false.
   restart_in_file_name  = 'smoother_ics'
   restart_out_file_name = 'smoother_restart'
  /

&ensemble_manager_nml
   layout = 2
   tasks_per_node = ${ncores_filter}
  /

&assim_tools_nml
   filter_kind                       = 1
   cutoff                            = 0.036,
   distribute_mean                   = .true.
   convert_all_obs_verticals_first   = .true.
   convert_all_state_verticals_first = .true.
   sort_obs_inc                      = .false.
   spread_restoration                = .false.
   sampling_error_correction         = ${sampling_error_correction}
   adaptive_localization_threshold   = -1
   output_localization_diagnostics   = .false.
   localization_diagnostics_file     = 'localization_diagnostics'
   print_every_nth_obs               = 0
   special_localization_obs_types  = 'METAR_ALTIMETER',
                                     'METAR_U_10_METER_WIND',
                                     'METAR_V_10_METER_WIND',
                                     'METAR_TEMPERATURE_2_METER',
                                     'METAR_DEWPOINT_2_METER',
                                     'MARINE_SFC_U_WIND_COMPONENT',
                                     'MARINE_SFC_V_WIND_COMPONENT',
                                     'MARINE_SFC_TEMPERATURE',
                                     'MARINE_SFC_ALTIMETER',
                                     'MARINE_SFC_DEWPOINT',
                                     'LAND_SFC_U_WIND_COMPONENT',
                                     'LAND_SFC_V_WIND_COMPONENT',
                                     'LAND_SFC_TEMPERATURE',
                                     'LAND_SFC_DEWPOINT',
                                     'LAND_SFC_ALTIMETER',
                                     'LAND_SFC_PRESSURE',
                                     'RADAR_REFLECTIVITY',
                                     'RADAR_CLEARAIR_REFLECTIVITY',
                                     'DOPPLER_RADIAL_VELOCITY',
                                     'GOES_CWP_PATH',
                                     'GOES_LWP_PATH',
                                     'GOES_IWP_PATH',
                                     'GOES_CWP_ZERO',
   special_localization_cutoffs    = 0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0094247,
                                     0.0047123,
                                     0.0047123,
                                     0.0047123,
                                     0.0047123,
                                     0.0094247,
                                     0.0047123,
                                     0.0014137,
                                     0.0014137,
                                     0.0014137,
                                     0.00315,
                                     0.00315,
                                     0.00315,
                                     0.0035,
  /

&location_nml
   horiz_dist_only                 = .false.
   vert_normalization_pressure     = 700000.0,
   vert_normalization_height       = 111111.1,
   vert_normalization_level        = 2666.7,
   vert_normalization_scale_height = 2.0
   approximate_distance            = .false.
   nlon                            = 283,
   nlat                            = 144,
   output_box_info                 = .false.
   print_box_level                 = 0
   special_vert_normalization_obs_types =  'METAR_ALTIMETER',
                                           'METAR_U_10_METER_WIND',
                                           'METAR_V_10_METER_WIND',
                                           'METAR_TEMPERATURE_2_METER',
                                           'METAR_DEWPOINT_2_METER',
                                           'MARINE_SFC_U_WIND_COMPONENT',
                                           'MARINE_SFC_V_WIND_COMPONENT',
                                           'MARINE_SFC_TEMPERATURE',
                                           'MARINE_SFC_ALTIMETER',
                                           'MARINE_SFC_DEWPOINT',
                                           'LAND_SFC_U_WIND_COMPONENT',
                                           'LAND_SFC_V_WIND_COMPONENT',
                                           'LAND_SFC_TEMPERATURE',
                                           'LAND_SFC_DEWPOINT',
                                           'LAND_SFC_ALTIMETER',
                                           'LAND_SFC_PRESSURE',
                                           'RADAR_REFLECTIVITY',
                                           'RADAR_CLEARAIR_REFLECTIVITY',
                                           'DOPPLER_RADIAL_VELOCITY',
                                           'GOES_CWP_PATH',
                                           'GOES_LWP_PATH',
                                           'GOES_IWP_PATH',
                                           'GOES_CWP_ZERO',
   special_vert_normalization_pressures =  100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                           100000.0,
                                         15873016.0,
                                         12698413.0,
                                         15873016.0,
                                           100000.0,
   special_vert_normalization_heights  =   424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           424416.6,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           848842.3,
                                           2122090.9,
                                           2083333.2,
                                           2122090.9,
                                           1587301.0,
                                           1587301.0,
                                           1587301.3,
                                           1000000.0,
   special_vert_normalization_levels    =  20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
                                           20.0,
   special_vert_normalization_scale_heights = 5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
                                              5.0,
/

&xyz_location_nml
/

&cov_cutoff_nml
    select_localization = 1
/

&reg_factor_nml
    select_regression    = 1
    input_reg_file       = 'time_mean_reg'
    save_reg_diagnostics = .false.
    reg_diagnostics_file = 'reg_diagnostics'
/

&obs_sequence_nml
    write_binary_obs_sequence = .false.
/

!   assimilate_these_obs_types = 'RADIOSONDE_TEMPERATURE',
!                                'RADIOSONDE_U_WIND_COMPONENT',
!                                'RADIOSONDE_V_WIND_COMPONENT',
!                                'RADIOSONDE_SPECIFIC_HUMIDITY',
!                                'GPSRO_REFRACTIVITY',
!                                'LAND_SFC_ALTIMETER',
!                                'MARINE_SFC_DEWPOINT',
!                                'AIRCRAFT_U_WIND_COMPONENT',
!                                'AIRCRAFT_V_WIND_COMPONENT',
!                                'AIRCRAFT_TEMPERATURE',
!                                'ACARS_U_WIND_COMPONENT',
!                                'ACARS_V_WIND_COMPONENT',
!                                'ACARS_TEMPERATURE',
!                                'SAT_U_WIND_COMPONENT',
!                                'SAT_V_WIND_COMPONENT',
!                                'RADAR_REFLECTIVITY',
!                                'RADAR_CLEARAIR_REFLECTIVITY',
!                                'DOPPLER_RADIAL_VELOCITY'

! Upper level
!                                'AIRCRAFT_U_WIND_COMPONENT',
!                                'AIRCRAFT_V_WIND_COMPONENT',
!                                'AIRCRAFT_TEMPERATURE',
!                                'ACARS_U_WIND_COMPONENT',
!                                'ACARS_V_WIND_COMPONENT',
!                                'ACARS_TEMPERATURE',

!                                'RADIOSONDE_TEMPERATURE',
!                                'RADIOSONDE_U_WIND_COMPONENT',
!                                'RADIOSONDE_V_WIND_COMPONENT',
!                                'RADIOSONDE_SPECIFIC_HUMIDITY',
!                                'GPSRO_REFRACTIVITY',

! Surface
!                                'METAR_ALTIMETER',
!                                'METAR_DEWPOINT_2_METER',
!                                'METAR_U_10_METER_WIND',
!                                'METAR_V_10_METER_WIND',
!                                'METAR_TEMPERATURE_2_METER',
!                                'METAR_SPECIFIC_HUMIDITY_2_METER',
!                                'MARINE_SFC_SPECIFIC_HUMIDITY',
!                                'MARINE_SFC_U_WIND_COMPONENT',
!                                'MARINE_SFC_V_WIND_COMPONENT',
!                                'MARINE_SFC_TEMPERATURE',
!                                'MARINE_SFC_PRESSURE',
!                                'MARINE_SFC_DEWPOINT',
!                                'LAND_SFC_PRESSURE',
!                                'LAND_SFC_ALTIMETER',
!                                'LAND_SFC_DEWPOINT',
!                                'LAND_SFC_TEMPERATURE',
!                                'LAND_SFC_SPECIFIC_HUMIDITY',
!                                'LAND_SFC_U_WIND_COMPONENT',
!                                'LAND_SFC_V_WIND_COMPONENT',
!
&obs_kind_nml
    assimilate_these_obs_types = 'AIRCRAFT_U_WIND_COMPONENT',
                                 'AIRCRAFT_V_WIND_COMPONENT',
                                 'AIRCRAFT_TEMPERATURE',
                                 'ACARS_U_WIND_COMPONENT',
                                 'ACARS_V_WIND_COMPONENT',
                                 'ACARS_TEMPERATURE',
                                 'METAR_ALTIMETER',
                                 'METAR_DEWPOINT_2_METER',
                                 'METAR_U_10_METER_WIND',
                                 'METAR_V_10_METER_WIND',
                                 'METAR_TEMPERATURE_2_METER',
                                 'MARINE_SFC_U_WIND_COMPONENT',
                                 'MARINE_SFC_V_WIND_COMPONENT',
                                 'MARINE_SFC_TEMPERATURE',
                                 'MARINE_SFC_ALTIMETER',
                                 'MARINE_SFC_DEWPOINT',
                                 'LAND_SFC_PRESSURE',
                                 'LAND_SFC_ALTIMETER',
                                 'LAND_SFC_TEMPERATURE',
                                 'LAND_SFC_DEWPOINT',
                                 'LAND_SFC_U_WIND_COMPONENT',
                                 'LAND_SFC_V_WIND_COMPONENT',
                                 'RADAR_REFLECTIVITY',
                                 'RADAR_CLEARAIR_REFLECTIVITY',
                                 'DOPPLER_RADIAL_VELOCITY',
                                 'GOES_IWP_PATH',
                                 'GOES_CWP_ZERO',
                                 'GOES_CWP_PATH',
                                 'GOES_LWP_PATH',
                                 'GOES_16_ABI_TB',
    evaluate_these_obs_types = ''
/

&obs_def_gps_nml
    max_gpsro_obs = 100000
/

&obs_def_radar_mod_nml
    apply_ref_limit_to_obs     =  .true. ,
    reflectivity_limit_obs     =     0.0 ,
    lowest_reflectivity_obs    =     0.0 ,
    apply_ref_limit_to_fwd_op  =  .true. ,
    reflectivity_limit_fwd_op  =     0.0 ,
    lowest_reflectivity_fwd_op =     0.0 ,
    dielectric_factor          =   0.224 ,
    n0_rain                    =   8.0e6 ,
    n0_graupel                 =   4.0e6 ,
    n0_snow                    =   3.0e6 ,
    rho_rain                   =  1000.0 ,
    rho_graupel                =   400.0 ,
    rho_snow                   =   100.0 ,
    allow_wet_graupel          = .false. ,
    microphysics_type          =       5 ,
    allow_dbztowt_conv         =  .true. ,
/
&obs_def_cwp_nml
    pressure_top               = 15000.0,
    physics                    = 8
/

&model_nml
   init_template_filename       = '${filename_mesh}'
   assimilation_period_days     = 0
   assimilation_period_seconds  = 2400
   model_perturbation_amplitude = 0.0001
   vert_localization_coord      = 3
   calendar                     = 'Gregorian'
   highest_obs_pressure_mb      = 20.0
   sfc_elev_max_diff            = 100.
   log_p_vert_interp            = .true.
   debug                        = 0
   use_u_for_wind               = .false.
   use_rbf_option               = 2
   update_u_from_reconstruct    = .true.
   use_increments_for_u_update  = .true.
  /

!                          'theta',                 'QTY_POTENTIAL_TEMPERATURE',
!                          'surface_pressure',      'QTY_SURFACE_PRESSURE',
!                          'uReconstructZonal',     'QTY_U_WIND_COMPONENT',
!                          'uReconstructMeridional','QTY_V_WIND_COMPONENT',
!                          'u',                     'QTY_EDGE_NORMAL_SPEED',
!                          'w',                     'QTY_VERTICAL_VELOCITY',
!                          'qv',                    'QTY_VAPOR_MIXING_RATIO',
!                          'rho',                   'QTY_DENSITY',
!                          'u10',                   'QTY_10M_U_WIND_COMPONENT',
!                          'v10',                   'QTY_10M_V_WIND_COMPONENT',
!                          't2m',                   'QTY_2M_TEMPERATURE',
!                          'q2',                    'QTY_2M_SPECIFIC_HUMIDITY',

&mpas_vars_nml
    mpas_state_variables = 'theta',                 'QTY_POTENTIAL_TEMPERATURE',
                           'rho',                   'QTY_DENSITY',
                           'uReconstructZonal',     'QTY_U_WIND_COMPONENT',
                           'uReconstructMeridional','QTY_V_WIND_COMPONENT',
                           'w',                     'QTY_VERTICAL_VELOCITY',
                           'u10',                   'QTY_10M_U_WIND_COMPONENT',
                           'v10',                   'QTY_10M_V_WIND_COMPONENT',
                           't2m',                   'QTY_2M_TEMPERATURE',
                           'q2',                    'QTY_2M_SPECIFIC_HUMIDITY',
                           'surface_pressure',      'QTY_SURFACE_PRESSURE',
                           'refl10cm',              'QTY_RADAR_REFLECTIVITY',
                           'qv',                    'QTY_VAPOR_MIXING_RATIO',
EOF

    for var in "${mp_variables_keys[@]}"; do
        lenstr=$((22-${#var}))
        printf "%27s%s,%*s%s,\n" ' ' "'${var}'" $lenstr ' ' "'${mp_state_variables[$var]}'" >> input.nml
    done

    echo "    mpas_state_bounds    = 'qv','0.0','NULL','CLAMP',"     >> input.nml
    for var in "${mp_variables_keys[@]}"; do
        printf "%27s%s,%s,\n" ' ' "'${var}'" "${mp_state_bounds}"    >> input.nml
    done
    printf "%s\n" "/"                                                >> input.nml

    cat << EOF >> input.nml

&update_mpas_states_nml
    update_input_file_list  = 'filter_out.txt'
    update_output_file_list = 'filter_in.txt'
    print_data_ranges       = .true.
/

&update_bc_nml
    update_analysis_file_list           = 'filter_out.txt'
    update_boundary_file_list           = 'boundary_inout.txt'
    lbc_update_from_reconstructed_winds = .false.
    lbc_update_winds_from_increments    = .false.
    lbc_mp_nssl_variables               = ${lbc_mp_nssl_variables}
    debug = 0
/

&utilities_nml
    TERMLEVEL      = 1
    module_details = .false.
    logfilename    = 'dart_log.out'
    nmlfilename    = 'dart_log.nml'
    write_nml      = 'file'
/

&preprocess_nml
    overwrite_output        = .true.
    input_obs_def_mod_file  = '../../../observations/forward_operators/DEFAULT_obs_def_mod.F90'
    output_obs_def_mod_file = '../../../observations/forward_operators/obs_def_mod.f90'
    input_obs_qty_mod_file  = '../../../assimilation_code/modules/observations/DEFAULT_obs_kind_mod.F90'
    output_obs_qty_mod_file = '../../../assimilation_code/modules/observations/obs_kind_mod.f90'
    obs_type_files          = '../../../observations/forward_operators/obs_def_reanalysis_bufr_mod.f90',
                              '../../../observations/forward_operators/obs_def_altimeter_mod.f90',
                              '../../../observations/forward_operators/obs_def_gts_mod.f90',
                              '../../../observations/forward_operators/obs_def_metar_mod.f90',
                              '../../../observations/forward_operators/obs_def_gps_mod.f90',
                              '../../../observations/forward_operators/obs_def_vortex_mod.f90',
                              '../../../observations/forward_operators/obs_def_rel_humidity_mod.f90',
                              '../../../observations/forward_operators/obs_def_dew_point_mod.f90',
                              '../../../observations/forward_operators/obs_def_radar_mod.f90',
                              '../../../observations/forward_operators/obs_def_cwp_mod.f90'
    quantity_files          = '../../../assimilation_code/modules/observations/default_quantities_mod.f90',
                              '../../../assimilation_code/modules/observations/atmosphere_quantities_mod.f90',
/

&obs_sequence_tool_nml
    filename_seq_list = 'obsflist'
    filename_out      = 'obs_seq.${timestr_cur}'
    first_obs_days    = -1
    first_obs_seconds = -1
    last_obs_days     = -1
    last_obs_seconds  = -1
    print_only        = .false.
    min_lat           = -90.0
    max_lat           =  90.0
    min_lon           =   0.0
    max_lon           = 360.0
    gregorian_cal     = .true.
    keep_types        = .true.
    obs_types         = ''
/

# The times in the namelist for the obs_diag program are vectors
# that follow the following sequence:
# year   month   day   hour   minute   second
# max_num_bins can be used to specify a fixed number of bins,
# in which case last_bin_center should be safely in the future.
#
# keep only the U and V radiosonde winds:
#   obs_types          = 'RADIOSONDE_U_WIND_COMPONENT'
#                        'RADIOSONDE_V_WIND_COMPONENT'
#   keep_types         = .true.
#
# remove the U and V radiosonde winds:
#   obs_types          = 'RADIOSONDE_U_WIND_COMPONENT'
#                        'RADIOSONDE_V_WIND_COMPONENT'
#   keep_types         = .false.
#
# keep only observations with a DART QC of 0:
#   qc_metadata        = 'Dart quality control'
#   min_qc             = 0
#   max_qc             = 0
#
# keep only radiosonde temp obs between 250 and 300 K:
#   copy_metadata      = 'NCEP BUFR observation'
#   copy_type          = 'RADIOSONDE_TEMPERATURE'
#   min_copy           = 250.0
#   max_copy           = 300.0
#


&schedule_nml
    calendar             = 'Gregorian'
    first_bin_start      =  ${datestr4obsdiag_start}
    first_bin_end        =  ${datestr4obsdiag_end}
    last_bin_end         =  ${datestr4obsdiag_end}
    bin_interval_days    = 0
    bin_interval_seconds = ${gobtw_secs}
    max_num_bins         = 1000
    print_table          = .true.
/


&obs_seq_to_netcdf_nml
    obs_sequence_name = 'obs_seq.final'
    obs_sequence_list = ''
    append_to_netcdf  = .false.
    lonlim1           =    0.0
    lonlim2           =  360.0
    latlim1           =  -90.0
    latlim2           =   90.0
    verbose           = .true.
/

&obs_diag_nml
    obs_sequence_name  = 'obs_seq.final'
    obs_sequence_list  = ''
    first_bin_center   = ${datestr4obsdiag}
    last_bin_center    = ${datestr4obsdiag}
    bin_width          = ${dateintvl4obsdiag}
    bin_separation     = ${dateintvl4obsdiag}
    time_to_skip       =    0, 0, 0,00,00,00
    trusted_obs        = 'null'
    nregions  = 1
    lonlim1   =   0.0
    lonlim2   = 360.0
    latlim1   = -90.0
    latlim2   =  90.0
    reg_names = 'WOFS'
    create_rank_histogram = .true.
    outliers_in_histogram = .true.
    use_zero_error_obs    = .false.
    verbose               = .true.
/

&obs_common_subset_nml
    num_to_compare_at_once = 2
    filename_seq           = ''
    filename_seq_list      = ''
    filename_out_suffix    = '.common'
    calendar               = 'Gregorian'
    print_every            = 1000
    dart_qc_threshold      = 3
    print_only             = .false.
/

# possible vertical coordinate systems are:
# VERTISUNDEF VERTISSURFACE VERTISLEVEL VERTISPRESSURE VERTISHEIGHT VERTISSCALEHEIGHT
   quantity_of_interest = 'QTY_SURFACE_PRESSURE'
   quantity_of_interest = 'QTY_POTENTIAL_TEMPERATURE'
   quantity_of_interest = 'QTY_TEMPERATURE'
   quantity_of_interest = 'QTY_U_WIND_COMPONENT'
   quantity_of_interest = 'QTY_V_WIND_COMPONENT'
   quantity_of_interest = 'QTY_DENSITY'
   quantity_of_interest = 'QTY_VAPOR_MIXING_RATIO'

&model_mod_check_nml
    input_state_files     = 'mpas_init.nc'
    output_state_files    = 'check_me.nc'
    test1thru             = 0
    run_tests             = 1,2,3,4,5,7
    x_ind                 = 300
    loc_of_interest       = 240.0, 0.0, 10000.0
    quantity_of_interest  = 'QTY_U_WIND_COMPONENT'
    interp_test_lonrange  = 0.0, 359.0
    interp_test_dlon      = 1.0
    interp_test_latrange  = -89.0, 89.0
    interp_test_dlat      = 1.0
    interp_test_vertrange = 100.0,  20100.0
    interp_test_dvert     = 2000.0
    interp_test_vertcoord = 'VERTISHEIGHT'
    verbose               = .false.
/

&exhaustion_nml
    dart_input_file       = 'dart_ics'
    output_file           = 'exhaust'
    advance_time_present  = .FALSE.
    verbose               = .FALSE.
    matlab_out            = .FALSE.
    netcdf_out            = .TRUE.
    kind_of_interest      = 'QTY_U_WIND_COMPONENT'
    interp_test_lonrange  = 0.0, 360.0
    interp_test_dlon      = 1.0
    interp_test_latrange  = -89.0, 89.0
    interp_test_dlat      = 1.0
    interp_test_vertrange = 7000.0, 7000.0
    interp_test_dvert     = 1000.0
    interp_test_vertcoord = 'VERTISHEIGHT'
    hscale                = 100.0
    diff_threshold        = 2.0
    pointcount            = 100000
/

&obs_def_rttov_nml
    rttov_sensor_db_file   = 'rttov_sensor_db.csv'
    first_lvl_is_sfc       = .true.
    mw_clear_sky_only      = .false.
    interp_mode            = 1
    do_checkinput          = .true.
    apply_reg_limits       = .true.
    verbose                = .true.
    fix_hgpl               = .false.
    do_lambertian          = .false.
    lambertian_fixed_angle = .true.
    rad_down_lin_tau       = .true.
    use_q2m                = .true.
    use_uv10m              = .true.
    use_wfetch             = .false.
    use_water_type         = .false.
    addrefrac              = .false.
    plane_parallel         = .false.
    use_salinity           = .false.
    cfrac_data             = .true.
    clw_data               = .true.
    rain_data              = .true.
    ciw_data               = .true.
    snow_data              = .true.
    graupel_data           = .true.
    hail_data              = .false.
    w_data                 = .true.
    clw_scheme             = 1
    clw_cloud_top          = 322.
    fastem_version         = 6
    supply_foam_fraction   = .false.
    use_totalice           = .true.
    use_zeeman             = .false.
    cc_threshold           = 0.05
    ozone_data             = .false.
    co2_data               = .false.
    n2o_data               = .false.
    co_data                = .false.
    ch4_data               = .false.
    so2_data               = .false.
    addsolar               = .false.
    rayleigh_single_scatt  = .true.
    do_nlte_correction     = .false.
    solar_sea_brdf_model   = 2
    ir_sea_emis_model      = 2
    use_sfc_snow_frac      = .false.
    add_aerosl             = .false.
    aerosl_type            = 1
    add_clouds             = .true.
    ice_scheme             = 1
    use_icede              = .false.
    idg_scheme             = 2
    user_aer_opt_param     = .false.
    user_cld_opt_param     = .false.
    grid_box_avg_cloud     = .true.
    cldcol_threshold       = -1.0
    cloud_overlap          = 1
    cc_low_cloud_top       = 750.0
    ir_scatt_model         = 2
    vis_scatt_model        = 1
    dom_nstreams           = 8
    dom_accuracy           = 0.0
    dom_opdep_threshold    = 0.0
    addpc                  = .false.
    npcscores              = -1
    addradrec              = .false.
    ipcreg                 = 1
    use_htfrtc             = .false.
    htfrtc_n_pc            = -1
    htfrtc_simple_cloud    = .false.
    htfrtc_overcast        = .false.
/
&obs_seq_coverage_nml
    obs_sequences     = ''
    obs_sequence_list = 'obs_coverage_list.txt'
    obs_of_interest   = 'RADIOSONDE_TEMPERATURE', 'RADIOSONDE_U_WIND_COMPONENT', 'RADIOSONDE_V_WIND_COMPONENT'
    textfile_out      = 'obsdef_mask.txt'
    netcdf_out        = 'obsdef_mask.nc'
    calendar          = 'Gregorian'
    first_analysis    =  2008, 8, 1, 18, 0, 0
    last_analysis     =  2008, 8, 1, 18, 0, 0
    forecast_length_days          = 0
    forecast_length_seconds       = 21600
    verification_interval_seconds = 21600
    temporal_coverage_percent     = 50.0
    lonlim1    =    0.0
    lonlim2    =  360.0
    latlim1    =  -90.0
    latlim2    =   90.0
    verbose    = .true.
    debug      = .false.
/

# selections_file is a list of obs_defs output
# from the obs_seq_coverage utility.
&obs_selection_nml
    filename_seq          = 'obs_seq.out'
    filename_seq_list     = ''
    filename_out          = 'obs_seq.processed'
    selections_file       = 'obsdef_mask.txt'
    selections_is_obs_seq = .false.
    print_only            = .false.
    calendar              = 'Gregorian'
/

# one of the other, but not both
   obs_sequences = 'obs_seq.final.2008060100', 'obs_seq.final.2008060112'
   obs_sequence_list = 'obs_forecast_list.txt'
&obs_seq_verify_nml
    obs_sequences     = ''
    obs_sequence_list = 'obs_forecast_list.txt'
    input_template    = 'obsdef_mask.nc'
    netcdf_out        = 'forecast.nc'
    obtype_string     = 'RADIOSONDE_TEMPERATURE'
    print_every       = 20000
    verbose           = .true.
    debug             = .false.
/

&mpas_dart_obs_preprocess_nml
    file_name_input          = 'obs_seq.old'
    file_name_output         = 'obs_seq.new'
    include_sig_data         = .false.
    superob_aircraft         = .false.
    superob_sat_winds        = .false.
    sfc_elevation_check      = .false.
    overwrite_ncep_sfc_qc    = .false.
    overwrite_ncep_satwnd_qc = .false.
    aircraft_pres_int        = 2500.0
    sat_wind_pres_int        = 2500.0
    sfc_elevation_tol        = 300.0
    obs_pressure_top         = 1.0
    obs_height_top           = 2.0e10
    max_num_obs              = 1000000
    sonde_extra              = 'obs_seq.rawin'
    metar_extra              = 'obs_seq.metar'
    acars_extra              = 'obs_seq.acars'
    land_sfc_extra           = 'obs_seq.land_sfc'
    marine_sfc_extra         = 'obs_seq.marine'
    sat_wind_extra           = 'obs_seq.satwnd'
    profiler_extra           = 'obs_seq.profiler'
    trop_cyclone_extra       = 'obs_seq.tc'
    gpsro_extra              = 'obs_seq.gpsro'
    tc_sonde_radii           = -1.0
    overwrite_obs_time       = .false.
    windowing_obs_time       = .true.
    windowing_int_hour       = 0.5
    increase_bdy_error       = .true.
    maxobsfac                = 10.
    obsdistbdy               = 15000.0     ! meters
    obs_boundary             =  5000.0     ! meters
/
EOF

    #------------------------------------------------------
    # 4. Prepare Obs sequence for this analysis cycle
    #------------------------------------------------------

    if [[ -e OBSDIR/obs_seq.${timestr_cur} ]]; then
        mecho0 "Using observation file: ${CYAN}OBSDIR/obs_seq.${timestr_cur}${NC} as ${BROWN}obs_seq.in${NC}"
        ln -sf OBSDIR/obs_seq.${timestr_cur} obs_seq.in
    else
        if [[ $verb -eq 1 ]]; then mecho0 "run_obsmerge $wrkdir $iseconds"; fi
        run_obsmerge $wrkdir $iseconds |& tee ${wrkdir}/observations.log

        if [[ -e OBSDIR/obs_seq.${timestr_cur} ]]; then
            ln -sf OBSDIR/obs_seq.${timestr_cur} obs_seq.in
        else
            mecho0 "${YELLOW}WARNING${NC}: Observation file ${CYAN}OBSDIR/obs_seq.${timestr_cur}${NC} not found"
            touch done.filter
            no_observation=true
            return
        fi
    fi

    #------------------------------------------------------
    # 5. Run filter
    #------------------------------------------------------

    jobscript="run_filter.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="$npefilter"
        [JOBNAME]="filter-${jobname}_${eventtime}"
        [CPUSPEC]="${claim_cpu_filter}"
        [EXEDIR]="${EXEDIR}/dart"
        [ISECONDS]="${iseconds}"
        [RUNOBS2NC]="${run_obs2nc}"
        [RUNOBSDIAG]="${run_obsdiag}"
        [RUNADDNOISE]="${run_addnoise}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_filter}"
        jobParms[NCORES]="${ncores_filter}"
    fi

    submit_a_job "${wrkdir}" "filter" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" ""
}

########################################################################

function run_update_states {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, update_in_place
    #         input_file_list
    #

    #
    # Build working directory
    #
    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.update_states || -f $wrkdir/done.update_states || -f $wrkdir/queue.update_states ]]; then
        return
    fi

    currtime_fil=$(date -u -d @${iseconds} +%Y-%m-%d_%H.%M.%S)

    #------------------------------------------------------
    # Prepare update_mpas_states by copying/linking the background files
    #------------------------------------------------------
    if [[ $update_in_place == true ]]; then
        cpcmd="ln -sf"
    else
        cpcmd="cp"
        #cpcmd="rsync -a"
    fi

    # Anaysis background file list, for retrieving update_states output file name
    filter_input_file=$(awk '/input_state_file_list/{print $3}' input.nml)
    readarray -t filter_infile_array < ${filter_input_file:1:${#filter_input_file}-2}

    # update_states input file list, used as update_states input file names
    filter_output_file=$(awk '/output_state_file_list/{print $3}' input.nml)
    readarray -t update_infile_array < ${filter_output_file:1:${#filter_output_file}-2}

    jobarrays=(); stateinfiles=(); stateoutfiles=()
    for iens in $(seq 1 $ENS_SIZE); do
        (( jindex=iens-1 ))

        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        #rm -rf input.nml
        if [[ ! -e input.nml ]]; then
            cp ../input.nml .
        fi

        update_input_file='update_states_in.txt'
        rm -rf ${update_input_file}
        echo "../${update_infile_array[$jindex]}" > ${update_input_file}

        update_output_file='update_states_out.txt'
        rm -rf ${update_output_file}

        fn="../${filter_infile_array[$jindex]}"
        fnbase=$(basename $fn)
        srcfn=${fnbase/.prior./.${damode}.}
        if [[ "$srcfn" =~ ^${domname}_[0-9]{2}.init.nc$ ]]; then     # insert time to init.nc
            srcfn="${srcfn//.nc}.${currtime_fil}.nc"
        fi
        echo "./${srcfn}" > ${update_output_file}
        sed -i "/update_input_file_list/s/=.*/= '${update_input_file}'/" input.nml
        sed -i "/update_output_file_list/s/=.*/= '${update_output_file}'/" input.nml
        filename_mesh="${rundir}/init/${domname}_${memstr}.init.nc"
        sed -i "/init_template_filename/s#=.*#= '${filename_mesh}'#" input.nml

        if [[ ! -e done.update_states_${memstr} ]]; then
            jobarrays+=("$iens")
            if $relative_path; then
                stateinfiles+=("$(realpath -m --relative-to=${memwrkdir} $fn)")
            else
                stateinfiles+=("$(realpath -m $fn)")
            fi
            stateoutfiles+=("./$srcfn")
            if [[ $no_observation == true ]]; then
                ln -sf $fn $srcfn
                touch done.update_states_${memstr}
            fi
        fi

    done

    cd $wrkdir || return

    if [[ $no_observation == true ]]; then
        mecho0 "${YELLOW}WARNING${NC}: no observation, skipping ...."
        touch done.update_states
        return
    fi

    #
    # Waiting for job conditions
    #
    conditions=(done.filter)

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #------------------------------------------------------
    # Run update_mpas_states for all ensemble members
    #------------------------------------------------------

    jobscript="run_update_states.${mach}"

    echo "${jobParms[@]}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="1"
        [JOBNAME]="updatestates_${eventtime}"
        [CPUSPEC]="${claim_cpu_update}"
        [EXEDIR]="${EXEDIR}/dart"
        [CPCMD]="${cpcmd}"
        [STATEINFILESSTR]="${stateinfiles[*]}"
        [STATEOUTFILESSTR]="${stateoutfiles[*]}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="1"
        jobParms[NCORES]="1"
    fi

    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    submit_a_job "$wrkdir" "update_states" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" "${jobarraystr}"
}

########################################################################

function run_update_bc {
    # $1
    # wrkdir
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    cd $wrkdir || return

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.update_bc || -f $wrkdir/done.update_bc || -f $wrkdir/queue.update_bc ]]; then
        return
    fi

    #
    # Waiting for job conditions
    #
    conditions=("${rundir}/lbc/done.${domname}")

    if [[ $run_addnoise == true && $icycle -gt 0 ]]; then
        conditions+=("${wrkdir}/done.add_noise")
    else
        conditions+=("${wrkdir}/done.update_states")
    fi

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    if [[ ${run_updatebc} == true ]]; then
        cpcmd="cp"
        #cpcmd="rsync -a"
    else
        cpcmd="ln -sf"
    fi

    #------------------------------------------------------
    # Prepare update_bc by copying/linking the background files
    #------------------------------------------------------

    jobarrays=(); lbcfiles_org=(); lbcfiles_mem=(); lbcfiles_next=()
    for iens in $(seq 1 $ENS_SIZE); do
        #(( jindex=iens-1 ))

        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        update_output_file='update_bc_inout.txt'
        update_input_file='update_bc_in.txt'
        rm -rf ${update_output_file}
        rm -rf ${update_input_file}

        if [[ ! -e input.nml ]]; then
            mecho0 "Should have run mpas_update_states first."
        else
            state_output_file=$(awk '/update_output_file_list/{print $3}' input.nml)
            readarray -t input_file_array < ${state_output_file:1:${#state_output_file}-2}
        fi

        #
        # lbc files
        #
        jens=$(( (iens-1)%nenslbc+1 ))
        mlbcstr=$(printf "%02d" $jens)           # get LBC member string

        isec_nlbc1=$(( iseconds/3600*3600 ))
        isec_nlbc2=${isec_nlbc1}
        isec_elbc=$(( iseconds+intvl_sec ))
        while [[ $isec_elbc -gt $isec_nlbc2 ]]; do
            (( isec_nlbc2+=EXTINVL ))
        done
        # External GRIB file provided file times
        lbctime_str1=$(date -u -d @${isec_nlbc1} +%Y-%m-%d_%H.%M.%S)
        lbctime_str2=$(date -u -d @${isec_nlbc2} +%Y-%m-%d_%H.%M.%S)

        # MPAS expected boundary file times
        mpastime_str1=$(date -u -d @${iseconds}  +%Y-%m-%d_%H.%M.%S)
        mpastime_str2=${lbctime_str2}
        icycle_lbcgap=$(( isec_nlbc2-iseconds ))
        if [[ $verb -eq 1 ]]; then
            mecho0 "Member: $iens use lbc files from $rundir/lbc:"
            mecho0 "        ${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc  ${domname}_${mlbcstr}.lbc.${lbctime_str2}.nc";
        fi

        case ${relative_path} in
        true  ) lbcdir=$(realpath -m --relative-to=${memwrkdir} ${rundir}/lbc);;
        false ) lbcdir="${rundir}/lbc";;
        *     ) mecho0 "${RED}ERROR${NC}: Hi, what is this <${relative_path}>?"; exit 1;;
        esac

        #ln -sf $rundir/lbc/${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc ${domname}_${memstr}.lbc.${mpastime_str1}.nc
        lbc_file1="${lbcdir}/${domname}_${mlbcstr}.lbc.${lbctime_str1}.nc"
        lbc_file2="${lbcdir}/${domname}_${mlbcstr}.lbc.${lbctime_str2}.nc"
        lbc_filem="./${domname}_${memstr}.lbc.${mpastime_str1}.nc"

        # Should copy the initial boundary file as a starting point.
        # it is moved to the job script for parallelization to save time.
        echo "$lbc_filem" >> ${update_output_file}
        sed -i "/update_boundary_file_list/s/=.*/= '${update_output_file}'/" input.nml
        echo "${input_file_array[0]}" >> ${update_input_file}
        sed -i "/update_analysis_file_list/s/=.*/= '${update_input_file}'/" input.nml

        lbcfiles_org+=("${lbc_file1}")
        lbcfiles_next+=("${lbc_file2}")
        lbcfiles_mem+=("${lbc_filem}")

        ln -sf "${lbc_file2}" "${domname}_${memstr}.lbc.${mpastime_str2}.nc"

        jobarrays+=("$iens")
    done

    #------------------------------------------------------
    # Run update_bc for all ensemble members as a job array
    #------------------------------------------------------

    cd $wrkdir || return

    jobscript="run_update_bc.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="1"
        [JOBNAME]="updatebc_${eventtime}"
        [CPUSPEC]="${claim_cpu_update}"
        [EXEDIR]="${EXEDIR}/dart"
        [CPCMD]="${cpcmd}"
        [MPSCHEME]="${mpscheme}"
        [LBCFILEORGSTR]="${lbcfiles_org[*]}"
        [LBCFILEMEMSTR]="${lbcfiles_mem[*]}"
        [LBCFILENEXTSTR]="${lbcfiles_next[*]}"
        [UPDATEBC]="${run_updatebc}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="1"
        jobParms[NCORES]="1"
    fi

    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    submit_a_job $wrkdir "update_bc" jobParms $TEMPDIR/$jobscript $jobscript "${jobarraystr}"
}

########################################################################

function run_add_noise {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # GLOBAL: ENS_SIZE, rundir, update_in_place
    #         input_file_list
    #

    #
    # Build working directory
    #
    cd $wrkdir || return

    timestr_cur=$(date  -u -d @$iseconds    +%Y%m%d%H%M)
    read -r -a days_secs < <(convertS2days "${iseconds}")

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/done.add_noise ]]; then
        #mecho0 "add_noise is already done"
        return
    fi

    if [[ -f $wrkdir/running.noise_pert || -f $wrkdir/queue.noise_pert ]]; then
        #mecho0 "add_noise is running/queued."
        return
    fi

    seqfile="obs_seq.final.${timestr_cur}.nc"

    #------------------------------------------------------
    # Run grid_refl_obs.py for noise mask files
    #------------------------------------------------------

    if [[ ${no_observation} == true ]]; then
        mecho0 "${YELLOW}WARNING${NC}: no observation, skipping ...."
        touch done.add_noise done.noise_mask
        return
    fi

    #
    # Waiting for done.update_states
    #
    conditions=("${wrkdir}/done.update_states" "${seqfile}")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking ${CYAN}$cond${NC} ...."
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: ${CYAN}$cond${NC}"
                fi
                sleep 10
            done
        done
    fi

    if [[ ! -e done.noise_mask && ! -e running.noise_mask && ! -e queue.noise_mask && ! -e missed.noise_mask ]]; then
        if [[ $verb -eq 1 ]]; then mecho0 "Running ${WHITE}grid_refl_obs.py${NC} at ${YELLOW}${timestr_cur}${NC}"; fi

        invfile="$rundir/init/${domname}.invariant.nc"
        #
        # Create job script and submit it
        #
        runexe_str="${job_runexe_str} -n 1"

        jobscript="run_noise_mask.${mach}"

        declare -A jobParms=(
            [PARTION]="${partition_filter}"
            [NOPART]="1"
            [JOBNAME]="noise_mask_${eventtime}"
            [CPUSPEC]="${claim_cpu_update}"
            [MACHINE]="${machine}"
            [SEQFILE]="${seqfile}"
            [INVFILE]="${invfile}"
            [WAN_PATH]="${WOFSAN_PATH}"
            [EVENTDAYS]="${days_secs[0]}"
            [EVENTSECS]="${days_secs[1]}"
            [RUNCMD]="${runexe_str}"
        )
        if [[ "${mach}" == "pbs" ]]; then
            jobParms[NNODES]="1"
            jobParms[NCORES]="1"
        fi

        submit_a_job $wrkdir "noise_mask" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" ""
    fi

    #------------------------------------------------------
    # Run add_pert_where_high_refl.py for all members
    #------------------------------------------------------

    #
    # Waiting for done.noise_mask
    #
    conditions=("${wrkdir}/done.noise_mask")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking ${CYAN}$cond${NC} ...."
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: ${CYAN}$cond${NC}"
                fi
                if [[ -e "${wrkdir}/missed.noise_mask" ]]; then
                    mecho0 "${YELLOW}WARNING${NC}: No radar reflectivity obs for this cycle. Skip ${WHITE}add_noise${NC}."
                    touch "${wrkdir}/done.add_noise"
                    return
                fi
                sleep 10
            done
        done
    fi

    if [[ $verb -eq 1 ]]; then mecho0 "Running ${WHITE}add_pert_where_high_refl.py${NC} at ${YELLOW}${timestr_cur}${NC}"; fi

    invfile="$rundir/init/${domname}.invariant.nc"

    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        if [[ ! -e done.add_noise_${memstr} && ! -e running.add_noise_${memstr} ]]; then
            days_str=$(printf "%5.5i_%6.6i" ${days_secs[0]} ${days_secs[1]})
            ln -sf ../refl_obs_${days_str}.pkl ../wofs_mpas_grid_kdtree.pkl ../mpas_XYZ.pkl .
            jobarrays+=("$iens")
        fi
    done

    cd "${wrkdir}" || return

    #
    # Create job script and submit it
    #
    if [[ ${#jobarrays[@]} -gt 0 ]]; then
        jobscript="run_noise_pert.${mach}"

        runexe_str="${job_runexe_str} -n 1"

        declare -A jobParms=(
            [PARTION]="${partition_filter}"
            [NOPART]="1"
            [JOBNAME]="noist_pert_${eventtime}"
            [CPUSPEC]="${claim_cpu_update}"
            [INVFILE]="${invfile}"
            [MACHINE]="${machine}"
            [SEQFILE]="${seqfile}"
            [WAN_PATH]="${WOFSAN_PATH}"
            [EVENTDAYS]="${days_secs[0]}"
            [EVENTSECS]="${days_secs[1]}"
            [RUNCMD]="${runexe_str}"
        )
        if [[ "${mach}" == "pbs" ]]; then
            jobParms[NNODES]="1"
            jobParms[NCORES]="1"
        fi

        jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")
        submit_a_job $wrkdir "add_noise" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" "${jobarraystr}"
    fi
}

########################################################################

function run_mpas {
    # $1        $2      $3
    # wrkdir    icycle    iseconds
    local wrkdir=$1
    local icycle=$2
    local iseconds=$3

    #
    # GLOBAL: ENS_SIZE, rundir, intvl_sec, npefcst
    #

    #
    # Build working directory
    #
    mkwrkdir $wrkdir 0
    cd $wrkdir || exit $?

    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.fcst || -f $wrkdir/done.fcst || -f $wrkdir/queue.fcst ]]; then
        return
    fi

    #
    # Waiting for job conditions
    #
    conditions=("${wrkdir}/done.update_bc")

    if [[ $dorun == true ]]; then
        for cond in "${conditions[@]}"; do
            mecho0 "Checking $cond"
            while [[ ! -e $cond ]]; do
                if [[ $verb -eq 1 ]]; then
                    mecho0 "Waiting for file: $cond"
                fi
                sleep 10
            done
        done
    fi

    #
    # Preparation for all members
    #
    if [[ ! -f $rundir/$domname/$domname.graph.info.part.${npefcst} ]]; then
        split_graph "${gpmetis}" "${domname}.graph.info" "${npefcst}" "$rundir/$domname" "$dorun" "$verb"
    fi

    intvl_min=$((intvl_sec/60))

    currtime_str=$(date -u -d @${iseconds} +%Y-%m-%d_%H:%M:%S)
    currtime_fil=${currtime_str//:/.}
    #fcst_sec=$(( iseconds + intvl_sec ))
    #fcsttime_fil=$(date -u -d @${fcst_sec} +%Y-%m-%d_%H.%M.%S)

    #
    # Preparation for each member
    #
    if [[ -z ${coef_3rd_order} ]];      then coef_3rd_order=1.0;       fi
    if [[ -z ${smagorinsky_coef} ]];    then smagorinsky_coef=0.25;    fi
    if [[ -z ${visc4_2dsmag} ]];        then visc4_2dsmag=0.125;       fi
    if [[ -z ${h_mom_eddy_visc4} ]];    then h_mom_eddy_visc4=0.0;     fi
    if [[ -z ${h_theta_eddy_visc4} ]];  then h_theta_eddy_visc4=0.25;  fi
    if [[ -z ${h_scalar_eddy_visc4} ]]; then h_scalar_eddy_visc4=0.25; fi
    if [[ -z ${smdiv} ]];               then smdiv=0.1;                fi

    jobarrays=()
    for iens in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $iens)
        basen=$(( (iens-1)%6 ))
        if [[ $basen -lt 2 ]]; then     # map to 0,1,2
            idx=0
        elif [[ $basen -lt 4 ]]; then
            idx=1
        else
            idx=2
        fi
        pblscheme=${pbl_schemes[$idx]}
        sfcscheme=${sfclayer_schemes[$idx]}

        memwrkdir=$wrkdir/fcst_$memstr
        mkwrkdir $memwrkdir 0
        cd $memwrkdir  || return

        #
        # init files
        #
        if [[ $icycle -eq 0 || ${damode} == "init" ]]; then
            do_restart="false"
            do_dacyle="false"
            mpas_inputfile_template="${domname}_${memstr}.init.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
            initfile="./${domname}_${memstr}.init.${currtime_fil}.nc"
        else
            do_restart="true"
            do_dacyle="true"
            mpas_inputfile_template="${domname}_${memstr}.init.nc"
            initfile="./${domname}_${memstr}.restart.${currtime_fil}.nc"
        fi

        if [[ $verb -eq 1 ]]; then
            realinit=$(realpath -m --relative-to=. ${initfile})
            mecho0 "Member $iens init file: ${realinit}";
        fi

        if [[ ! -e ${initfile} && ${dorun} == true ]]; then
            mecho0 "${RED}ERROR${NC}: ${damode} file: ${CYAN}${initfile}${NC} not exists"
            exit 1              # something wrong should never happen
        fi

        if $relative_path; then
            casedir=$(realpath -m --relative-to=. ${rundir})
        else
            casedir="${rundir}"
        fi

        ln -sf ${casedir}/$domname/$domname.graph.info.part.${npefcst} .
        ln -sf ${casedir}/init/${domname}.invariant.nc .

        diag_stream="stream_list.atmosphere.diagnostics_da"
        if [[ ${outwrf} == true ]]; then
            diag_stream="stream_list.atmosphere.diagnostics_fcst"
        fi

        streamlists=("${diag_stream}" stream_list.atmosphere.output stream_list.atmosphere.surface)
        for fn in "${streamlists[@]}"; do
            cp -f ${FIXDIR}/$fn .
        done

        datafiles=(  CAM_ABS_DATA.DBL  CAM_AEROPT_DATA.DBL GENPARM.TBL       LANDUSE.TBL    \
                     OZONE_DAT.TBL     OZONE_LAT.TBL       OZONE_PLEV.TBL    RRTMG_LW_DATA  \
                     RRTMG_LW_DATA.DBL RRTMG_SW_DATA       RRTMG_SW_DATA.DBL SOILPARM.TBL   \
                     VEGPARM.TBL )

        for fn in "${datafiles[@]}"; do
            ln -sf ${FIXDIR}/$fn .
        done

        if [[ "${mpscheme}" == "mp_tempo" ]]; then
            thompson_tables=( MP_TEMPO_HAILAWARE_QRacrQG_DATA.DBL MP_TEMPO_QRacrQG_DATA.DBL   MP_TEMPO_QRacrQS_DATA.DBL   \
                              MP_TEMPO_freezeH2O_DATA.DBL         MP_TEMPO_QIautQS_DATA.DBL   CCN_ACTIVATE.BIN )

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        elif [[ "${mpscheme}" == "mp_thompson" ]]; then
            thompson_tables=( MP_THOMPSON_QRacrQG_DATA.DBL   MP_THOMPSON_QRacrQS_DATA.DBL   \
                              MP_THOMPSON_freezeH2O_DATA.DBL MP_THOMPSON_QIautQS_DATA.DBL CCN_ACTIVATE.BIN )

            for fn in "${thompson_tables[@]}"; do
                ln -sf ${FIXDIR}/$fn .
            done
        fi

        fcstmin_str=$(printf "%02d" "${intvl_min}")

        # the ratio of radt to dt is 15
        cat << EOF > namelist.atmosphere
&nhyd_model
    config_time_integration_order   = 2
    config_dt                       = ${time_step}
    config_start_time               = '${currtime_str}'
    config_run_duration             = '00:${fcstmin_str}:00'
    config_split_dynamics_transport = true
    config_number_of_sub_steps      = 4
    config_dynamics_split_steps     = 3
    config_h_mom_eddy_visc2         = 0.0
    config_h_mom_eddy_visc4         = ${h_mom_eddy_visc4}
    config_v_mom_eddy_visc2         = 0.0
    config_h_theta_eddy_visc2       = 0.0
    config_h_theta_eddy_visc4       = ${h_theta_eddy_visc4}
    config_v_theta_eddy_visc2       = 0.0
    config_h_scalar_eddy_visc4      = ${h_scalar_eddy_visc4}
    config_horiz_mixing             = '2d_smagorinsky'
    config_len_disp                 = 3000.0
    config_visc4_2dsmag             = ${visc4_2dsmag}
    config_w_adv_order              = 3
    config_theta_adv_order          = 3
    config_scalar_adv_order         = 3
    config_u_vadv_order             = 3
    config_w_vadv_order             = 3
    config_theta_vadv_order         = 3
    config_scalar_vadv_order        = 3
    config_scalar_advection         = true
    config_monotonic                = true
    config_coef_3rd_order           = ${coef_3rd_order}
    config_epssm                    = 0.1
    config_smdiv                    = ${smdiv}
    config_smagorinsky_coef         = ${smagorinsky_coef}
/
&damping
    config_mpas_cam_coef             = 2.0
    config_rayleigh_damp_u           = true
    config_zd                        = 16000.0
    config_xnutr                     = 0.2
    config_number_cam_damping_levels = 8
/
&limited_area
    config_apply_lbcs                = true
/
&io
    config_pio_num_iotasks           = NNNODE
    config_pio_stride                = NNCORE
/
&decomposition
    config_block_decomp_file_prefix  = '${domname}.graph.info.part.'
/
&restart
    config_do_restart                = ${do_restart}
    config_do_DAcycling              = ${do_dacyle}
/
&printout
    config_print_global_minmax_sca   = true
    config_print_global_minmax_vel   = true
    config_print_detailed_minmax_vel = false
/
&IAU
    config_IAU_option                = 'off'
    config_IAU_window_length_s       = 21600.
/
&physics
    config_sst_update                = false
    config_sstdiurn_update           = false
    config_deepsoiltemp_update       = false
    config_radtlw_interval           = '00:05:00'
    config_radtsw_interval           = '00:05:00'
    config_bucket_update             = 'none'
    config_lsm_scheme                = '${MPASLSM}'
    num_soil_layers                  = ${MPASNFLS}
    config_microp_re                 = true
    config_physics_suite             = 'convection_permitting'
    config_convection_scheme         = 'off'
    config_pbl_scheme                = '${pblscheme}'
    config_sfclayer_scheme           = '${sfcscheme}'

    config_frac_seaice         = true
    config_gwdo_scheme         = 'off'
EOF
        if [[ ${sfcscheme} == "sf_mynn" ]]; then
            cat << EOF >> namelist.atmosphere
    config_radt_cld_scheme     = 'cld_fraction_mynn'
    config_mynn_edmf_tke       = 0
    config_mynn_edmf           = 1
    config_mynn_mixqt          = 0
    config_mynn_tkeadvect      = .false.
    config_mynn_cloudpdf       = 0
    config_mynn_closure        = 2.6
    config_mynn_mixscalars     = 1
    config_mynn_edmf_output    = 0
    config_mynn_mixlength      = 1
    config_mynn_mixclouds      = 1
    config_mynn_tkebudget      = 0
    config_mynn_edmf_mom       = 1
EOF
        fi

        if [[ ${mpscheme} == "mp_nssl2m" ]]; then
            cat << EOF >> namelist.atmosphere
    config_microp_scheme             = '${mpscheme}'
/
&nssl_mp_params
    ehw0                             = 0.9
    ehlw0                            = 0.9
    icefallfac                       = 1.5
    snowfallfac                      = 1.25
    iusewetsnow                      = 0
/
EOF
        else
            echo "/" >> namelist.atmosphere
        fi

        cat << EOF >> namelist.atmosphere
&soundings
    config_sounding_interval         = 'none'
/
&assimilation
    config_jedi_da                   = false
/
&development
    config_halo_exch_method          = 'mpas_halo'
/
EOF

        (( icycle_extinvl_hr=icycle_lbcgap/3600 ))
        (( icycle_extinvl_min=(icycle_lbcgap-3600*icycle_extinvl_hr)/60 ))
        icycle_extinvl_str=$(printf "%02d:%02d:00" ${icycle_extinvl_hr} ${icycle_extinvl_min})
        #echo "icycle_extinvl_str=${icycle_extinvl_str},$icycle_extinvl_hr,$icycle_extinvl_min"

        cat << EOF > streams.atmosphere
<streams>
<immutable_stream name="input"
                  type="input"
                  filename_template="${mpas_inputfile_template}"
                  input_interval="initial_only" />

<immutable_stream name="invariant"
                  type="input"
                  filename_template="${domname}.invariant.nc"
                  input_interval="initial_only" />

<immutable_stream name="restart"
                  type="input;output"
                  filename_template="${domname}_${memstr}.restart.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  input_interval="initial_only"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" />

<stream name="output"
                  type="output"
                  filename_template="${domname}_${memstr}.history.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${OUTINVL_STR}" >

                <file name="stream_list.atmosphere.output"/>
</stream>

<stream name="diagnostics"
                  type="output"
                  filename_template="${domname}_${memstr}.diag.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  io_type="${OUTIOTYPE}"
                  clobber_mode="replace_files"
                  output_interval="${RSTINVL_STR}" >

                <file name="${diag_stream}"/>
</stream>

<stream name="surface"
                  type="input"
                  filename_template="${domname}_${memstr}.sfc_update.nc"
                  filename_interval="none"
                  input_interval="none" >

                <file name="stream_list.atmosphere.surface"/>
</stream>

<immutable_stream name="iau"
                  type="input"
                  filename_template="${domname}_${memstr}.AmB.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="none"
                  packages="iau"
                  input_interval="initial_only" />

<immutable_stream name="lbc_in"
                  type="input"
                  filename_template="${domname}_${memstr}.lbc.\$Y-\$M-\$D_\$h.\$m.\$s.nc"
                  filename_interval="input_interval"
                  packages="limited_area"
                  input_interval="${icycle_extinvl_str}" />

</streams>
EOF
        jobarrays+=("$iens")
    done

    cd $wrkdir || return

    #
    # Create job script for MPAS forecast and submit it
    #
    declare -A jobParms=(
        [PARTION]="${partition_fcst}"
        [NOPART]="$npefcst"
        [NNODES]="${nnodes_fcst}"
        [JOBNAME]="mfrd-${jobname}_${eventtime}"
        [CPUSPEC]="${claim_cpu_fcst}"
        [CLAIMTIME]="${claim_time_fcst}"
    )
    #mpas_jobscript="run_mpas.${mach}"
    jobarraystr=$(get_jobarray_str ${mach} "${jobarrays[@]}")

    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_fcst}"
        jobParms[NCORES]="${ncores_fcst}"
    fi

    submit_a_job "$wrkdir" "fcst" "jobParms" "$TEMPDIR/run_mpas_array.${mach}" "$mpas_jobscript" "${jobarraystr}"
}

########################################################################

function dacycle_driver() {
    #
    #  based on driver_mpas_dart.csh in the DART package
    #
    #  THIS IS A TOP-LEVEL DRIVER SCRIPT FOR CYCLING RUNS.
    #
    #  Required files to run this driver:
    #  1. executables:
    #       filter
    #       update_mpas_states
    #       update_bc
    #       atmosphere_model
    #
    #  Input files to run this script:
    #  A. input_state_file_list  - a list of input ensemble netcdf files for DART/filter
    #  B. output_state_file_list - a list of output ensemble netcdf files from DART/filter
    #  C. RUN_DIR/fcst_??/${mpas_filename}    - the input file listed in input_state_file_list for each member
    #  D. OBS_DIR/${obs_seq_in}.${YYYYMMDDHH} - obs sequence files for each analysis cycle (YYYYMMDDHH)
    #
    ##############################################################################################
    # USER SPECIFIED PARAMETERS
    ##############################################################################################
    # $1    $2    $3
    # init start  end
    local init_sec=$1
    local start_sec=$2
    local end_sec=$3

    #
    # Build working directory
    #
    wrkdir="$rundir/dacycles${daffix}"
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg date_end intvl_min n_cycles
    date_beg=$(date -u -d @$start_sec +%Y%m%d%H%M)
    date_end=$(date -u -d @$end_sec +%Y%m%d%H%M)
    intvl_min=$((intvl_sec/60))
    n_cycles=$(( (end_sec-start_sec)/intvl_sec+1 ))

    echo -e "Total ${n_cycles} cycles from ${GREEN}$date_beg${NC} to ${LIGHT_BLUE}$date_end${NC} will be run every $intvl_min minutes."

    if [[ $dorun == true ]]; then
        num_resubmit=2               # resubmit failed jobs
    else
        num_resubmit=0               # Just check job status
    fi

    local icyc=$(( (start_sec-init_sec)/intvl_sec ))
    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date -u -d @$isec +%H%M)

        dawrkdir=${wrkdir}/${eventtime}
        mkwrkdir $dawrkdir 0    # keep original directory
        cd $dawrkdir || return

        echo ""
        echo -e "- Cycle $icyc at ${timestr_curr} - ${CYAN}$(date +'%Y-%m-%d %H:%M:%S (%Z)')${NC}"
        time1=$(date +%s)

        no_observation=false

        #------------------------------------------------------
        # 0. Check forecast status of the early cycle or inital boundary status
        #------------------------------------------------------
        if [[ $dorun == true ]]; then
            if [[ $icyc -eq 0 ]]; then
                if [[ ! -e $rundir/lbc/done.lbc ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "${domname}" $rundir/lbc $nenslbc run_lbc.${mach}
                fi
            else   #if [[ $icyc -gt 0 ]]; then
                timesec_pre=$((isec-intvl_sec))
                event_pre=$(date -u -d @$timesec_pre  +%H%M)
                wrkdir_pre=${wrkdir}/${event_pre}
                if [[ ! -e ${wrkdir_pre}/done.fcst ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "fcst" $wrkdir_pre $ENS_SIZE run_mpas.${mach}
                fi
            fi
        fi

        #------------------------------------------------------
        # 1. Run filter
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " filter " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run filter at $eventtime"; fi
            run_filter $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 2. Run update_states for all ensemble members
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " update_states " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run update_mpas_state at $eventtime"; fi
            run_update_states $dawrkdir $isec
        fi

        #------------------------------------------------------
        # 3. Add noise (must run after update_states)
        #------------------------------------------------------

        if [[ $run_addnoise == true && $icyc -gt 0 ]]; then
            # check and set update_states status
            if [[ ! -e done.update_states ]]; then
                #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                check_job_status "update_states fcst_" $dawrkdir $ENS_SIZE run_update_states.${mach} ${num_resubmit}
            fi

            if [[ $verb -eq 1 ]]; then echo "  Run add_noise at $eventtime"; fi
            run_add_noise $dawrkdir $isec
        fi

        #------------------------------------------------------
        # 4. Run update_bc for all ensemble members
        #------------------------------------------------------
        if [[ " ${jobs[*]} " =~ " update_bc " ]]; then
            if [[ ${run_addnoise} == true && $icyc -gt 0 ]]; then   # check and set add_noise status
                if [[ ! -e done.add_noise ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "add_noise fcst_" $dawrkdir $ENS_SIZE run_noise_pert.${mach} ${num_resubmit}
                fi
            else                                     # check and set update_states status
                if [[ ! -e done.update_states ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "update_states fcst_" $dawrkdir $ENS_SIZE run_update_states.${mach} ${num_resubmit}
                fi
            fi

            if [[ $verb -eq 1 ]]; then echo "  Run update_bc at $eventtime"; fi
            run_update_bc $dawrkdir $icyc $isec
        fi

        #------------------------------------------------------
        # 5. Advance model for each member
        #------------------------------------------------------
        # Run forecast for ensemble members until the next analysis time
        if [[ " ${jobs[*]} " =~ " mpas " ]]; then
            # check and set update_bc status
            if [[ ! -e done.update_bc ]]; then
                #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                check_job_status "update_bc fcst_" $dawrkdir $ENS_SIZE run_update_bc.${mach} ${num_resubmit}
            fi

            if [[ "${eventtime}" != "0300" ]]; then
                if [[ $verb -eq 1 ]]; then echo "  Run advance model at $eventtime"; fi

                mpas_jobscript="run_mpas.${mach}"
                run_mpas $dawrkdir $icyc $isec

                if [[ ! -e done.fcst ]]; then
                    #jobname=$1 mywrkdir=$2 donenum=$3 myjobscript=$4 numtries=${5-1}
                    check_job_status "fcst" $dawrkdir $ENS_SIZE $mpas_jobscript ${num_resubmit}
                fi
            fi
        fi
        #------------------------------------------------------
        # 6. MPASSIT for each member, diagnostic purpose
        #------------------------------------------------------
        # Interpolate the forecast datasets to a virtual WRF grid

        if [[ " ${jobs[*]} " =~ " mpassit " ]]; then
            if [[ $verb -eq 1 ]]; then echo "  Run MPASSIT at $eventtime"; fi

            run_mpassit $dawrkdir ${isec}

            check_job_status "mpassit mem" $dawrkdir/mpassit $ENS_SIZE run_mpassit.${mach} ${num_resubmit}
        else
            # Clean not needed files in each member's forecast directory after
            # the MPAS forward forecast
            if [[ $outwrf == false && $icyc -gt 0 ]]; then
                rm -rf ${dawrkdir}/fcst_??/${domname}_??.{diag,history}.*
            fi
        fi

        #------------------------------------------------------
        # This DA cycle is done
        #------------------------------------------------------
        time2=$(date +%s)
        if [[ $time2 -gt $time1 ]]; then
            (( secoffset = time2-time1 )); (( minoffset = secoffset/60 )); (( secoffset = secoffset%60 ))
            echo -e "= Cycle ${eventtime} took ${CYAN}${minoffset}:${secoffset}${NC} minutes:seconds."
        fi

        (( icyc+=1 ))
    done
}

########################################################################

function run_obs_diag {
    # $1     $2
    # start  end
    local start_sec=$1
    local end_sec=$2

    #
    # Build working directory
    #
    dawrkdir="$rundir/dacycles${daffix}"
    if [[ ! -d $dawrkdir ]]; then
        mecho0 "${RED}ERROR${NC}: ${CYAN}$dawrkdir${NC} not exsit."
        exit 1
    fi
    wrkdir=$dawrkdir/obs_diag
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------
    local date_beg_str_4obsdiag date_end_str_4obsdiag intvl_min n_cycles
    date_beg_str_4obsdiag=$(date -u -d @$start_sec +%Y,%m,%d,%H,%M,%S)
    date_end_str_4obsdiag=$(date -u -d @$end_sec +%Y,%m,%d,%H,%M,%S)
    intvl_min=$((intvl_sec/60))
    date_intvl_str_4obsdiag="0, 0, 0,00,${intvl_min},00"

    n_cycles=$(( (end_sec-start_sec)/intvl_sec+1 ))

    timestr_end=$(date -u -d @$end_sec    +%H%M)
    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.obs_diag || -f $wrkdir/done.obs_diag || -f $wrkdir/queue.obs_diag ]]; then
        return
    fi

    #------------------------------------------------------
    # Prepare obs_diag
    #------------------------------------------------------
    #obs_final_files1=$(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    #obs_final_files2=$(find $dawrkdir/0???    -name obs_seq.final | sort)
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/0???    -name obs_seq.final | sort)
    obs_final_files=("${obs_final_files1[@]}" "${obs_final_files2[@]}")

    printf "%s\n" "${obs_final_files[@]}" > obs_seq.final.list

    #
    # Waiting for job conditions
    #

    if [[ ${#obs_final_files[@]} -ne ${n_cycles} ]]; then
        mecho0 "${RED}ERROR${NC}: found ${YELLOW}${#obs_final_files[@]}${NC} ${CYAN}obs_seq.final${NC} files, expected ${WHITE}${n_cycles}${NC}."
        exit 1
    fi

    cp $dawrkdir/${timestr_end}/input.nml .

    sedfile=$(mktemp -t obsdiag_nml.sed_XXXX)

    cat <<EOF > $sedfile
/obs_sequence_list/c   obs_sequence_list  = 'obs_seq.final.list'
/obs_sequence_name/c   obs_sequence_name  = ''
/first_bin_center/c    first_bin_center   = ${date_beg_str_4obsdiag}
/last_bin_center/c     last_bin_center    = ${date_end_str_4obsdiag}
/bin_width/c           bin_width          = ${date_intvl_str_4obsdiag}
/bin_separation/c      bin_separation     = ${date_intvl_str_4obsdiag}
EOF
    sed -f $sedfile -i input.nml

    #------------------------------------------------------
    # Run obs_diag for all analysis
    #------------------------------------------------------

    jobscript="run_obs_diag.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="1"
        [JOBNAME]="obsdiag_${jobname}"
        [CPUSPEC]="${claim_cpu_update}"
        [EXEDIR]="${EXEDIR}/dart"
        [EXENAME]="obs_diag"
        [PRONAME]="obs_diag"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="1"
        jobParms[NCORES]="1"
    fi

    submit_a_job "$wrkdir" "obs_diag" "jobParms" "$TEMPDIR/$jobscript" "$jobscript" ""
}

########################################################################

function run_obs_final2nc {
    # $1     $2
    # start  end
    local start_sec=$1
    local end_sec=$2

    #
    # Build working directory
    #
    dawrkdir="$rundir/dacycles${daffix}"
    if [[ ! -d $dawrkdir ]]; then
        mecho0 "${RED}ERROR${NC}: ${CYAN}$dawrkdir${NC} not exsit."
        exit 1
    fi
    wrkdir=$dawrkdir/obs_diag
    mkwrkdir $wrkdir $overwrite
    cd $wrkdir || return

    #------------------------------------------
    # Time Cylces start here
    #------------------------------------------

    n_cycles=$(( (end_sec-start_sec)/intvl_sec ))

    timestr_end=$(date -u -d @$end_sec    +%H%M)
    #
    # Return if is running or is done
    #
    if [[ -f $wrkdir/running.obs_final2nc || -f $wrkdir/done.obs_final2nc || -f $wrkdir/queue.obs_final2nc ]]; then
        return
    fi

    #------------------------------------------------------
    # Prepare obs_diag
    #------------------------------------------------------
    #obs_final_files1=$(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    #obs_final_files2=$(find $dawrkdir/0??? -name obs_seq.final | sort)
    #obs_final_files=("${obs_final_files1[@]}" "${obs_final_files2[@]}")
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/[12]??? -name obs_seq.final | sort)
    while IFS='' read -r line; do
        obs_final_files1+=("$line");
    done < <(find $dawrkdir/0???    -name obs_seq.final | sort)
    obs_final_files=("${obs_final_files1[@]}" "${obs_final_files2[@]}")

    #
    # Waiting for job conditions
    #

    if [[ ${#obs_final_files[@]} -lt ${n_cycles} ]]; then
        mecho0 "${RED}ERROR${NC}: found ${YELLOW}${#obs_final_files[@]}${NC} ${CYAN}obs_seq.final${NC} files, expected ${WHITE}${n_cycles}${NC}."
        exit 1
    fi

    cp $dawrkdir/${timestr_end}/input.nml .

    #------------------------------------------------------
    # Run obs_diag for all analysis
    #------------------------------------------------------
    #    echo "    Running ${EXEDIR}/dart/obs_seq_to_netcdf"
    #    ${runcmd_str} ${EXEDIR}/dart/obs_seq_to_netcdf >& $srunout
    #    mv obs_epoch_001.nc obs_seq.final.${timestr_cur}.nc

    jobscript="run_obs_final2nc.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="1"
        [JOBNAME]="obsdiag_${jobname}"
        [CPUSPEC]="${claim_cpu_update}"
        [EXEDIR]="${EXEDIR}/dart"
        [START_S]="${start_sec}"
        [END_S]="${end_sec}"
        [INTVL_S]="${intvl_sec}"
        [DACYCLEDIR]="${dawrkdir}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="1"
        jobParms[NCORES]="1"
    fi

    submit_a_job $wrkdir "obs_final2nc" jobParms $TEMPDIR/$jobscript $jobscript ""
}

########################################################################

function run_mpassit {
    # $1        $2
    # wrkdir    iseconds
    local wrkdir=$1
    local iseconds=$2

    #
    # Build working directory
    #
    wrkdir=$wrkdir/mpassit
    mkwrkdir $wrkdir 0
    cd $wrkdir || return

    #
    # Check MPASSIT status
    #
    if [[ -f done.mpassit ]]; then
        mecho0 "MPASSIT done for all forecast minutes"
        return
    fi

    if [[ -f running.mpassit || -f queue.mpassit ]]; then
        mecho0 "MPASSIT is running/queued for all forecast minutes"
        return
    fi

    if [[ -f error.mpassit ]]; then
        mecho0 "MPASSIT failed for all forecast minutes "
        return
    fi

    minstr=$(printf "%02d" $((intvl_sec/60)) )
    #minstr="00"
    fcst_minutes=()
    if [[ ${damode} == "init" || $icyc -eq 0 ]]; then
        fcst_minutes=("00")
    fi
    fcst_minutes+=("${minstr}")

    #
    # Prepare MPASSIT working files
    #
    if [[ ${#fcst_minutes[@]} -gt 0 ]]; then
        if [[ "${mpscheme}" == "mp_nssl2m" ]]; then
            fileappend="NSSL"
        else
            fileappend="THOM"
        fi

        jobarrays=()
        for mem in $(seq 1 $ENS_SIZE); do
            memstr=$(printf "%02d" $mem)
            memdir=$wrkdir/mem$memstr
            mkwrkdir $memdir 0
            cd $memdir || return

            rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

            # Linking working file for this member
            parmfiles=(diaglist histlist_2d histlist_3d histlist_soil)
            for fn in "${parmfiles[@]}"; do
                if [[ ! -e $fn ]]; then
                    #if [[ $verb -eq 1 ]]; then echo "Linking $fn ..."; fi
                    if [[ -e $FIXDIR/MPASSIT/${fn}.${fileappend} ]]; then
                        ln -sf $FIXDIR/MPASSIT/${fn}.${fileappend} $fn
                    elif [[ -e $FIXDIR/MPASSIT/${fn} ]]; then
                        ln -sf $FIXDIR/MPASSIT/$fn .
                    else
                        mecho0 "${RED}ERROR${NC}: file ${BLUE}$FIXDIR/MPASSIT/${fn}${NC} not exist."
                        return
                    fi
                fi
            done
            jobarrays+=("$mem")
        done

        jobarrays_str=$(get_jobarray_str "${mach}" "${jobarrays[@]}")

        cd $wrkdir || return

        run_mpassit_alltimes "${wrkdir}" "${iseconds}" "${fcst_minutes[*]}" "${jobarrays_str}"
    fi
}

########################################################################

function run_mpassit_alltimes {
    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local fcsttimes
    local -r jobarraystr=$4

    IFS=" " read -r -a fcsttimes <<< "$3"

    cd $wrkdir || return

    # Loop over forecast minutes
    local minsec=3600
    local maxsec=0

    for minstr in "${fcsttimes[@]}"; do
        (( i=10#${minstr}*60 ))
        (( i > maxsec )) && maxsec=$i
        (( i < minsec )) && minsec=$i

        prepare_mpassit_onetime $wrkdir ${iseconds} $i 5
        local estatus=$?               # number of missing members
        if [[ ${estatus} -gt 0 ]]; then
            echo -e "${PURPLE}${estatus}${NC} files missing"
            exit 1
        fi
    done

    #
    # Create job script and submit it
    #
    cd $wrkdir || return

    jobscript="run_mpassit.${mach}"

    declare -A jobParms=(
        [PARTION]="${partition_filter}"
        [NOPART]="$npepost"
        [JOBNAME]="mpassit_${eventtime}"
        [CPUSPEC]="${claim_cpu_post}"
        [CLAIMTIME]="${claim_time_mpassit_alltimes}"
        [HHMINSTR]=""
        [FCST_START]="${minsec}"
        [FCST_END]="${maxsec}"
        [FCST_INTVL]="${intvl_sec}"
    )
    if [[ "${mach}" == "pbs" ]]; then
        jobParms[NNODES]="${nnodes_post}"
        jobParms[NCORES]="${ncores_post}"
    fi

    submit_a_job "$wrkdir" "mpassit" "jobParms" "$TEMPDIR/run_mpassit_array.${mach}" "$jobscript" "$jobarraystr"
}

########################################################################

function prepare_mpassit_onetime {
    # Work for one forecast time and all ensemble members
    # 1. Wait for the history/diag files
    # 2. Create namelist files

    # $1        $2
    # wrkdir    iseconds
    local -r wrkdir=$1
    local -r iseconds=$2
    local -r fctseconds=$3
    local -r waitseconds=$4   # run all time together, it does not have to wait

    cd $wrkdir || return

    fminstr=$(printf "%03d" $((fctseconds/60)))
    fcst_lauch_time=$(date -u -d @${iseconds} +%H%M)

    isec=$(( iseconds+fctseconds ))
    fcst_time_str=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

    outdone=false
    jobarrays=()
    for mem in $(seq 1 $ENS_SIZE); do
        memstr=$(printf "%02d" $mem)
        memdir=$wrkdir/mem$memstr
        mkwrkdir $memdir 0
        cd $memdir || return

        rm -f core.*           # Maybe core-dumped, resubmission will solves the problem if the machine is unstable.

        fcstmemdir=$(upnlevels $memdir 2)
        histfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.history.${fcst_time_str}.nc"
        diagfile="$fcstmemdir/fcst_$memstr/${domname}_${memstr}.diag.${fcst_time_str}.nc"

        if [[ $dorun == true ]]; then
            for fn in $histfile $diagfile; do
                if [[ $outdone == false ]]; then
                    mecho0 "Checking forecast files at $fminstr for all $ENS_SIZE memebers from dacycles${daffix}/${fcst_lauch_time} ..."
                    outdone=true
                fi
                while [[ ! -f $fn ]]; do
                    if [[ $verb -eq 1 ]]; then
                        mecho0 "Waiting for $fn ..."
                    fi
                    sleep 10
                done
                fileage=$(( $(date +%s) - $(stat -c %Y -- "$fn") ))
                if [[ $fileage -lt $waitseconds ]]; then
                    if [[ $verb -eq 1 ]]; then mecho0 "Waiting for $fn ..."; fi
                    sleep "$waitseconds"
                fi
            done
        fi

        nmlfile="namelist.fcst_$fminstr"
        cat << EOF > $nmlfile
&config
    grid_file_input_grid = "$rundir/init/${domname}_${memstr}.init.nc"
    hist_file_input_grid = "$histfile"
    diag_file_input_grid = "$diagfile"
    file_target_grid     = "$rundir/${domname/*_/geo_}/geo_em.d01.nc"
    target_grid_type     = "file"
    output_file          = "$memdir/MPASSIT_${memstr}.${fcst_time_str}.nc"
    interp_diag          = .true.
    interp_hist          = .true.
    wrf_mod_vars         = .true.
    esmf_log             = .false.
/
EOF
    done

    cd $wrkdir || return

    return 0
}

########################################################################

function run_clean {
    # $1     $2    $3      $4
    # start  end   option  tasks
    local start_sec=$1
    local end_sec=$2
    local coption=$3
    local jobs
    read -r -a jobs <<< "$4"

    wrkdir="$rundir/dacycles${daffix}"

    if [[ "$coption" == "-a" ]]; then
        declare -A cleanmsg=(
            [mpas]="all MPAS forecast files"
            [filter]="the whole DA cycle directory"
            [update_states]="all update_states files"
            [update_bc]="all update_bc files"
        )
        for job in "${jobs[@]}"; do
            mecho0  "${YELLOW}WARNING${NC}: Delete ${cleanmsg[$job]} from $(date -u -d @${start_sec} +%Y%m%d_%H:%M:%S) to $(date -u -d @${end_sec} +%Y%m%d_%H:%M:%S)"
            mecho0  "         in ${CYAN}${wrkdir}${NC}\n"
            mecho0n "[${YELLOW}YES,NO${NC}]? "
            read -r doit
            if [[ ${doit^^} == "YES" ]]; then
                mecho0 "${YELLOW}WARNING${NC}: ${cleanmsg[$job]} will be cleaned."
            else
                mecho0 "Got ${PURPLE}${doit^^}${NC}, do nothing."
                return
            fi
        done
    fi

    local isec
    local show="echo"
    if [[ $dorun == true ]]; then
        show=""
    fi

    for isec in $(seq $start_sec $intvl_sec $end_sec ); do
        timestr_curr=$(date -u -d @$isec +%Y%m%d%H%M)
        eventtime=$(date    -u -d @$isec +%H%M)
        timestr_file=$(date -u -d @$isec +%Y-%m-%d_%H.%M.%S)

        dawrkdir=$wrkdir/$eventtime
        if [[ -d $dawrkdir ]]; then
            cd $dawrkdir || return

            if [[ $verb -eq 1 ]]; then mecho0 "Cleaning working directory ${CYAN}$dawrkdir${NC}"; fi

            for dirname in "${jobs[@]}"; do

                cd $dawrkdir || continue

                case $dirname in
                mpas )
                    ${show} rm -f fcst_??/error.fcst_* fcst_??/log.????.abort fcst_??/dart_log.*
                    ${show} rm -f fcst_??/log.atmosphere.????.{out,err}  fcst_??/namelist.output fcst_*_*.log
                    ${show} rm -f fcst_??/${domname}_??.{diag,history}.*.nc

                    if [[ "${eventtime}" =~ ??00 ]]; then
                        :       # keep lbc/{restart,init} for run MPAS free forecasts later
                    else
                        ${show} rm -f fcst_??/${domname}_??.lbc.${timestr_file}.nc
                        ${show} rm -f fcst_??/${domname}_??.{restart,init,prior}.${timestr_file}.nc
                    fi

                    ${show} rm -f fcst_??/mpas_XYZ.pkl fcst_??/wofs_mpas_grid_kdtree.pkl fcst_??/refl_*.{txt,pkl}
                    if [[ "$coption" == "-c" ]]; then
                        ${show} rm -f fcst_??/${domname}_??.{restart,init,prior}.*.nc
                    elif [[ "$coption" == "-a" ]]; then
                        ${show} rm -rf fcst_??
                    elif [[ "$coption" == "-d" ]]; then
                        ${show} rm -f fcst_??/${domname}_??.{restart,init,prior}.*.nc
                        ${show} rm -rf fcst_??/done.fcst_* fcst_??/done.update_{bc,states}_*
                    fi
                    ;;
                filter )
                    if [[ -e done.filter ]]; then
                        ${show} rm -f error.filter dart_log.{nml,out} obs_seq_to_netcdf.log filter_*.log obs_diag.log
                        ${show} rm -f preassim_*.nc output_*.nc
                        ${show} find OBSDIR -type f -not -name "obs_seq.${timestr_curr}" -exec rm -f {} \;
                        ${show} rm -f noise_mask_*.log noise_pert_*.log mpas_XYZ.pkl wofs_mpas_grid_kdtree.pkl refl_*.{txt,pkl}
                        if [[ "$coption" == "-c" ]]; then
                            ${show} rm -f ${domname}_??.analysis
                        elif [[ "$coption" == "-a" ]]; then
                            cd $wrkdir || return
                            ${show} rm -rf $eventtime
                            break
                        elif [[ "$coption" == "-d" ]]; then
                            ${show} rm -f ${domname}_??.analysis
                            ${show} rm -f done.fcst done.filter done.update_bc done.update_states
                        fi
                    fi
                    ;;
                update_states )
                    if [[ -e done.update_states ]]; then
                        ${show} rm -f error.update_states update_states_*.log
                    fi
                    ;;
                update_bc )
                    if [[ -e done.update_bc ]]; then
                        ${show} rm -f error.update_bc update_bc_*.log
                    fi
                    ;;
                esac
            done
        else
            mecho0 "${RED}ERROR${NC}: ${CYAN}$dawrkdir${NC} not exist."
        fi
    done
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
#@ MAIN entry
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

source $scpdir/Common_Utilfuncs.sh || exit $?

#-----------------------------------------------------------------------
#
# Handle command line arguments (override default settings)
#
#-----------------------------------------------------------------------
#% ARGS

parse_args "$@"

[[ -v args["verb"] ]]      && verb=${args["verb"]}           || verb=0
[[ -v args["overwrite"] ]] && overwrite=${args["overwrite"]} || overwrite=0

[[ -v args["dorun"] ]]     && dorun=${args["dorun"]}   || dorun=true
[[ -v args["rt_run"] ]]    && rt_run=${args["rt_run"]} || rt_run=false

[[ -v args["cleanoption"] ]] && cleanoption=${args["cleanoption"]}              || cleanoption="clean"
[[ -v args["cleanjobs"] ]]   && read -r -a cleanjobs <<< "${args['cleanjobs']}" || cleanjobs=()

#-----------------------------------------------------------------------
#
# Get jobs to run
#
#-----------------------------------------------------------------------

[[ -v args["jobs"] ]] && read -r -a jobs <<< "${args['jobs']}" || jobs=(filter update_states update_bc mpas clean)

#-----------------------------------------------------------------------
#
# Set up working environment
#
#-----------------------------------------------------------------------

source "${scpdir}/Site_Runtime.sh" || exit $?

#[[ ${run_trimvr} == true || ${run_addnoise} == true ]] && use_python=true || use_python=false
setup_machine "${args['machine']}" "$rootdir" true false

[[ $dorun == false ]] && runcmd="echo $runcmd"

[[ -v args["WORKDIR"] ]] && WORKDIR=${args["WORKDIR"]} || WORKDIR="${workdirDF}"

#-----------------------------------------------------------------------
# Set Event Date and Time
#-----------------------------------------------------------------------

[[ -v args["eventdate"] ]] && eventdate="${args['eventdate']}" || eventdate="$eventdateDF"
[[ -v args["eventtime"] ]] && eventtime="${args['eventtime']}" || eventtime="1500"
[[ -v args["initdatetime"] ]] && initdatetime="${args['initdatetime']}" || initdatetime="${eventdate}1500"

eventhour=${eventtime:0:2}
if ((10#$eventhour < 12)); then
    startday="1 day"
else
    startday=""
fi


if [[ -v args["endhrmin"] ]]; then
    endhrmin="${args['endhrmin']}"
    endhour=${endhrmin:0:2}
    if ((10#$endhour < 12)); then
        enddatetime=$(date -u -d "$eventdate $endhrmin 1 day" +%Y%m%d%H%M)
    else
        enddatetime=$(date -u -d "$eventdate $endhrmin" +%Y%m%d%H%M)
    fi
elif [[ -v args["enddatetime"] ]]; then
    enddatetime="${args['enddatetime']}"
else
    enddatetime=$(date -u -d "$eventdate 03:00 1 day" +%Y%m%d%H%M)
fi

inittime_sec=$(date -u -d "${initdatetime:0:8} ${initdatetime:8:4}" +%s)
starttime_sec=$(date -u -d "$eventdate ${eventtime} $startday"      +%s)
stoptime_sec=$(date -u -d "${enddatetime:0:8}  ${enddatetime:8:4}"  +%s)

#-----------------------------------------------------------------------
# read configurations that is not set from command line
#-----------------------------------------------------------------------

if [[ -v args["config_file"] ]]; then
    config_file="${args['config_file']}"

    if [[ -r ${config_file} ]]; then
        :
    elif [[ -e ${WORKDIR}/${config_file} ]]; then
        config_file="${WORKDIR}/${config_file}"
    else
        echo -e "${RED}ERROR${NC}: file ${CYAN}${WORKDIR}/${config_file}${NC} not exist."
        usage 1
    fi
else
    config_file="$WORKDIR/config.${eventdate}"
fi

if [[ ! -r ${config_file} ]]; then
    echo -e "${RED}ERROR${NC}: Configuration file ${CYAN}${config_file}${NC} is not found."
    echo -e "       Please run ${GREEN}setup_mpas-wofs.sh${NC} first."
    exit 2
else
    echo -e "Reading case configuration file: ${CYAN}${config_file}${NC} ...."
fi
readconf ${config_file} COMMON MPAS_OPTIONS dacycles || exit $?
# get ENS_SIZE, time_step, EXTINVL, ADAPTIVE_INF, update_in_place

#
# Check configurations reading in
#
if [[ "${damode}" == "restart" || "${damode}" == "init" ]]; then
    :
else
    echo -e "${RED}ERROR${NC}: damode=${damode} is not supported."
    usage 1
fi

if [[ "${mpscheme}" =~ ^(mp_nssl2m|mp_thompson|mp_tempo)$ ]]; then
    :
else
    echo -e "${RED}ERROR${NC}: mpscheme=${PURPLE}${mpscheme}${NC} is not supported."
    usage 1
fi

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Perform DA cycles
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#% ENTRY

rundir="$WORKDIR/${eventdate}"
if [[ ! -d $rundir ]]; then
    mkdir -p $rundir
fi

echo    ""
echo -e "---- Jobs (${YELLOW}$$${NC}) started at $(date +'%m-%d %H:%M:%S (%Z)') on host ${LIGHT_RED}$(hostname)${NC} ----\n"
echo -e "  Event  date: ${WHITE}$eventdate${NC} ${YELLOW}${eventtime}${NC} --> ${WHITE}${enddatetime:0:8}${NC} ${YELLOW}${enddatetime:8:4}${NC}"
echo -e "  ROOT    dir: ${rootdir}${BROWN}/scripts${NC}"
echo -e "  TEMP    dir: ${PURPLE}${TEMPDIR}${NC}"
echo -e "  FIXED   dir: ${DARK}${FIXDIR}${NC}"
echo -e "  EXEC    dir: ${GREEN}${EXEDIR}${NC}"
echo -e "  Working dir: ${WHITE}${WORKDIR}${LIGHT_BLUE}/${eventdate}/dacycles${daffix}${NC}"
echo -e "  Domain name: ${RED}$domname${NC};  MP scheme: ${CYAN}${mpscheme}${NC}"
echo    " "

jobname="${eventdate:4:4}"

RSTINVL=${intvl_sec}
if [[ ${outwrf} == true ]]; then
    jobs+=(mpassit)
    OUTINVL=${RSTINVL}
else
    OUTINVL=$((2*RSTINVL))
fi


RSTINVL_STR=$(printf "00:%02d:00" $((RSTINVL/60)) )
OUTINVL_STR=$(printf "00:%02d:00" $((OUTINVL/60)) )

#
# Start the data assimilation cycles
#

# $1    $2    $3
# init start  end
if [[ " ${jobs[*]} " =~ " "(filter|mpas|update_states|update_bc)" " ]]; then
    dacycle_driver $inittime_sec $starttime_sec $stoptime_sec
elif [[ " ${jobs[*]} " =~ " "(obs_diag|obs_final2nc)" " ]]; then
    for job in "${jobs[@]}"; do
        run_${job} ${starttime_sec} ${stoptime_sec}
    done
elif [[ " ${jobs[*]} " =~ " clean " ]]; then

    if [[ ${#cleanjobs[@]} -eq 0 ]]; then
        cleanjobs=(mpas filter update_states update_bc)
    fi
    run_clean "${starttime_sec}" "${stoptime_sec}" "${cleanoption}" "${cleanjobs[*]}"
fi

echo -e "\n==== Jobs done $(date +'%m-%d %H:%M:%S (%Z)') ====\n"

exit 0
